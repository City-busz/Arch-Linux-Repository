## Description: add some description
## Origin/Author: add some origin or author
## Bug: bug URL
Index: gtk+-2.24.4/gtk/gtk.symbols
===================================================================
--- gtk+-2.24.4.orig/gtk/gtk.symbols	2011-04-04 10:57:59.396596969 +1000
+++ gtk+-2.24.4/gtk/gtk.symbols	2011-04-04 10:58:00.236596968 +1000
@@ -5381,6 +5381,7 @@
 gtk_window_get_modal
 gtk_window_get_position
 gtk_window_get_resizable
+gtk_window_get_resize_grip_area
 gtk_window_get_role
 gtk_window_get_screen
 gtk_window_get_size
@@ -5416,6 +5417,7 @@
 gtk_window_remove_mnemonic
 gtk_window_reshow_with_initial_size
 gtk_window_resize
+gtk_window_resize_grip_is_visible
 gtk_window_set_accept_focus
 gtk_window_set_auto_startup_notification
 gtk_window_set_decorated
@@ -5443,6 +5445,8 @@
 gtk_window_get_has_frame
 gtk_window_set_has_frame
 #endif
+gtk_window_get_has_resize_grip
+gtk_window_set_has_resize_grip
 gtk_window_set_icon
 #ifndef _WIN64
 gtk_window_set_icon_from_file PRIVATE
Index: gtk+-2.24.4/gtk/gtkalias.h
===================================================================
--- gtk+-2.24.4.orig/gtk/gtkalias.h	2011-04-02 08:43:12.000000000 +1100
+++ gtk+-2.24.4/gtk/gtkalias.h	2011-04-04 10:58:00.236596968 +1000
@@ -12827,6 +12827,9 @@
 extern __typeof (gtk_window_get_group) IA__gtk_window_get_group __attribute((visibility("hidden")));
 #define gtk_window_get_group IA__gtk_window_get_group
 
+extern __typeof (gtk_window_get_has_resize_grip) IA__gtk_window_get_has_resize_grip __attribute((visibility("hidden")));
+#define gtk_window_get_has_resize_grip IA__gtk_window_get_has_resize_grip
+
 extern __typeof (gtk_window_get_icon) IA__gtk_window_get_icon __attribute((visibility("hidden")));
 #define gtk_window_get_icon IA__gtk_window_get_icon
 
@@ -12851,6 +12854,9 @@
 extern __typeof (gtk_window_get_resizable) IA__gtk_window_get_resizable __attribute((visibility("hidden")));
 #define gtk_window_get_resizable IA__gtk_window_get_resizable
 
+extern __typeof (gtk_window_get_resize_grip_area) IA__gtk_window_get_resize_grip_area __attribute((visibility("hidden")));
+#define gtk_window_get_resize_grip_area IA__gtk_window_get_resize_grip_area
+
 extern __typeof (gtk_window_get_role) IA__gtk_window_get_role __attribute((visibility("hidden")));
 #define gtk_window_get_role IA__gtk_window_get_role
 
@@ -12956,6 +12962,9 @@
 extern __typeof (gtk_window_resize) IA__gtk_window_resize __attribute((visibility("hidden")));
 #define gtk_window_resize IA__gtk_window_resize
 
+extern __typeof (gtk_window_resize_grip_is_visible) IA__gtk_window_resize_grip_is_visible __attribute((visibility("hidden")));
+#define gtk_window_resize_grip_is_visible IA__gtk_window_resize_grip_is_visible
+
 extern __typeof (gtk_window_set_accept_focus) IA__gtk_window_set_accept_focus __attribute((visibility("hidden")));
 #define gtk_window_set_accept_focus IA__gtk_window_set_accept_focus
 
Index: gtk+-2.24.4/gtk/gtkaliasdef.c
===================================================================
--- gtk+-2.24.4.orig/gtk/gtkaliasdef.c	2011-04-02 08:43:10.000000000 +1100
+++ gtk+-2.24.4/gtk/gtkaliasdef.c	2011-04-04 10:58:00.246596968 +1000
@@ -12830,6 +12830,9 @@
 #undef gtk_window_get_group 
 extern __typeof (gtk_window_get_group) gtk_window_get_group __attribute((alias("IA__gtk_window_get_group"), visibility("default")));
 
+#undef gtk_window_get_has_resize_grip 
+extern __typeof (gtk_window_get_has_resize_grip) gtk_window_get_has_resize_grip __attribute((alias("IA__gtk_window_get_has_resize_grip"), visibility("default")));
+
 #undef gtk_window_get_icon 
 extern __typeof (gtk_window_get_icon) gtk_window_get_icon __attribute((alias("IA__gtk_window_get_icon"), visibility("default")));
 
@@ -12854,6 +12857,9 @@
 #undef gtk_window_get_resizable 
 extern __typeof (gtk_window_get_resizable) gtk_window_get_resizable __attribute((alias("IA__gtk_window_get_resizable"), visibility("default")));
 
+#undef gtk_window_get_resize_grip_area 
+extern __typeof (gtk_window_get_resize_grip_area) gtk_window_get_resize_grip_area __attribute((alias("IA__gtk_window_get_resize_grip_area"), visibility("default")));
+
 #undef gtk_window_get_role 
 extern __typeof (gtk_window_get_role) gtk_window_get_role __attribute((alias("IA__gtk_window_get_role"), visibility("default")));
 
@@ -12959,6 +12965,9 @@
 #undef gtk_window_resize 
 extern __typeof (gtk_window_resize) gtk_window_resize __attribute((alias("IA__gtk_window_resize"), visibility("default")));
 
+#undef gtk_window_resize_grip_is_visible 
+extern __typeof (gtk_window_resize_grip_is_visible) gtk_window_resize_grip_is_visible __attribute((alias("IA__gtk_window_resize_grip_is_visible"), visibility("default")));
+
 #undef gtk_window_set_accept_focus 
 extern __typeof (gtk_window_set_accept_focus) gtk_window_set_accept_focus __attribute((alias("IA__gtk_window_set_accept_focus"), visibility("default")));
 
Index: gtk+-2.24.4/gtk/gtkassistant.c
===================================================================
--- gtk+-2.24.4.orig/gtk/gtkassistant.c	2011-02-20 01:31:37.000000000 +1100
+++ gtk+-2.24.4/gtk/gtkassistant.c	2011-04-04 10:58:00.246596968 +1000
@@ -1413,6 +1413,9 @@
     {
       container = GTK_CONTAINER (widget);
 
+      if (GTK_WIDGET_CLASS (gtk_assistant_parent_class)->expose_event)
+        GTK_WIDGET_CLASS (gtk_assistant_parent_class)->expose_event (widget, event);
+
       assistant_paint_colored_box (widget);
 
       gtk_container_propagate_expose (container, priv->header_image, event);
Index: gtk+-2.24.4/gtk/gtkrange.c
===================================================================
--- gtk+-2.24.4.orig/gtk/gtkrange.c	2011-03-18 11:14:36.000000000 +1100
+++ gtk+-2.24.4/gtk/gtkrange.c	2011-04-04 10:58:00.246596968 +1000
@@ -39,6 +39,7 @@
 #include "gtkrange.h"
 #include "gtkscale.h"
 #include "gtkscrollbar.h"
+#include "gtkwindow.h"
 #include "gtkprivate.h"
 #include "gtkintl.h"
 #include "gtkalias.h"
@@ -149,6 +150,8 @@
                                       GtkRequisition   *requisition);
 static void gtk_range_size_allocate  (GtkWidget        *widget,
                                       GtkAllocation    *allocation);
+static void gtk_range_hierarchy_changed (GtkWidget     *widget,
+                                         GtkWidget     *previous_toplevel);
 static void gtk_range_realize        (GtkWidget        *widget);
 static void gtk_range_unrealize      (GtkWidget        *widget);
 static void gtk_range_map            (GtkWidget        *widget);
@@ -179,6 +182,8 @@
 				      gint              mouse_x,
 				      gint              mouse_y);
 static void stop_scrolling           (GtkRange         *range);
+static gboolean modify_allocation_for_window_grip (GtkWidget     *widget,
+                                                   GtkAllocation *allocation);
 
 /* Range methods */
 
@@ -257,8 +262,9 @@
 
   widget_class->size_request = gtk_range_size_request;
   widget_class->size_allocate = gtk_range_size_allocate;
+  widget_class->hierarchy_changed = gtk_range_hierarchy_changed;
   widget_class->realize = gtk_range_realize;
-  widget_class->unrealize = gtk_range_unrealize;  
+  widget_class->unrealize = gtk_range_unrealize;
   widget_class->map = gtk_range_map;
   widget_class->unmap = gtk_range_unmap;
   widget_class->expose_event = gtk_range_expose;
@@ -1534,6 +1540,67 @@
   requisition->height = range_rect.height + border.top + border.bottom;
 }
 
+static gboolean
+modify_allocation_for_window_grip (GtkWidget     *widget,
+                                   GtkAllocation *allocation)
+{
+  GtkRange *range = GTK_RANGE (widget);
+  GtkWidget *window;
+  GdkRectangle grip_rect;
+  GdkRectangle translated_rect;
+  gint border_width;
+  gint x;
+  gint y;
+
+  window = gtk_widget_get_toplevel (widget);
+  if (!GTK_IS_WINDOW (window))
+    return FALSE;
+
+  if (!gtk_window_resize_grip_is_visible (GTK_WINDOW (window)))
+    return FALSE;
+
+  /* Get the area of the window's corner grip */
+  gtk_window_get_resize_grip_area (GTK_WINDOW (window), &grip_rect);
+
+  x = 0;
+  y = 0;
+
+  /* Translate the stepper's area into window coords */
+  if (gtk_widget_translate_coordinates (gtk_widget_get_parent (widget),
+                                        window,
+                                        allocation->x,
+                                        allocation->y,
+                                        &x,
+                                        &y))
+    {
+      translated_rect.x = x;
+      translated_rect.y = y;
+      translated_rect.width = allocation->width;
+      translated_rect.height = allocation->height;
+
+      border_width = gtk_container_get_border_width (GTK_CONTAINER (window));
+
+      /* If the stepper button intersects the window resize grip.. */
+      if (gdk_rectangle_intersect (&grip_rect, &translated_rect, NULL))
+        {
+          if (range->orientation == GTK_ORIENTATION_HORIZONTAL)
+            {
+              allocation->width -= (grip_rect.width - border_width);
+              if (gtk_widget_get_direction (window) == GTK_TEXT_DIR_RTL)
+                allocation->x += grip_rect.width;
+            }
+          else
+            {
+              allocation->height -= (grip_rect.height - border_width);
+            }
+
+          return TRUE;
+        }
+    }
+
+  return FALSE;
+}
+
 static void
 gtk_range_size_allocate (GtkWidget     *widget,
                          GtkAllocation *allocation)
@@ -1542,6 +1609,7 @@
 
   range = GTK_RANGE (widget);
 
+  modify_allocation_for_window_grip (widget, allocation);
   widget->allocation = *allocation;
   
   range->layout->recalc_marks = TRUE;
@@ -1558,11 +1626,36 @@
 }
 
 static void
+resize_grip_visible_changed (GObject    *object,
+                             GParamSpec *pspec,
+                             gpointer    user_data)
+{
+  gtk_widget_queue_resize (GTK_WIDGET (user_data));
+}
+
+static void
+gtk_range_hierarchy_changed (GtkWidget *widget,
+                             GtkWidget *previous_toplevel)
+{
+  GtkWidget *window;
+
+  if (previous_toplevel)
+    g_signal_handlers_disconnect_by_func (previous_toplevel,
+                                          G_CALLBACK (resize_grip_visible_changed),
+                                          widget);
+  window = gtk_widget_get_toplevel (widget);
+  if (GTK_IS_WINDOW (window))
+    g_signal_connect (window, "notify::resize-grip-visible",
+                      G_CALLBACK (resize_grip_visible_changed), widget);
+}
+
+static void
 gtk_range_realize (GtkWidget *widget)
 {
   GtkRange *range;
   GdkWindowAttr attributes;
-  gint attributes_mask;  
+  gint attributes_mask;
+  GtkAllocation allocation;
 
   range = GTK_RANGE (widget);
 
@@ -1572,7 +1665,11 @@
 
   widget->window = gtk_widget_get_parent_window (widget);
   g_object_ref (widget->window);
-  
+
+  gtk_widget_get_allocation (widget, &allocation);
+  if (modify_allocation_for_window_grip (widget, &allocation))
+    gtk_widget_set_allocation (widget, &allocation);
+
   attributes.window_type = GDK_WINDOW_CHILD;
   attributes.x = widget->allocation.x;
   attributes.y = widget->allocation.y;
Index: gtk+-2.24.4/gtk/gtkstatusbar.c
===================================================================
--- gtk+-2.24.4.orig/gtk/gtkstatusbar.c	2011-02-20 01:31:37.000000000 +1100
+++ gtk+-2.24.4/gtk/gtkstatusbar.c	2011-04-04 10:58:00.246596968 +1000
@@ -72,20 +72,8 @@
 static void     gtk_statusbar_unrealize         (GtkWidget         *widget);
 static void     gtk_statusbar_map               (GtkWidget         *widget);
 static void     gtk_statusbar_unmap             (GtkWidget         *widget);
-static gboolean gtk_statusbar_button_press      (GtkWidget         *widget,
-						 GdkEventButton    *event);
-static gboolean gtk_statusbar_expose_event      (GtkWidget         *widget,
-						 GdkEventExpose    *event);
-static void     gtk_statusbar_size_request      (GtkWidget         *widget,
-						 GtkRequisition    *requisition);
 static void     gtk_statusbar_size_allocate     (GtkWidget         *widget,
 						 GtkAllocation     *allocation);
-static void     gtk_statusbar_direction_changed (GtkWidget         *widget,
-						 GtkTextDirection   prev_dir);
-static void     gtk_statusbar_state_changed     (GtkWidget        *widget,
-                                                 GtkStateType      previous_state);
-static void     gtk_statusbar_create_window     (GtkStatusbar      *statusbar);
-static void     gtk_statusbar_destroy_window    (GtkStatusbar      *statusbar);
 static void     gtk_statusbar_get_property      (GObject           *object,
 						 guint              prop_id,
 						 GValue            *value,
@@ -125,13 +113,8 @@
   widget_class->unrealize = gtk_statusbar_unrealize;
   widget_class->map = gtk_statusbar_map;
   widget_class->unmap = gtk_statusbar_unmap;
-  widget_class->button_press_event = gtk_statusbar_button_press;
-  widget_class->expose_event = gtk_statusbar_expose_event;
-  widget_class->size_request = gtk_statusbar_size_request;
   widget_class->size_allocate = gtk_statusbar_size_allocate;
-  widget_class->direction_changed = gtk_statusbar_direction_changed;
-  widget_class->state_changed = gtk_statusbar_state_changed;
-  
+
   class->text_pushed = gtk_statusbar_update;
   class->text_popped = gtk_statusbar_update;
   
@@ -550,21 +533,7 @@
   if (setting != statusbar->has_resize_grip)
     {
       statusbar->has_resize_grip = setting;
-      gtk_widget_queue_resize (statusbar->label);
-      gtk_widget_queue_draw (GTK_WIDGET (statusbar));
 
-      if (gtk_widget_get_realized (GTK_WIDGET (statusbar)))
-        {
-          if (statusbar->has_resize_grip && statusbar->grip_window == NULL)
-	    {
-	      gtk_statusbar_create_window (statusbar);
-	      if (gtk_widget_get_mapped (GTK_WIDGET (statusbar)))
-		gdk_window_show (statusbar->grip_window);
-	    }
-          else if (!statusbar->has_resize_grip && statusbar->grip_window != NULL)
-            gtk_statusbar_destroy_window (statusbar);
-        }
-      
       g_object_notify (G_OBJECT (statusbar), "has-resize-grip");
     }
 }
@@ -678,123 +647,6 @@
 }
 
 static void
-get_grip_rect (GtkStatusbar *statusbar,
-               GdkRectangle *rect)
-{
-  GtkWidget *widget;
-  gint w, h;
-  
-  widget = GTK_WIDGET (statusbar);
-
-  /* These are in effect the max/default size of the grip. */
-  w = 18;
-  h = 18;
-
-  if (w > widget->allocation.width)
-    w = widget->allocation.width;
-
-  if (h > widget->allocation.height - widget->style->ythickness)
-    h = widget->allocation.height - widget->style->ythickness;
-  
-  rect->width = w;
-  rect->height = h;
-  rect->y = widget->allocation.y + widget->allocation.height - h;
-
-  if (gtk_widget_get_direction (widget) == GTK_TEXT_DIR_LTR) 
-    rect->x = widget->allocation.x + widget->allocation.width - w;
-  else 
-    rect->x = widget->allocation.x + widget->style->xthickness;
-}
-
-static void
-set_grip_cursor (GtkStatusbar *statusbar)
-{
-  if (statusbar->has_resize_grip && statusbar->grip_window != NULL)
-    {
-      GtkWidget *widget = GTK_WIDGET (statusbar);
-      GdkDisplay *display = gtk_widget_get_display (widget);
-      GdkCursorType cursor_type;
-      GdkCursor *cursor;
-      
-      if (gtk_widget_is_sensitive (widget))
-        {
-          if (gtk_widget_get_direction (widget) == GTK_TEXT_DIR_LTR)
-	    cursor_type = GDK_BOTTOM_RIGHT_CORNER;
-          else
-	    cursor_type = GDK_BOTTOM_LEFT_CORNER;
-
-          cursor = gdk_cursor_new_for_display (display, cursor_type);
-          gdk_window_set_cursor (statusbar->grip_window, cursor);
-          gdk_cursor_unref (cursor);
-        }
-      else
-        gdk_window_set_cursor (statusbar->grip_window, NULL);
-    }
-}
-
-static void
-gtk_statusbar_create_window (GtkStatusbar *statusbar)
-{
-  GtkWidget *widget;
-  GdkWindowAttr attributes;
-  gint attributes_mask;
-  GdkRectangle rect;
-
-  widget = GTK_WIDGET (statusbar);
-
-  g_return_if_fail (gtk_widget_get_realized (widget));
-  g_return_if_fail (statusbar->has_resize_grip);
-
-  get_grip_rect (statusbar, &rect);
-
-  attributes.x = rect.x;
-  attributes.y = rect.y;
-  attributes.width = rect.width;
-  attributes.height = rect.height;
-  attributes.window_type = GDK_WINDOW_CHILD;
-  attributes.wclass = GDK_INPUT_ONLY;
-  attributes.event_mask = gtk_widget_get_events (widget) |
-    GDK_BUTTON_PRESS_MASK;
-
-  attributes_mask = GDK_WA_X | GDK_WA_Y;
-
-  statusbar->grip_window = gdk_window_new (widget->window,
-                                           &attributes, attributes_mask);
-
-  gdk_window_set_user_data (statusbar->grip_window, widget);
-
-  gdk_window_raise (statusbar->grip_window);
-
-  set_grip_cursor (statusbar);
-}
-
-static void
-gtk_statusbar_direction_changed (GtkWidget        *widget,
-				 GtkTextDirection  prev_dir)
-{
-  GtkStatusbar *statusbar = GTK_STATUSBAR (widget);
-
-  set_grip_cursor (statusbar);
-}
-
-static void
-gtk_statusbar_state_changed (GtkWidget    *widget,
-	                     GtkStateType  previous_state)   
-{
-  GtkStatusbar *statusbar = GTK_STATUSBAR (widget);
-
-  set_grip_cursor (statusbar);
-}
-
-static void
-gtk_statusbar_destroy_window (GtkStatusbar *statusbar)
-{
-  gdk_window_set_user_data (statusbar->grip_window, NULL);
-  gdk_window_destroy (statusbar->grip_window);
-  statusbar->grip_window = NULL;
-}
-
-static void
 gtk_statusbar_realize (GtkWidget *widget)
 {
   GtkStatusbar *statusbar;
@@ -802,9 +654,6 @@
   statusbar = GTK_STATUSBAR (widget);
 
   GTK_WIDGET_CLASS (gtk_statusbar_parent_class)->realize (widget);
-
-  if (statusbar->has_resize_grip)
-    gtk_statusbar_create_window (statusbar);
 }
 
 static void
@@ -814,9 +663,6 @@
 
   statusbar = GTK_STATUSBAR (widget);
 
-  if (statusbar->grip_window)
-    gtk_statusbar_destroy_window (statusbar);
-
   GTK_WIDGET_CLASS (gtk_statusbar_parent_class)->unrealize (widget);
 }
 
@@ -828,9 +674,6 @@
   statusbar = GTK_STATUSBAR (widget);
 
   GTK_WIDGET_CLASS (gtk_statusbar_parent_class)->map (widget);
-
-  if (statusbar->grip_window)
-    gdk_window_show (statusbar->grip_window);
 }
 
 static void
@@ -840,103 +683,9 @@
 
   statusbar = GTK_STATUSBAR (widget);
 
-  if (statusbar->grip_window)
-    gdk_window_hide (statusbar->grip_window);
-
   GTK_WIDGET_CLASS (gtk_statusbar_parent_class)->unmap (widget);
 }
 
-static gboolean
-gtk_statusbar_button_press (GtkWidget      *widget,
-                            GdkEventButton *event)
-{
-  GtkStatusbar *statusbar;
-  GtkWidget *ancestor;
-  GdkWindowEdge edge;
-  
-  statusbar = GTK_STATUSBAR (widget);
-  
-  if (!statusbar->has_resize_grip ||
-      event->type != GDK_BUTTON_PRESS ||
-      event->window != statusbar->grip_window)
-    return FALSE;
-  
-  ancestor = gtk_widget_get_toplevel (widget);
-
-  if (!GTK_IS_WINDOW (ancestor))
-    return FALSE;
-
-  edge = get_grip_edge (statusbar);
-
-  if (event->button == 1)
-    gtk_window_begin_resize_drag (GTK_WINDOW (ancestor),
-                                  edge,
-                                  event->button,
-                                  event->x_root, event->y_root,
-                                  event->time);
-  else if (event->button == 2)
-    gtk_window_begin_move_drag (GTK_WINDOW (ancestor),
-                                event->button,
-                                event->x_root, event->y_root,
-                                event->time);
-  else
-    return FALSE;
-  
-  return TRUE;
-}
-
-static gboolean
-gtk_statusbar_expose_event (GtkWidget      *widget,
-                            GdkEventExpose *event)
-{
-  GtkStatusbar *statusbar;
-  GdkRectangle rect;
-  
-  statusbar = GTK_STATUSBAR (widget);
-
-  GTK_WIDGET_CLASS (gtk_statusbar_parent_class)->expose_event (widget, event);
-
-  if (statusbar->has_resize_grip)
-    {
-      GdkWindowEdge edge;
-      
-      edge = get_grip_edge (statusbar);
-
-      get_grip_rect (statusbar, &rect);
-
-      gtk_paint_resize_grip (widget->style,
-                             widget->window,
-                             gtk_widget_get_state (widget),
-                             &event->area,
-                             widget,
-                             "statusbar",
-                             edge,
-                             rect.x, rect.y,
-                             /* don't draw grip over the frame, though you
-                              * can click on the frame.
-                              */
-                             rect.width - widget->style->xthickness,
-                             rect.height - widget->style->ythickness);
-    }
-
-  return FALSE;
-}
-
-static void
-gtk_statusbar_size_request (GtkWidget      *widget,
-			    GtkRequisition *requisition)
-{
-  GtkStatusbar *statusbar;
-  GtkShadowType shadow_type;
-  
-  statusbar = GTK_STATUSBAR (widget);
-
-  gtk_widget_style_get (GTK_WIDGET (statusbar), "shadow-type", &shadow_type, NULL);  
-  gtk_frame_set_shadow_type (GTK_FRAME (statusbar->frame), shadow_type);
-  
-  GTK_WIDGET_CLASS (gtk_statusbar_parent_class)->size_request (widget, requisition);
-}
-
 /* look for extra children between the frame containing
  * the label and where we want to draw the resize grip 
  */
@@ -979,40 +728,62 @@
 {
   GtkStatusbar *statusbar = GTK_STATUSBAR (widget);
   gboolean extra_children = FALSE;
+  gboolean has_resize_grip = FALSE;
   GdkRectangle rect;
-
-  if (statusbar->has_resize_grip)
-    {
-      get_grip_rect (statusbar, &rect);
-
-      extra_children = has_extra_children (statusbar);
-
-      /* If there are extra children, we don't want them to occupy
-       * the space where we draw the resize grip, so we temporarily
-       * shrink the allocation.
-       * If there are no extra children, we want the frame to get
-       * the full allocation, and we fix up the allocation of the
-       * label afterwards to make room for the grip.
-       */
-      if (extra_children)
-	{
-	  allocation->width -= rect.width;
-	  if (gtk_widget_get_direction (widget) == GTK_TEXT_DIR_RTL) 
-	    allocation->x += rect.width;
-	}
+  GtkWidget *window;
+  gint x, y;
+  GdkRectangle translated_rect;
+
+  window = gtk_widget_get_toplevel (widget);
+  if (GTK_IS_WINDOW (window) && gtk_window_resize_grip_is_visible (GTK_WINDOW (window)))
+    {
+      gtk_window_get_resize_grip_area (GTK_WINDOW (window), &rect);
+
+      if (gtk_widget_translate_coordinates (gtk_widget_get_parent (widget),
+                                            window,
+                                            allocation->x,
+                                            allocation->y,
+                                            &x,
+                                            &y))
+        {
+          translated_rect.x = x;
+          translated_rect.y = y;
+          translated_rect.width = allocation->width;
+          translated_rect.height = allocation->height;
+
+          if (gdk_rectangle_intersect (&rect, &translated_rect, NULL))
+            {
+              has_resize_grip = TRUE;
+              extra_children = has_extra_children (statusbar);
+
+              /* If there are extra children, we don't want them to occupy
+               * the space where we draw the resize grip, so we temporarily
+               * shrink the allocation.
+               * If there are no extra children, we want the frame to get
+               * the full allocation, and we fix up the allocation of the
+               * label afterwards to make room for the grip.
+               */
+              if (extra_children)
+                {
+                  allocation->width -= rect.width;
+                  if (gtk_widget_get_direction (widget) == GTK_TEXT_DIR_RTL)
+                    allocation->x += rect.width;
+                }
+            }
+        }
     }
 
   /* chain up normally */
   GTK_WIDGET_CLASS (gtk_statusbar_parent_class)->size_allocate (widget, allocation);
 
-  if (statusbar->has_resize_grip)
+  if (has_resize_grip)
     {
-      if (extra_children) 
-	{
-	  allocation->width += rect.width;
-	  if (gtk_widget_get_direction (widget) == GTK_TEXT_DIR_RTL) 
-	    allocation->x -= rect.width;
-	  
+      if (extra_children)
+        {
+          allocation->width += rect.width;
+          if (gtk_widget_get_direction (widget) == GTK_TEXT_DIR_RTL)
+            allocation->x -= rect.width;
+
 	  widget->allocation = *allocation;
 	}
       else
@@ -1036,17 +807,6 @@
 	      gtk_widget_size_allocate (child, allocation);
 	    }
 	}
-
-      if (statusbar->grip_window)
-	{
-          get_grip_rect (statusbar, &rect);
-
-	  gdk_window_raise (statusbar->grip_window);
-	  gdk_window_move_resize (statusbar->grip_window,
-				  rect.x, rect.y,
-				  rect.width, rect.height);
-	}
-
     }
 }
 
Index: gtk+-2.24.4/gtk/gtkwindow.c
===================================================================
--- gtk+-2.24.4.orig/gtk/gtkwindow.c	2011-04-04 10:57:59.406596969 +1000
+++ gtk+-2.24.4/gtk/gtkwindow.c	2011-04-04 10:58:00.246596968 +1000
@@ -95,6 +95,8 @@
   PROP_TRANSIENT_FOR,
   PROP_OPACITY,
   PROP_NO_PROXY,
+  PROP_HAS_RESIZE_GRIP,
+  PROP_RESIZE_GRIP_VISIBLE,
 
   /* Readonly properties */
   PROP_IS_ACTIVE,
@@ -198,6 +200,10 @@
 
   gboolean no_proxy;
 
+  gboolean   has_resize_grip;
+  GdkWindow *grip_window;
+  gboolean   resize_grip_visible;
+
   gchar *startup_id;
 };
 
@@ -226,6 +232,8 @@
 					   GdkEventKey       *event);
 static gint gtk_window_key_release_event  (GtkWidget         *widget,
 					   GdkEventKey       *event);
+static gint gtk_window_button_press_event (GtkWidget         *widget,
+                                           GdkEventButton    *event);
 static gint gtk_window_enter_notify_event (GtkWidget         *widget,
 					   GdkEventCrossing  *event);
 static gint gtk_window_leave_notify_event (GtkWidget         *widget,
@@ -236,11 +244,17 @@
 					   GdkEventFocus     *event);
 static gint gtk_window_client_event	  (GtkWidget	     *widget,
 					   GdkEventClient    *event);
+static gboolean gtk_window_state_event    (GtkWidget          *widget,
+                                           GdkEventWindowState *event);
 static void gtk_window_check_resize       (GtkContainer      *container);
 static gint gtk_window_focus              (GtkWidget        *widget,
 				           GtkDirectionType  direction);
 static void gtk_window_real_set_focus     (GtkWindow         *window,
 					   GtkWidget         *focus);
+static void gtk_window_direction_changed  (GtkWidget         *widget,
+                                           GtkTextDirection   prev_dir);
+static void gtk_window_state_changed      (GtkWidget         *widget,
+                                           GtkStateType       previous_state);
 
 static void gtk_window_real_activate_default (GtkWindow         *window);
 static void gtk_window_real_activate_focus   (GtkWindow         *window);
@@ -300,6 +314,10 @@
 						       const gchar  *name);
 static void     gtk_window_realize_icon               (GtkWindow    *window);
 static void     gtk_window_unrealize_icon             (GtkWindow    *window);
+static void     resize_grip_create_window             (GtkWindow    *window);
+static void     resize_grip_destroy_window            (GtkWindow    *window);
+static void     update_grip_visibility                (GtkWindow    *window);
+
 
 static void        gtk_window_notify_keys_changed (GtkWindow   *window);
 static GtkKeyHash *gtk_window_get_key_hash        (GtkWindow   *window);
@@ -462,10 +480,14 @@
   widget_class->enter_notify_event = gtk_window_enter_notify_event;
   widget_class->leave_notify_event = gtk_window_leave_notify_event;
   widget_class->focus_in_event = gtk_window_focus_in_event;
+  widget_class->button_press_event = gtk_window_button_press_event;
   widget_class->focus_out_event = gtk_window_focus_out_event;
   widget_class->client_event = gtk_window_client_event;
   widget_class->focus = gtk_window_focus;
   widget_class->expose_event = gtk_window_expose;
+  widget_class->window_state_event = gtk_window_state_event;
+  widget_class->direction_changed = gtk_window_direction_changed;
+  widget_class->state_changed = gtk_window_state_changed;
 
   container_class->check_resize = gtk_window_check_resize;
 
@@ -514,6 +536,42 @@
                                                          GTK_PARAM_READWRITE));
 
   /**
+   * GtkWindow:has-resize-grip
+   *
+   * Whether the window has a corner resize grip.
+   *
+   * Note that the resize grip is only shown if the window is
+   * actually resizable and not maximized. Use
+   * #GtkWindow:resize-grip-visible to find out if the resize
+   * grip is currently shown.
+   *
+   * Since: 3.0
+   */
+  g_object_class_install_property (gobject_class,
+                                   PROP_HAS_RESIZE_GRIP,
+                                   g_param_spec_boolean ("has-resize-grip",
+                                                         P_("Resize grip"),
+                                                         P_("Specifies whether the window should have a resize grip"),
+                                                         TRUE,
+                                                         GTK_PARAM_READWRITE));
+
+  /**
+   * GtkWindow: resize-grip-visible:
+   *
+   * Whether a corner resize grip is currently shown.
+   *
+   * Since: 3.0
+   */
+  g_object_class_install_property (gobject_class,
+                                   PROP_RESIZE_GRIP_VISIBLE,
+                                   g_param_spec_boolean ("resize-grip-visible",
+                                                         P_("Resize grip is visible"),
+                                                         P_("Specifies whether the window's resize grip is visible."),
+                                                         FALSE,
+                                                         GTK_PARAM_READABLE));
+
+
+  /**
    * GtkWindow:startup-id:
    *
    * The :startup-id is a write-only property for setting window's
@@ -816,6 +874,21 @@
 							1.0,
 							GTK_PARAM_READWRITE));
 
+  /* Style properties.
+   */
+    gtk_widget_class_install_style_property (widget_class,
+                                             g_param_spec_int ("resize-grip-width",
+                                                               P_("Width of resize grip"),
+                                                               P_("Width of resize grip"),
+                                                               0, G_MAXINT, 16, GTK_PARAM_READWRITE));
+
+    gtk_widget_class_install_style_property (widget_class,
+                                             g_param_spec_int ("resize-grip-height",
+                                                               P_("Height of resize grip"),
+                                                               P_("Height of resize grip"),
+                                                               0, G_MAXINT, 16, GTK_PARAM_READWRITE));
+
+
   window_signals[SET_FOCUS] =
     g_signal_new (I_("set-focus"),
                   G_TYPE_FROM_CLASS (gobject_class),
@@ -967,6 +1040,7 @@
   priv->type_hint = GDK_WINDOW_TYPE_HINT_NORMAL;
   priv->opacity = 1.0;
   priv->startup_id = NULL;
+  priv->has_resize_grip = TRUE;
   priv->mnemonics_visible = TRUE;
 
   colormap = _gtk_widget_peek_colormap ();
@@ -1020,9 +1094,7 @@
       g_object_notify (G_OBJECT (window), "resizable");
       break;
     case PROP_RESIZABLE:
-      window->allow_grow = g_value_get_boolean (value);
-      gtk_widget_queue_resize (GTK_WIDGET (window));
-      g_object_notify (G_OBJECT (window), "allow-grow");
+      gtk_window_set_resizable (window, g_value_get_boolean (value));
       break;
     case PROP_MODAL:
       gtk_window_set_modal (window, g_value_get_boolean (value));
@@ -1092,6 +1164,9 @@
     case PROP_OPACITY:
       gtk_window_set_opacity (window, g_value_get_double (value));
       break;
+    case PROP_HAS_RESIZE_GRIP:
+      gtk_window_set_has_resize_grip (window, g_value_get_boolean (value));
+      break;
     case PROP_MNEMONICS_VISIBLE:
       gtk_window_set_mnemonics_visible (window, g_value_get_boolean (value));
       break;
@@ -1213,6 +1288,12 @@
     case PROP_OPACITY:
       g_value_set_double (value, gtk_window_get_opacity (window));
       break;
+    case PROP_HAS_RESIZE_GRIP:
+      g_value_set_boolean (value, priv->has_resize_grip);
+      break;
+    case PROP_RESIZE_GRIP_VISIBLE:
+      g_value_set_boolean (value, gtk_window_resize_grip_is_visible (window));
+      break;
     case PROP_MNEMONICS_VISIBLE:
       g_value_set_boolean (value, priv->mnemonics_visible);
       break;
@@ -4656,6 +4737,9 @@
   if (window->frame)
     gdk_window_show (window->frame);
 
+  if (priv->grip_window)
+    gdk_window_show (priv->grip_window);
+
   if (!disable_startup_notification)
     {
       /* Do we have a custom startup-notification id? */
@@ -4871,6 +4955,9 @@
   if (window->frame)
     gtk_style_set_background (widget->style, window->frame, GTK_STATE_NORMAL);
 
+  if (priv->grip_window)
+    gtk_style_set_background (widget->style, priv->grip_window, GTK_STATE_NORMAL);
+
   /* This is a bad hack to set the window background. */
   gtk_window_paint (widget, NULL);
   
@@ -4922,15 +5009,20 @@
 
   /* Icons */
   gtk_window_realize_icon (window);
+
+  if (priv->has_resize_grip)
+    resize_grip_create_window (window);
 }
 
 static void
 gtk_window_unrealize (GtkWidget *widget)
 {
   GtkWindow *window;
+  GtkWindowPrivate *priv;
   GtkWindowGeometryInfo *info;
 
   window = GTK_WINDOW (widget);
+  priv = GTK_WINDOW_GET_PRIVATE (widget);
 
   /* On unrealize, we reset the size of the window such
    * that we will re-apply the default sizing stuff
@@ -4962,9 +5054,146 @@
   /* Icons */
   gtk_window_unrealize_icon (window);
 
+  if (priv->grip_window != NULL)
+    resize_grip_destroy_window (window);
+
   GTK_WIDGET_CLASS (gtk_window_parent_class)->unrealize (widget);
 }
 
+static GdkWindowEdge
+get_grip_edge (GtkWidget *widget)
+{
+  return gtk_widget_get_direction (widget) == GTK_TEXT_DIR_LTR ? GDK_WINDOW_EDGE_SOUTH_EAST : GDK_WINDOW_EDGE_SOUTH_WEST;
+}
+
+static gboolean
+get_drag_edge (GtkWidget     *widget,
+               GdkWindowEdge *edge)
+{
+  GtkTextDirection dir;
+
+  dir = gtk_widget_get_direction (widget);
+
+  if (!GTK_WINDOW (widget)->allow_grow)
+    return FALSE;
+
+  *edge = dir == GTK_TEXT_DIR_LTR ? GDK_WINDOW_EDGE_SOUTH_EAST : GDK_WINDOW_EDGE_SOUTH_WEST;
+
+  return TRUE;
+}
+
+static void
+set_grip_cursor (GtkWindow *window)
+{
+  GtkWidget *widget = GTK_WIDGET (window);
+  GtkWindowPrivate *priv = GTK_WINDOW_GET_PRIVATE(window);
+
+  if (priv->grip_window == NULL)
+    return;
+
+  if (gtk_widget_is_sensitive (widget))
+    {
+      GdkWindowEdge edge;
+      GdkDisplay *display;
+      GdkCursorType cursor_type;
+      GdkCursor *cursor;
+
+      cursor_type = GDK_LEFT_PTR;
+
+      if (get_drag_edge (widget, &edge))
+        {
+          switch (edge)
+            {
+            case GDK_WINDOW_EDGE_EAST:
+              cursor_type = GDK_RIGHT_SIDE;
+              break;
+            case GDK_WINDOW_EDGE_SOUTH_EAST:
+              cursor_type = GDK_BOTTOM_RIGHT_CORNER;
+              break;
+            case GDK_WINDOW_EDGE_SOUTH:
+              cursor_type = GDK_BOTTOM_SIDE;
+              break;
+            case GDK_WINDOW_EDGE_SOUTH_WEST:
+              cursor_type = GDK_BOTTOM_LEFT_CORNER;
+              break;
+            case GDK_WINDOW_EDGE_WEST:
+              cursor_type = GDK_LEFT_SIDE;
+              break;
+            default: ;
+            }
+        }
+
+      display = gtk_widget_get_display (widget);
+      cursor = gdk_cursor_new_for_display (display, cursor_type);
+      gdk_window_set_cursor (priv->grip_window, cursor);
+      gdk_cursor_unref (cursor);
+    }
+  else
+    gdk_window_set_cursor (priv->grip_window, NULL);
+}
+
+static void
+set_grip_shape (GtkWindow *window)
+{
+  GtkWindowPrivate *priv = GTK_WINDOW_GET_PRIVATE (window);
+  GdkDrawable *mask;
+  cairo_t *cr;
+  gint width, height;
+
+  if (priv->grip_window == NULL)
+    return;
+
+  gdk_window_get_geometry (priv->grip_window,
+                           NULL, NULL,
+                           &width, &height,
+                           NULL);
+
+  mask = (GdkDrawable *) gdk_pixmap_new (NULL, width, height, 1);
+
+  cr = gdk_cairo_create (mask);
+
+  cairo_set_operator (cr, CAIRO_OPERATOR_SOURCE);
+  cairo_set_source_rgba (cr, 0.0, 0.0, 0.0, 0.0);
+  cairo_paint (cr);
+  cairo_set_source_rgba (cr, 0.0, 0.0, 0.0, 1.0);
+
+  if (get_grip_edge (GTK_WIDGET (window)) == GDK_WINDOW_EDGE_SOUTH_EAST)
+    {
+      cairo_move_to (cr, width, 0.0);
+      cairo_line_to (cr, width, height);
+      cairo_line_to (cr, 0.0, height);
+    }
+  else
+    {
+      cairo_move_to (cr, 0.0, 0.0);
+      cairo_line_to (cr, width, height);
+      cairo_line_to (cr, 0.0, height);
+    }
+
+  cairo_close_path (cr);
+  cairo_fill (cr);
+  cairo_destroy (cr);
+
+  gdk_window_shape_combine_mask (priv->grip_window, NULL, 0, 0);
+  gdk_window_shape_combine_mask (priv->grip_window, mask, 0, 0);
+}
+
+static void
+set_grip_position (GtkWindow *window)
+{
+  GtkWindowPrivate *priv = GTK_WINDOW_GET_PRIVATE(window);
+  GdkRectangle rect;
+
+  if (priv->grip_window == NULL)
+    return;
+
+  gtk_window_get_resize_grip_area (window, &rect);
+  gdk_window_raise (priv->grip_window);
+  gdk_window_move_resize (priv->grip_window,
+                          rect.x, rect.y,
+                          rect.width, rect.height);
+}
+
 static void
 gtk_window_size_request (GtkWidget      *widget,
 			 GtkRequisition *requisition)
@@ -5011,14 +5240,293 @@
       gtk_widget_size_allocate (window->bin.child, &child_allocation);
     }
 
-  if (gtk_widget_get_realized (widget) && window->frame)
+  if (gtk_widget_get_realized (widget))
     {
-      gdk_window_resize (window->frame,
-			 allocation->width + window->frame_left + window->frame_right,
-			 allocation->height + window->frame_top + window->frame_bottom);
+      if (window->frame)
+        {
+          gdk_window_resize (window->frame,
+                             allocation->width + window->frame_left + window->frame_right,
+                             allocation->height + window->frame_top + window->frame_bottom);
+        }
+
+      update_grip_visibility (window);
+      set_grip_position (window);
     }
 }
 
+static gboolean
+gtk_window_state_event (GtkWidget           *widget,
+                        GdkEventWindowState *event)
+{
+  update_grip_visibility (GTK_WINDOW (widget));
+
+  return FALSE;
+}
+
+static void
+gtk_window_direction_changed (GtkWidget        *widget,
+                              GtkTextDirection  prev_dir)
+{
+  GtkWindow *window = GTK_WINDOW (widget);
+
+  set_grip_cursor (window);
+  set_grip_position (window);
+  set_grip_shape (window);
+}
+
+static void
+gtk_window_state_changed (GtkWidget    *widget,
+                          GtkStateType  previous_state)
+{
+  GtkWindow *window = GTK_WINDOW (widget);
+
+  set_grip_cursor (window);
+  update_grip_visibility (window);
+}
+
+static void
+resize_grip_create_window (GtkWindow *window)
+{
+  GtkWidget *widget;
+  GtkWindowPrivate *priv;
+  GdkWindowAttr attributes;
+  gint attributes_mask;
+  GdkRectangle rect;
+
+  priv = GTK_WINDOW_GET_PRIVATE(window);
+  widget = GTK_WIDGET (window);
+
+  g_return_if_fail (gtk_widget_get_realized (widget));
+  g_return_if_fail (priv->grip_window == NULL);
+
+  gtk_window_get_resize_grip_area (window, &rect);
+
+  attributes.x = rect.x;
+  attributes.y = rect.y;
+  attributes.width = rect.width;
+  attributes.height = rect.height;
+  attributes.window_type = GDK_WINDOW_CHILD;
+  attributes.wclass = GDK_INPUT_OUTPUT;
+  attributes.visual = gtk_widget_get_visual (widget);
+  attributes.event_mask = gtk_widget_get_events (widget) |
+    GDK_EXPOSURE_MASK |
+    GDK_BUTTON_PRESS_MASK;
+
+  attributes_mask = GDK_WA_X | GDK_WA_Y | GDK_WA_VISUAL;
+
+  priv->grip_window = gdk_window_new (gtk_widget_get_window (widget),
+                                      &attributes,
+                                      attributes_mask);
+
+  gdk_window_set_user_data (priv->grip_window, widget);
+
+  gdk_window_raise (priv->grip_window);
+
+  set_grip_cursor (window);
+  set_grip_shape (window);
+  update_grip_visibility (window);
+}
+
+static void
+resize_grip_destroy_window (GtkWindow *window)
+{
+  GtkWindowPrivate *priv = GTK_WINDOW_GET_PRIVATE(window);
+
+  gdk_window_set_user_data (priv->grip_window, NULL);
+  gdk_window_destroy (priv->grip_window);
+  priv->grip_window = NULL;
+  update_grip_visibility (window);
+}
+
+/**
+ * gtk_window_set_has_resize_grip:
+ * @window: a #GtkWindow
+ * @value: %TRUE to allow a resize grip
+ *
+ * Sets whether @window has a corner resize grip.
+ *
+ * Note that the resize grip is only shown if the window
+ * is actually resizable and not maximized. Use
+ * gtk_window_resize_grip_is_visible() to find out if the
+ * resize grip is currently shown.
+ *
+ * Since: 3.0
+ */
+void
+gtk_window_set_has_resize_grip (GtkWindow *window,
+                                gboolean   value)
+{
+  GtkWidget *widget = GTK_WIDGET (window);
+  GtkWindowPrivate *priv = GTK_WINDOW_GET_PRIVATE(window);
+
+  value = value != FALSE;
+
+  if (value != priv->has_resize_grip)
+    {
+      priv->has_resize_grip = value;
+      gtk_widget_queue_draw (widget);
+
+      if (gtk_widget_get_realized (widget))
+        {
+          if (priv->has_resize_grip && priv->grip_window == NULL)
+            resize_grip_create_window (window);
+          else if (!priv->has_resize_grip && priv->grip_window != NULL)
+            resize_grip_destroy_window (window);
+        }
+
+      g_object_notify (G_OBJECT (window), "has-resize-grip");
+    }
+}
+
+static void
+update_grip_visibility (GtkWindow *window)
+{
+  GtkWindowPrivate *priv = GTK_WINDOW_GET_PRIVATE(window);
+  gboolean val;
+
+  val = gtk_window_resize_grip_is_visible (window);
+
+  if (priv->grip_window != NULL)
+    {
+      if (val)
+        {
+          gdk_window_show (priv->grip_window);
+          set_grip_cursor (window);
+        }
+      else
+        {
+          gdk_window_hide (priv->grip_window);
+        }
+    }
+
+  if (priv->resize_grip_visible != val)
+    {
+      priv->resize_grip_visible = val;
+
+      g_object_notify (G_OBJECT (window), "resize-grip-visible");
+    }
+}
+
+/**
+ * gtk_window_resize_grip_is_visible:
+ * @window: a #GtkWindow
+ *
+ * Determines whether a resize grip is visible for the specified window.
+ *
+ * Returns %TRUE if a resize grip exists and is visible.
+ *
+ * Since: 3.0
+ */
+gboolean
+gtk_window_resize_grip_is_visible (GtkWindow *window)
+{
+  GtkWindowPrivate *priv;
+  GdkWindowEdge edge;
+
+  g_return_val_if_fail (GTK_IS_WINDOW (window), FALSE);
+
+  priv = GTK_WINDOW_GET_PRIVATE(window);
+
+  if (window->type == GTK_WINDOW_POPUP || !window->allow_grow)
+    return FALSE;
+
+  if (gtk_widget_get_realized (GTK_WIDGET (window)))
+    {
+      GdkWindowState state;
+
+      state = gdk_window_get_state (gtk_widget_get_window (GTK_WIDGET (window)));
+
+      if (state & GDK_WINDOW_STATE_MAXIMIZED || state & GDK_WINDOW_STATE_FULLSCREEN)
+        return FALSE;
+    }
+
+  if (!get_drag_edge (GTK_WIDGET (window), &edge))
+    return FALSE;
+
+  return priv->has_resize_grip;
+}
+
+/**
+ * gtk_window_get_has_resize_grip:
+ * @window: a #GtkWindow
+ *
+ * Determines whether the window may has a resize grip.
+ *
+ * Returns: %TRUE if the window has a resize grip.
+ *
+ * Since: 3.0
+ */
+gboolean
+gtk_window_get_has_resize_grip (GtkWindow *window)
+{
+  GtkWindowPrivate *priv;
+
+  g_return_val_if_fail (GTK_IS_WINDOW (window), FALSE);
+
+  priv = GTK_WINDOW_GET_PRIVATE(window);
+
+  return priv->has_resize_grip;
+}
+
+/**
+ * gtk_window_get_resize_grip_area:
+ * @window: a #GtkWindow
+ * @rect: a pointer to a #GdkRectangle which we should store the
+ *     resize grip area.
+ *
+ * If a window has a resize grip, this will retrieve the grip
+ * position, width and height into the specified #GdkRectangle.
+ *
+ * Returns: %TRUE if the resize grip's area was retrieved.
+ *
+ * Since: 3.0
+ */
+gboolean
+gtk_window_get_resize_grip_area (GtkWindow *window,
+                                 GdkRectangle *rect)
+{
+  GtkWidget *widget;
+  GtkWindowPrivate *priv;
+  GtkAllocation allocation;
+  GtkStyle *style;
+  gint grip_width;
+  gint grip_height;
+
+  g_return_val_if_fail (GTK_IS_WINDOW (window), FALSE);
+
+  widget = GTK_WIDGET (window);
+  priv = GTK_WINDOW_GET_PRIVATE (window);
+
+  if (!priv->has_resize_grip)
+    return FALSE;
+
+  gtk_widget_get_allocation (widget, &allocation);
+  style = gtk_widget_get_style (widget);
+
+  gtk_widget_style_get (widget,
+                        "resize-grip-width", &grip_width,
+                        "resize-grip-height", &grip_height,
+                        NULL);
+
+  if (grip_width > allocation.width)
+    grip_width = allocation.width;
+
+  if (grip_height > allocation.height)
+    grip_height = allocation.height;
+
+  rect->width = grip_width;
+  rect->height = grip_height;
+  rect->y = allocation.y + allocation.height - grip_height;
+
+  if (gtk_widget_get_direction (widget) == GTK_TEXT_DIR_LTR)
+    rect->x = allocation.x + allocation.width - grip_width;
+  else
+    rect->x = allocation.x;
+
+  return TRUE;
+}
+
+
 static gint
 gtk_window_event (GtkWidget *widget, GdkEvent *event)
 {
@@ -5270,6 +5778,29 @@
   return handled;
 }
 
+static gint
+gtk_window_button_press_event (GtkWidget *widget,
+                               GdkEventButton *event)
+{
+  GtkWindowPrivate *priv = GTK_WINDOW_GET_PRIVATE (widget);
+  GdkWindowEdge edge;
+
+  if (event->window == priv->grip_window)
+    {
+      if (get_drag_edge (widget, &edge))
+        gtk_window_begin_resize_drag (GTK_WINDOW (widget),
+                                      get_grip_edge (widget),
+                                      event->button,
+                                      event->x_root,
+                                      event->y_root,
+                                      event->time);
+
+      return TRUE;
+    }
+
+  return FALSE;
+}
+
 static void
 gtk_window_real_activate_default (GtkWindow *window)
 {
@@ -6051,6 +6582,7 @@
    *   the position request to be centered.
    */
   GtkWidget *widget;
+  GtkWindowPrivate *priv;
   GtkContainer *container;
   GtkWindowGeometryInfo *info;
   GdkGeometry new_geometry;
@@ -6064,7 +6596,8 @@
   widget = GTK_WIDGET (window);
   container = GTK_CONTAINER (widget);
   info = gtk_window_get_geometry_info (window, TRUE);
-  
+  priv = GTK_WINDOW_GET_PRIVATE (window);
+
   configure_request_size_changed = FALSE;
   configure_request_pos_changed = FALSE;
   
@@ -6260,6 +6793,9 @@
       allocation = widget->allocation;
       gtk_widget_size_allocate (widget, &allocation);
 
+      set_grip_position (window);
+      update_grip_visibility (window);
+
       gdk_window_process_updates (widget->window, TRUE);
       
       gdk_window_configure_finished (widget->window);
@@ -6636,24 +7172,75 @@
  ***********************/
 
 static void
-gtk_window_paint (GtkWidget     *widget,
-		  GdkRectangle *area)
+paint_window_grip (GtkWidget *widget, GdkRectangle *area)
 {
-  gtk_paint_flat_box (widget->style, widget->window, GTK_STATE_NORMAL, 
-		      GTK_SHADOW_NONE, area, widget, "base", 0, 0, -1, -1);
+  GtkWindow *window = GTK_WINDOW (widget);
+  GtkWindowPrivate *priv = GTK_WINDOW_GET_PRIVATE (window);
+
+  if (gtk_window_resize_grip_is_visible (window) && priv->grip_window != NULL)
+    {
+      GdkWindowEdge edge;
+      GdkRectangle rect;
+
+      gtk_window_get_resize_grip_area (window, &rect);
+
+      edge = get_grip_edge (widget);
+
+      gtk_window_get_resize_grip_area (window, &rect);
+
+      gtk_paint_flat_box (widget->style,
+                          priv->grip_window,
+                          GTK_STATE_NORMAL,
+                          GTK_SHADOW_NONE,
+                          area,
+                          widget,
+                          "base",
+                          0, 0,
+                          -1, -1);
+
+      gtk_paint_resize_grip (gtk_widget_get_style (widget),
+                             priv->grip_window,
+                             gtk_widget_get_state (widget),
+                             area,
+                             widget,
+                             "statusbar",
+                             edge,
+                             0, 0,
+                             rect.width,
+                             rect.height);
+    }
+}
+
+static void
+gtk_window_paint (GtkWidget    *widget,
+                  GdkRectangle *area)
+{
+  gtk_paint_flat_box (widget->style, widget->window, GTK_STATE_NORMAL,
+                      GTK_SHADOW_NONE, area, widget, "base", 0, 0, -1, -1);
 }
 
 static gint
 gtk_window_expose (GtkWidget      *widget,
 		   GdkEventExpose *event)
 {
-  if (!gtk_widget_get_app_paintable (widget))
-    gtk_window_paint (widget, &event->area);
-  
-  if (GTK_WIDGET_CLASS (gtk_window_parent_class)->expose_event)
-    return GTK_WIDGET_CLASS (gtk_window_parent_class)->expose_event (widget, event);
+  GtkWindowPrivate *priv = GTK_WINDOW_GET_PRIVATE (widget);
+  gboolean ret = FALSE;
 
-  return FALSE;
+  if (event->window == widget->window)
+    {
+      if (!gtk_widget_get_app_paintable (widget))
+        gtk_window_paint (widget, &event->area);
+
+      if (GTK_WIDGET_CLASS (gtk_window_parent_class)->expose_event)
+        ret = GTK_WIDGET_CLASS (gtk_window_parent_class)->expose_event (widget, event);
+    }
+  else if (event->window == priv->grip_window)
+    {
+      paint_window_grip (widget, &event->area);
+      ret = TRUE;
+    }
+
+  return ret;
 }
 
 /**
@@ -7265,8 +7852,16 @@
 gtk_window_set_resizable (GtkWindow *window,
                           gboolean   resizable)
 {
+  GtkWindowPrivate *priv;
+
   g_return_if_fail (GTK_IS_WINDOW (window));
 
+  priv = GTK_WINDOW_GET_PRIVATE (window);
+
+  // XXX - need to do this after setting policy?
+  if (priv->grip_window != NULL)
+    update_grip_visibility (window);
+
   gtk_window_set_policy_internal (window, FALSE, resizable, FALSE);
 }
 
Index: gtk+-2.24.4/gtk/gtkwindow.h
===================================================================
--- gtk+-2.24.4.orig/gtk/gtkwindow.h	2011-02-20 01:31:37.000000000 +1100
+++ gtk+-2.24.4/gtk/gtkwindow.h	2011-04-04 10:58:00.246596968 +1000
@@ -404,6 +404,17 @@
 GList *          gtk_window_group_list_windows  (GtkWindowGroup     *window_group);
 
 
+
+/* Window grips
+ */
+void     gtk_window_set_has_resize_grip    (GtkWindow    *window,
+                                            gboolean      value);
+gboolean gtk_window_get_has_resize_grip    (GtkWindow    *window);
+gboolean gtk_window_resize_grip_is_visible (GtkWindow    *window);
+gboolean gtk_window_get_resize_grip_area   (GtkWindow    *window,
+                                            GdkRectangle *rect);
+
+
 /* --- internal functions --- */
 void            _gtk_window_internal_set_focus (GtkWindow *window,
 						GtkWidget *focus);
