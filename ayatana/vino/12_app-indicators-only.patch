=== modified file 'configure.in'
--- old/configure.in	2010-09-09 21:16:40 +0000
+++ new/configure.in	2010-09-09 21:17:56 +0000
@@ -107,6 +107,23 @@
     AC_DEFINE(VINO_ENABLE_LIBNOTIFY, [], [Set if we should use libnotify])
 fi
 
+dnl -- check for application indicators ---------------------------------------
+APPINDICATOR_VERSION=0.0.7
+
+AC_ARG_ENABLE(appindicator,
+			AS_HELP_STRING([--enable-appindicator],[Build support for application indicators [[default=yes]]]),
+			[enable_appindicator=$enableval],
+			[enable_appindicator="yes"])
+
+if test x$enable_appindicator = xyes ; then
+	PKG_CHECK_MODULES(APP_INDICATOR,
+			appindicator-0.1 >= $APPINDICATOR_VERSION)
+	AC_SUBST(APP_INDICATOR_CFLAGS)
+	AC_SUBST(APP_INDICATOR_LIBS)
+	AC_DEFINE(VINO_ENABLE_APP_INDICATOR, 1, [Have AppIndicator])
+fi
+AM_CONDITIONAL(VINO_ENABLE_APP_INDICATOR, test x"$enable_appindicator" = xyes)
+
 dnl -- check for NetworkManager -----------------------------------------------
 AC_ARG_ENABLE(network-manager,
               AS_HELP_STRING([--enable-network-manager],[use NetworkManager to be notified when network status changes [default=auto]]),
@@ -437,4 +454,5 @@
 	Libunique support...........:  ${have_libunique}
 	DEBUG messages..............:  ${enable_debug}
 	Telepathy support...........:  ${have_telepathy}
+	Application indicator support: ${enable_appindicator}
 "

=== modified file 'server/Makefile.am'
--- old/server/Makefile.am	2010-09-09 21:16:40 +0000
+++ new/server/Makefile.am	2010-09-09 21:17:56 +0000
@@ -67,6 +67,7 @@
 	vino-server.h \
 	vino-util.c \
 	vino-util.h \
+	vino-icon-visibility.h \
 	vino-status-icon.c \
 	vino-status-icon.h \
 	vino-dbus-listener.c \
@@ -97,6 +98,12 @@
 
 endif
 
+if VINO_ENABLE_APP_INDICATOR
+INCLUDES += $(APP_INDICATOR_CFLAGS) -DVINO_ENABLE_APP_INDICATOR
+vino_server_LDADD += $(APP_INDICATOR_LIBS)
+vino_server_SOURCES += vino-tube-app-indicator.c vino-tube-app-indicator.h vino-app-indicator.c vino-app-indicator.h
+endif
+
 dbus-interface-glue.h: dbus-interface.xml
 	dbus-binding-tool --prefix=vino_dbus_listener --mode=glib-server $< > dbus-interface-glue.h
 
@@ -110,8 +117,8 @@
 vino_enum_headers = \
 	$(top_srcdir)/server/vino-server.h \
 	$(top_srcdir)/server/vino-prompt.h \
-	$(top_srcdir)/server/vino-status-icon.h \
-	$(top_srcdir)/server/vino-status-tube-icon.h \
+	$(top_srcdir)/server/vino-icon-visibility.h \
+	$(top_srcdir)/server/vino-tube-icon-visibility.h \
 	$(NULL)
 
 vino-enums.c: @REBUILD@ $(vino_enum_headers)

=== added file 'server/vino-app-indicator.c'
--- old/server/vino-app-indicator.c	1970-01-01 00:00:00 +0000
+++ new/server/vino-app-indicator.c	2010-09-13 14:37:43 +0000
@@ -0,0 +1,700 @@
+/*
+ * Copyright (C) 2010 Canonical Ltd
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ * Authors:
+ *      Travis B. Hartwell <nafai@travishartwell.net>
+ */
+
+#include <config.h>
+#include <gtk/gtk.h>
+#include <string.h>
+#ifdef VINO_ENABLE_LIBNOTIFY
+#include <libnotify/notify.h>
+#endif
+#include <libappindicator/app-indicator.h>
+
+#include "vino-app-indicator.h"
+#include "vino-enums.h"
+#include "vino-util.h"
+
+struct _VinoAppIndicatorPrivate
+{
+  AppIndicator *indicator;
+  GtkMenu    *menu;
+  GtkMenuItem *status_menu_item;
+  VinoServer *server;
+  GSList     *clients;
+  GtkWidget  *disconnect_dialog;
+  VinoIconVisibility visibility;
+
+#ifdef VINO_ENABLE_LIBNOTIFY
+  NotifyNotification *new_client_notification;
+#endif
+};
+
+G_DEFINE_TYPE (VinoAppIndicator, vino_app_indicator, G_TYPE_OBJECT);
+
+enum
+{
+  PROP_0,
+  PROP_SERVER,
+  PROP_VISIBILITY
+};
+
+typedef struct
+{
+  VinoAppIndicator *indicator;
+  VinoClient     *client;
+} VinoAppIndicatorNotify;
+
+static gboolean vino_app_indicator_show_new_client_notification (gpointer user_data);
+static void vino_app_indicator_build_menu (VinoAppIndicator *indicator);
+static void vino_app_indicator_setup_menu (VinoAppIndicator *indicator);
+
+static void
+vino_app_indicator_finalize (GObject *object)
+{
+  VinoAppIndicator *indicator = VINO_APP_INDICATOR (object);
+
+#ifdef VINO_ENABLE_LIBNOTIFY
+  if (indicator->priv->new_client_notification)
+    g_object_unref (indicator->priv->new_client_notification);
+  indicator->priv->new_client_notification = NULL;
+#endif
+
+  if (indicator->priv->status_menu_item)
+    gtk_widget_destroy (GTK_WIDGET (indicator->priv->status_menu_item));
+  indicator->priv->status_menu_item = NULL;
+
+  if (indicator->priv->menu)
+    gtk_widget_destroy (GTK_WIDGET (indicator->priv->menu));
+  indicator->priv->menu = NULL;
+
+  if (indicator->priv->clients)
+    g_slist_free (indicator->priv->clients);
+  indicator->priv->clients = NULL;
+
+  if (indicator->priv->disconnect_dialog)
+    gtk_widget_destroy (indicator->priv->disconnect_dialog);
+  indicator->priv->disconnect_dialog = NULL;
+
+  if (indicator->priv->indicator)
+    g_object_unref (indicator->priv->indicator);
+  indicator->priv->indicator = NULL;
+
+  G_OBJECT_CLASS (vino_app_indicator_parent_class)->finalize (object);
+}
+
+void
+vino_app_indicator_update_state (VinoAppIndicator *indicator)
+{
+  char     *tooltip;
+  gboolean visible;
+  AppIndicatorStatus status;
+
+  g_return_if_fail (VINO_IS_APP_INDICATOR (indicator));
+
+  vino_app_indicator_setup_menu (indicator);
+
+  visible = !vino_server_get_on_hold (indicator->priv->server);
+
+  tooltip = g_strdup (_("Desktop sharing is enabled"));
+
+  if (indicator->priv->clients != NULL)
+    {
+      int n_clients;
+
+      n_clients = g_slist_length (indicator->priv->clients);
+
+      tooltip = g_strdup_printf (ngettext ("One person is connected",
+                                           "%d people are connected",
+                                           n_clients),
+                                 n_clients);
+      visible = (visible) && ( (indicator->priv->visibility == VINO_ICON_VISIBILITY_CLIENT) ||
+			     (indicator->priv->visibility == VINO_ICON_VISIBILITY_ALWAYS) );
+    }
+  else
+    visible = visible && (indicator->priv->visibility == VINO_ICON_VISIBILITY_ALWAYS);
+
+  gtk_menu_item_set_label (GTK_MENU_ITEM (indicator->priv->status_menu_item), tooltip);
+
+  status = visible ? APP_INDICATOR_STATUS_ACTIVE : APP_INDICATOR_STATUS_PASSIVE;
+  if (indicator->priv->indicator != NULL)
+	  app_indicator_set_status (APP_INDICATOR (indicator->priv->indicator), status);
+
+  g_free (tooltip);
+}
+
+static void
+vino_app_indicator_init (VinoAppIndicator *indicator)
+{
+  indicator->priv = G_TYPE_INSTANCE_GET_PRIVATE (indicator, VINO_TYPE_APP_INDICATOR, VinoAppIndicatorPrivate);
+
+  indicator->priv->indicator = app_indicator_new ("vino-app-indicator",
+						  "preferences-desktop-remote-desktop",
+						  APP_INDICATOR_CATEGORY_APPLICATION_STATUS);
+
+  vino_app_indicator_setup_menu (indicator);
+}
+
+static void
+vino_app_indicator_set_property (GObject      *object,
+			       guint         prop_id,
+			       const GValue *value,
+			       GParamSpec   *pspec)
+{
+  VinoAppIndicator *indicator = VINO_APP_INDICATOR (object);
+
+  switch (prop_id)
+    {
+    case PROP_SERVER:
+      indicator->priv->server = g_value_get_object (value);
+      break;
+    case PROP_VISIBILITY:
+      vino_app_indicator_set_visibility (indicator, g_value_get_enum (value));
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+    }
+}
+
+static void
+vino_app_indicator_get_property (GObject    *object,
+			       guint       prop_id,
+			       GValue     *value,
+			       GParamSpec *pspec)
+{
+  VinoAppIndicator *indicator = VINO_APP_INDICATOR (object);
+
+  switch (prop_id)
+    {
+    case PROP_SERVER:
+      g_value_set_object (value, indicator->priv->server);
+      break;
+    case PROP_VISIBILITY:
+      g_value_set_enum (value, indicator->priv->visibility);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+    }
+}
+
+VinoAppIndicator *
+vino_app_indicator_new (VinoServer *server)
+{
+  g_return_val_if_fail (VINO_IS_SERVER (server), NULL);
+
+  return g_object_new (VINO_TYPE_APP_INDICATOR,
+                       "server",    server,
+                       NULL);
+}
+
+VinoServer *
+vino_app_indicator_get_server (VinoAppIndicator *indicator)
+{
+  g_return_val_if_fail (VINO_IS_APP_INDICATOR (indicator), NULL);
+
+  return indicator->priv->server;
+}
+
+static void
+vino_app_indicator_preferences (VinoAppIndicator *indicator)
+{
+  GdkScreen *screen;
+  GError *error = NULL;
+
+  screen = gdk_screen_get_default ();
+  if (!gdk_spawn_command_line_on_screen (screen, "vino-preferences", &error))
+    {
+      vino_util_show_error (_("Error displaying preferences"),
+			    error->message,
+			    NULL);
+      g_error_free (error);
+    }
+}
+
+static void
+vino_app_indicator_help (VinoAppIndicator *indicator)
+{
+  GdkScreen *screen;
+  GError    *error = NULL;
+
+  screen = gdk_screen_get_default ();
+  if (!gtk_show_uri (screen,
+		     "ghelp:user-guide?goscustdesk-90",
+		     GDK_CURRENT_TIME,
+		     &error))
+    {
+      vino_util_show_error (_("Error displaying help"),
+			    error->message,
+			    NULL);
+      g_error_free (error);
+    }
+}
+
+static void
+vino_app_indicator_about (VinoAppIndicator *indicator)
+{
+
+  g_return_if_fail (VINO_IS_APP_INDICATOR (indicator));
+
+  const char *authors[] = {
+    "Mark McLoughlin <mark@skynet.ie>",
+    "Calum Benson <calum.benson@sun.com>",
+    "Federico Mena Quintero <federico@ximian.com>",
+    "Sebastien Estienne <sebastien.estienne@gmail.com>",
+    "Shaya Potter <spotter@cs.columbia.edu>",
+    "Steven Zhang <steven.zhang@sun.com>",
+    "Srirama Sharma <srirama.sharma@wipro.com>",
+    "Jonh Wendell <wendell@bani.com.br>",
+    NULL
+  };
+  char *license;
+  char *translators;
+
+  license = _("Licensed under the GNU General Public License Version 2\n\n"
+              "Vino is free software; you can redistribute it and/or\n"
+              "modify it under the terms of the GNU General Public License\n"
+              "as published by the Free Software Foundation; either version 2\n"
+              "of the License, or (at your option) any later version.\n\n"
+              "Vino is distributed in the hope that it will be useful,\n"
+              "but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
+              "MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n"
+              "GNU General Public License for more details.\n\n"
+              "You should have received a copy of the GNU General Public License\n"
+              "along with this program; if not, write to the Free Software\n"
+              "Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n"
+              "02110-1301, USA.\n");
+
+  /* Translators comment: put your own name here to appear in the about dialog. */
+  translators = _("translator-credits");
+
+  if (!strcmp (translators, "translator-credits"))
+    translators = NULL;
+
+  gtk_show_about_dialog (NULL,
+                         "comments",           _("Share your desktop with other users"),
+                         "version",            VERSION,
+                         "license",            license,
+                         "authors",            authors,
+                         "translator-credits", translators,
+                         "logo-icon-name",     "preferences-desktop-remote-desktop",
+                         NULL);
+}
+
+static void
+vino_app_indicator_disconnect_client (VinoAppIndicatorNotify *a, gint response)
+{
+
+  GSList *l;
+  GSList *next;
+
+  VinoAppIndicator *indicator    = a->indicator;
+  VinoClient     *client  = a->client;
+
+  gtk_widget_destroy (indicator->priv->disconnect_dialog);
+  indicator->priv->disconnect_dialog = NULL;
+
+  if (response != GTK_RESPONSE_OK)
+  {
+    g_free (a);
+    return;
+  }
+
+  if (client)
+  {
+    if (g_slist_find (indicator->priv->clients, client))
+      vino_client_disconnect (client);
+  }
+  else
+    for (l = indicator->priv->clients; l; l = next)
+      {
+        VinoClient *client = l->data;
+
+        next = l->next;
+
+        vino_client_disconnect (client);
+      }
+
+  g_free (a);
+}
+
+static void
+vino_app_indicator_disconnect_confirm (VinoAppIndicatorNotify *a)
+{
+  char      *primary_msg;
+  char      *secondary_msg;
+
+  VinoAppIndicator *indicator    = a->indicator;
+  VinoClient     *client  = a->client;
+
+  if (indicator->priv->disconnect_dialog)
+  {
+    gtk_window_present (GTK_WINDOW (indicator->priv->disconnect_dialog));
+    return;
+  }
+
+  if (client != NULL)
+    {
+      /* Translators: %s is a hostname */
+      primary_msg   = g_strdup_printf
+          (_("Are you sure you want to disconnect '%s'?"),
+          vino_client_get_hostname (client));
+      secondary_msg = g_strdup_printf
+          (_("The remote user from '%s' will be disconnected. Are you sure?"),
+          vino_client_get_hostname (client));
+    }
+  else
+    {
+      primary_msg   = g_strdup
+          (_("Are you sure you want to disconnect all clients?"));
+      secondary_msg = g_strdup
+          (_("All remote users will be disconnected. Are you sure?"));
+    }
+
+  indicator->priv->disconnect_dialog = gtk_message_dialog_new (NULL,
+                                                          GTK_DIALOG_DESTROY_WITH_PARENT,
+                                                          GTK_MESSAGE_QUESTION,
+                                                          GTK_BUTTONS_CANCEL,
+                                                          "%s",
+                                                          primary_msg);
+
+  gtk_window_set_skip_taskbar_hint (GTK_WINDOW (indicator->priv->disconnect_dialog), FALSE);
+
+  gtk_dialog_add_button (GTK_DIALOG (indicator->priv->disconnect_dialog), _("Disconnect"), GTK_RESPONSE_OK);
+
+  gtk_message_dialog_format_secondary_text (GTK_MESSAGE_DIALOG (indicator->priv->disconnect_dialog),
+                                            "%s", secondary_msg);
+
+  g_signal_connect_swapped (indicator->priv->disconnect_dialog, "response",
+                            G_CALLBACK (vino_app_indicator_disconnect_client), (gpointer) a);  
+  gtk_widget_show_all (GTK_WIDGET (indicator->priv->disconnect_dialog));
+
+  g_free (primary_msg);
+  g_free (secondary_msg);
+}
+
+static void
+vino_app_indicator_setup_menu (VinoAppIndicator *indicator)
+{
+  if (indicator->priv->status_menu_item)
+    gtk_widget_destroy (GTK_WIDGET (indicator->priv->status_menu_item));
+  indicator->priv->status_menu_item = NULL;
+
+  if (indicator->priv->menu)
+    gtk_widget_destroy (GTK_WIDGET (indicator->priv->menu));
+  indicator->priv->menu = NULL;
+
+  vino_app_indicator_build_menu (indicator);
+
+  app_indicator_set_menu (indicator->priv->indicator, indicator->priv->menu);
+}
+
+static void
+vino_app_indicator_build_menu (VinoAppIndicator *indicator)
+{
+  GtkWidget      *item;
+  GSList         *l;
+  VinoAppIndicatorNotify *a;
+  guint          n_clients;
+
+  indicator->priv->menu = (GtkMenu*) gtk_menu_new ();
+
+  indicator->priv->status_menu_item = (GtkMenuItem*) gtk_menu_item_new ();
+  gtk_widget_set_sensitive (GTK_WIDGET (indicator->priv->status_menu_item), FALSE);
+  gtk_widget_show (GTK_WIDGET (indicator->priv->status_menu_item));
+  gtk_menu_shell_append (GTK_MENU_SHELL (indicator->priv->menu), GTK_WIDGET (indicator->priv->status_menu_item));
+
+  item = gtk_separator_menu_item_new ();
+  gtk_widget_show (item);
+  gtk_menu_shell_append (GTK_MENU_SHELL (indicator->priv->menu), item);
+
+  item = gtk_image_menu_item_new_with_mnemonic (_("_Preferences"));
+  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (item),
+                                 gtk_image_new_from_stock (GTK_STOCK_PREFERENCES, GTK_ICON_SIZE_MENU));
+  g_signal_connect_swapped (item, "activate",
+                            G_CALLBACK (vino_app_indicator_preferences), indicator);
+  gtk_widget_show (item);
+  gtk_menu_shell_append (GTK_MENU_SHELL (indicator->priv->menu), item);
+
+  item = gtk_separator_menu_item_new ();
+  gtk_widget_show (item);
+  gtk_menu_shell_append (GTK_MENU_SHELL (indicator->priv->menu), item);
+
+  n_clients = g_slist_length (indicator->priv->clients);
+  if (n_clients > 1)
+    {
+      item  = gtk_image_menu_item_new_with_label (_("Disconnect all"));
+      gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (item),
+                                     gtk_image_new_from_stock (GTK_STOCK_NETWORK, GTK_ICON_SIZE_MENU));
+
+      a = g_new (VinoAppIndicatorNotify, 1);
+      a->indicator = indicator;
+      a->client = NULL;
+
+      g_signal_connect_swapped (item, "activate",
+                                G_CALLBACK (vino_app_indicator_disconnect_confirm), (gpointer) a);
+      gtk_widget_show (item);
+      gtk_menu_shell_append (GTK_MENU_SHELL (indicator->priv->menu), item);
+    }
+
+  for (l = indicator->priv->clients; l; l = l->next)
+    {
+      VinoClient *client = l->data;
+      char       *str;
+
+      a = g_new (VinoAppIndicatorNotify, 1);
+      a->indicator   = indicator;
+      a->client = client;
+
+      /* Translators: %s is a hostname */
+      str = g_strdup_printf (_("Disconnect %s"),
+          vino_client_get_hostname (client));
+
+      item  = gtk_image_menu_item_new_with_label (str);
+      gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (item),
+                                     gtk_image_new_from_stock (GTK_STOCK_NETWORK, GTK_ICON_SIZE_MENU));
+      g_signal_connect_swapped (item, "activate",
+                                G_CALLBACK (vino_app_indicator_disconnect_confirm), (gpointer) a);
+      gtk_widget_show (item);
+      gtk_menu_shell_append (GTK_MENU_SHELL (indicator->priv->menu), item);
+
+      g_free (str);
+    }
+
+  if (n_clients)
+    {
+      item = gtk_separator_menu_item_new ();
+      gtk_widget_show (item);
+      gtk_menu_shell_append (GTK_MENU_SHELL (indicator->priv->menu), item);
+    }
+
+  item = gtk_image_menu_item_new_with_mnemonic (_("_Help"));
+  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (item),
+				 gtk_image_new_from_stock (GTK_STOCK_HELP, GTK_ICON_SIZE_MENU));
+  g_signal_connect_swapped (item, "activate",
+                            G_CALLBACK (vino_app_indicator_help), indicator);
+  gtk_widget_show (item);
+  gtk_menu_shell_append (GTK_MENU_SHELL (indicator->priv->menu), item);
+
+  item = gtk_image_menu_item_new_with_mnemonic (_("_About"));
+  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (item),
+                                 gtk_image_new_from_stock (GTK_STOCK_ABOUT, GTK_ICON_SIZE_MENU));
+  g_signal_connect_swapped (item, "activate",
+                            G_CALLBACK (vino_app_indicator_about), indicator);
+  gtk_widget_show (item);
+  gtk_menu_shell_append (GTK_MENU_SHELL (indicator->priv->menu), item);
+}
+
+void
+vino_app_indicator_add_client (VinoAppIndicator *indicator,
+			       VinoClient     *client)
+{
+  g_return_if_fail (VINO_IS_APP_INDICATOR (indicator));
+  g_return_if_fail (client != NULL);
+
+  indicator->priv->clients = g_slist_append (indicator->priv->clients, client);
+
+  vino_app_indicator_update_state (indicator);
+
+  /* Visible if not APP_INDICATOR_STATUS_PASSIVE */
+  if (app_indicator_get_status (indicator->priv->indicator) != APP_INDICATOR_STATUS_PASSIVE)
+    {
+      VinoAppIndicatorNotify *a;
+
+      a = g_new (VinoAppIndicatorNotify, 1);
+      a->indicator   = indicator;
+      a->client = client;
+      g_timeout_add_seconds (1,
+                             vino_app_indicator_show_new_client_notification,
+                             (gpointer) a);
+    }
+}
+
+gboolean
+vino_app_indicator_remove_client (VinoAppIndicator *indicator,
+				  VinoClient     *client)
+{
+  g_return_val_if_fail (VINO_IS_APP_INDICATOR (indicator), TRUE);
+  g_return_val_if_fail (client != NULL, TRUE);
+
+  if (!indicator->priv->clients)
+    return FALSE;
+
+  indicator->priv->clients = g_slist_remove (indicator->priv->clients, client);
+
+  vino_app_indicator_update_state (indicator);
+
+  return indicator->priv->clients == NULL;
+}
+
+static void
+vino_app_indicator_class_init (VinoAppIndicatorClass *klass)
+{
+  GObjectClass       *gobject_class     = G_OBJECT_CLASS (klass);
+
+  gobject_class->finalize     = vino_app_indicator_finalize;
+  gobject_class->set_property = vino_app_indicator_set_property;
+  gobject_class->get_property = vino_app_indicator_get_property;
+
+  g_object_class_install_property (gobject_class,
+				   PROP_SERVER,
+				   g_param_spec_object ("server",
+							"Server",
+							"The server",
+							VINO_TYPE_SERVER,
+							G_PARAM_READWRITE |
+							G_PARAM_CONSTRUCT_ONLY |
+							G_PARAM_STATIC_NAME |
+							G_PARAM_STATIC_NICK |
+							G_PARAM_STATIC_BLURB));
+  g_object_class_install_property (gobject_class,
+				   PROP_VISIBILITY,
+				   g_param_spec_enum ("visibility",
+						      "Indicator visibility",
+						      "When the indicator must be shown",
+						      VINO_TYPE_ICON_VISIBILITY,
+						      VINO_ICON_VISIBILITY_CLIENT,
+						      G_PARAM_READWRITE |
+						      G_PARAM_CONSTRUCT |
+						      G_PARAM_STATIC_NAME |
+						      G_PARAM_STATIC_NICK |
+						      G_PARAM_STATIC_BLURB));
+
+  g_type_class_add_private (gobject_class, sizeof (VinoAppIndicatorPrivate));
+}
+
+#ifdef VINO_ENABLE_LIBNOTIFY
+static void
+vino_status_handle_new_client_notification_closed (VinoAppIndicator *indicator)
+{
+  g_object_unref (indicator->priv->new_client_notification);
+  indicator->priv->new_client_notification = NULL;
+}
+#endif /* VINO_ENABLE_LIBNOTIFY */
+
+static gboolean
+vino_app_indicator_show_new_client_notification (gpointer user_data)
+{
+#ifdef VINO_ENABLE_LIBNOTIFY
+#define NOTIFICATION_TIMEOUT 5
+
+  GError     *error;
+  const char *summary;
+  char       *body;
+
+  VinoAppIndicatorNotify *a = (VinoAppIndicatorNotify *)user_data;
+  VinoAppIndicator *indicator    = a->indicator;
+  VinoClient     *client  = a->client;
+
+  if (vino_server_get_prompt_enabled (indicator->priv->server))
+  {
+    g_free (user_data);
+    return FALSE;
+  }
+
+  if (!notify_is_initted () &&  !notify_init (g_get_application_name ()))
+    {
+      g_printerr (_("Error initializing libnotify\n"));
+      g_free (user_data);
+      return FALSE;
+    }
+
+  if (g_slist_index (indicator->priv->clients, client) == -1)
+    {
+      g_free (user_data);
+      return FALSE;
+    }
+
+  if (indicator->priv->new_client_notification)
+    {
+      notify_notification_close (indicator->priv->new_client_notification, NULL);
+      g_object_unref (indicator->priv->new_client_notification);
+      indicator->priv->new_client_notification = NULL;
+    }
+
+  if (vino_server_get_view_only (indicator->priv->server))
+    {
+      /* Translators: %s is a hostname */
+      summary = _("Another user is viewing your desktop");
+      body = g_strdup_printf
+          (_("A user on the computer '%s' is remotely viewing your desktop."),
+          vino_client_get_hostname (client));
+    }
+  else
+    {
+      /* Translators: %s is a hostname */
+      summary = _("Another user is controlling your desktop");
+      body = g_strdup_printf
+          (_("A user on the computer '%s' is remotely controlling "
+          "your desktop."), vino_client_get_hostname (client));
+    }
+
+  indicator->priv->new_client_notification =
+    notify_notification_new (summary,
+			     body,
+			     "preferences-desktop-remote-desktop");
+
+  g_free (body);
+
+  g_signal_connect_swapped (indicator->priv->new_client_notification, "closed",
+                            G_CALLBACK (vino_status_handle_new_client_notification_closed),
+                            indicator);
+
+  notify_notification_set_timeout (indicator->priv->new_client_notification,
+                                   NOTIFICATION_TIMEOUT * 1000);
+
+  error = NULL;
+  if (!notify_notification_show (indicator->priv->new_client_notification, &error))
+    {
+      g_printerr (_("Error while displaying notification bubble: %s\n"),
+                  error->message);
+      g_error_free (error);
+    }
+
+  g_free (user_data);
+
+#undef NOTIFICATION_TIMEOUT
+#endif /* VINO_ENABLE_LIBNOTIFY */
+
+  return FALSE;
+}
+
+void
+vino_app_indicator_set_visibility (VinoAppIndicator *indicator,
+				   VinoIconVisibility  visibility)
+{
+  g_return_if_fail (VINO_IS_APP_INDICATOR (indicator));
+  g_return_if_fail (visibility != VINO_ICON_VISIBILITY_INVALID);
+
+  if (visibility != indicator->priv->visibility)
+    {
+      indicator->priv->visibility = visibility;
+      vino_app_indicator_update_state (indicator);
+    }
+}
+
+VinoIconVisibility
+vino_app_indicator_get_visibility (VinoAppIndicator *indicator)
+{
+  g_return_val_if_fail (VINO_IS_APP_INDICATOR (indicator), VINO_ICON_VISIBILITY_INVALID);
+
+  return indicator->priv->visibility;
+}

=== added file 'server/vino-app-indicator.h'
--- old/server/vino-app-indicator.h	1970-01-01 00:00:00 +0000
+++ new/server/vino-app-indicator.h	2010-09-09 21:17:56 +0000
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2010 Canonical Ltd
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ * Authors:
+ *      Travis B. Hartwell <nafai@travishartwell.net>
+ */
+
+#ifndef __VINO_APP_INDICATOR_H__
+#define __VINO_APP_INDICATOR_H__
+
+#include <gtk/gtk.h>
+#include "vino-icon-visibility.h"
+
+G_BEGIN_DECLS
+
+#define VINO_TYPE_APP_INDICATOR         (vino_app_indicator_get_type ())
+#define VINO_APP_INDICATOR(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), VINO_TYPE_APP_INDICATOR, VinoAppIndicator))
+#define VINO_APP_INDICATOR_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), VINO_TYPE_APP_INDICATOR, VinoAppIndicatorClass))
+#define VINO_IS_APP_INDICATOR(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), VINO_TYPE_APP_INDICATOR))
+#define VINO_IS_APP_INDICATOR_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), VINO_TYPE_APP_INDICATOR))
+#define VINO_APP_INDICATOR_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), VINO_TYPE_APP_INDICATOR, VinoAppIndicatorClass))
+
+typedef struct _VinoAppIndicator        VinoAppIndicator;
+typedef struct _VinoAppIndicatorClass   VinoAppIndicatorClass;
+typedef struct _VinoAppIndicatorPrivate VinoAppIndicatorPrivate;
+
+struct _VinoAppIndicator
+{
+  GObject          base;
+
+  VinoAppIndicatorPrivate *priv;
+};
+
+struct _VinoAppIndicatorClass
+{
+  GObjectClass base_class;
+};
+
+#include "vino-server.h"
+
+GType           vino_app_indicator_get_type      (void) G_GNUC_CONST;
+
+VinoAppIndicator *vino_app_indicator_new           (VinoServer      *server);
+
+VinoServer     *vino_app_indicator_get_server    (VinoAppIndicator  *indicator);
+
+void            vino_app_indicator_add_client    (VinoAppIndicator  *indicator,
+						  VinoClient      *client);
+gboolean        vino_app_indicator_remove_client (VinoAppIndicator  *indicator,
+						  VinoClient      *client);
+
+void		vino_app_indicator_update_state	(VinoAppIndicator *indicator);
+void		vino_app_indicator_set_visibility	(VinoAppIndicator           *indicator,
+							 VinoIconVisibility visibility);
+VinoIconVisibility vino_app_indicator_get_visibility (VinoAppIndicator *indicator);
+
+G_END_DECLS
+
+#endif /* __VINO_APP_INDICATOR_H__ */

=== added file 'server/vino-icon-visibility.h'
--- old/server/vino-icon-visibility.h	1970-01-01 00:00:00 +0000
+++ new/server/vino-icon-visibility.h	2010-09-09 21:17:56 +0000
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2006 Jonh Wendell
+ * Copyright (C) 2010 Canonical Ltd
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ * Authors:
+ *      Jonh Wendell <wendell@bani.com.br>
+ *      Travis B. Hartwell <nafai@travishartwell.net>
+ */
+
+#ifndef __VINO_ICON_VISIBILITY_H__
+#define __VINO_ICON_VISIBILITY_H__
+
+G_BEGIN_DECLS
+
+typedef enum
+{
+  VINO_ICON_VISIBILITY_INVALID = 0,
+  VINO_ICON_VISIBILITY_ALWAYS,
+  VINO_ICON_VISIBILITY_CLIENT,
+  VINO_ICON_VISIBILITY_NEVER
+} VinoIconVisibility;
+
+G_END_DECLS
+
+#endif /* __VINO_ICON_VISIBILITY_H__ */

=== modified file 'server/vino-prefs.c'
--- old/server/vino-prefs.c	2010-09-09 21:16:40 +0000
+++ new/server/vino-prefs.c	2010-09-09 21:17:56 +0000
@@ -31,7 +31,11 @@
 #include "vino-prefs.h"
 #include "vino-util.h"
 #include "vino-mdns.h"
+#ifdef VINO_ENABLE_APP_INDICATOR
+#include "vino-app-indicator.h"
+#else
 #include "vino-status-icon.h"
+#endif /* VINO_ENABLE_APP_INDICATOR */
 #include "vino-background.h"
 
 #define VINO_PREFS_DIR                    "/desktop/gnome/remote_access"
@@ -72,7 +76,7 @@
 static gboolean        vino_disable_background   = FALSE;
 static gboolean        vino_use_upnp             = TRUE;
 static gboolean        vino_disable_xdamage      = FALSE;
-static VinoStatusIconVisibility vino_icon_visibility = VINO_STATUS_ICON_VISIBILITY_CLIENT;
+static VinoIconVisibility vino_icon_visibility = VINO_ICON_VISIBILITY_CLIENT;
 
 static void
 vino_prefs_enabled_changed (GConfClient *client,
@@ -375,17 +379,17 @@
     vino_server_set_lock_screen (l->data, lock_screen);
 }
 
-static VinoStatusIconVisibility
+static VinoIconVisibility
 vino_prefs_icon_visibility_from_string (const char *value)
 {
-  VinoStatusIconVisibility ret_value = VINO_STATUS_ICON_VISIBILITY_INVALID;
+  VinoIconVisibility ret_value = VINO_ICON_VISIBILITY_INVALID;
 
   if (!g_ascii_strcasecmp (value, "always"))
-    ret_value = VINO_STATUS_ICON_VISIBILITY_ALWAYS;
+    ret_value = VINO_ICON_VISIBILITY_ALWAYS;
   else if (!g_ascii_strcasecmp (value, "client"))
-    ret_value = VINO_STATUS_ICON_VISIBILITY_CLIENT;
+    ret_value = VINO_ICON_VISIBILITY_CLIENT;
   else if (!g_ascii_strcasecmp (value, "never"))
-    ret_value = VINO_STATUS_ICON_VISIBILITY_NEVER;
+    ret_value = VINO_ICON_VISIBILITY_NEVER;
 
   return ret_value;
 }
@@ -397,7 +401,7 @@
 {
   const gchar  *entry_str;
   GSList *l;
-  VinoStatusIconVisibility visibility;
+  VinoIconVisibility visibility;
 
   if (!entry->value || entry->value->type != GCONF_VALUE_STRING)
     return;
@@ -414,10 +418,17 @@
 
   for (l = vino_servers; l; l = l->next)
     {
+#ifdef VINO_ENABLE_APP_INDICATOR
+      VinoAppIndicator *indicator;
+
+      indicator = vino_server_get_app_indicator (l->data);
+      vino_app_indicator_set_visibility (indicator, visibility);
+#else
       VinoStatusIcon *icon;
 
       icon = vino_server_get_status_icon (l->data);
       vino_status_icon_set_visibility (icon, visibility);
+#endif /* VINO_ENABLE_APP_INDICATOR */
     }
 }
 
@@ -497,8 +508,11 @@
 vino_prefs_create_server (GdkScreen *screen)
 {
   VinoServer     *server;
+#ifdef VINO_ENABLE_APP_INDICATOR
+  VinoAppIndicator *indicator;
+#else
   VinoStatusIcon *icon;
-
+#endif /* VINO_ENABLE_APP_INDICATOR */
 
   server = g_object_new (VINO_TYPE_SERVER,
 			 "prompt-enabled",       vino_prompt_enabled,
@@ -525,8 +539,13 @@
   g_signal_connect (server, "notify::use-alternative-port", G_CALLBACK(vino_prefs_restart_mdns), NULL);
   g_signal_connect (server, "notify::network-interface", G_CALLBACK (vino_prefs_restart_mdns), NULL);
 
+#ifdef VINO_ENABLE_APP_INDICATOR
+  indicator = vino_server_get_app_indicator (server);
+  vino_app_indicator_set_visibility (indicator, vino_icon_visibility);
+#else
   icon = vino_server_get_status_icon (server);
   vino_status_icon_set_visibility (icon, vino_icon_visibility);
+#endif /* VINO_ENABLE_APP_INDICATOR */
 }
 
 static void

=== modified file 'server/vino-server.c'
--- old/server/vino-server.c	2010-09-09 21:16:40 +0000
+++ new/server/vino-server.c	2010-09-09 21:17:56 +0000
@@ -61,8 +61,13 @@
   VinoFB           *fb;
   VinoCursorData   *cursor_data;
   VinoPrompt       *prompt;
+#ifdef VINO_ENABLE_APP_INDICATOR
+  VinoAppIndicator *indicator;
+  gboolean          display_app_indicator;
+#else
   VinoStatusIcon   *icon;
   gboolean          display_status_icon;
+#endif /* VINO_ENABLE_APP_INDICATOR */
   VinoDBusListener *listener;
   gboolean          use_dbus_listener;
   VinoUpnp         *upnp;
@@ -114,7 +119,11 @@
   PROP_ON_HOLD,
   PROP_PROMPT_ENABLED,
   PROP_VIEW_ONLY,
+#ifdef VINO_ENABLE_APP_INDICATOR
+  PROP_DISPLAY_APP_INDICATOR,
+#else
   PROP_DISPLAY_STATUS_ICON,
+#endif /* VINO_ENABLE_APP_INDICATOR */
   PROP_USE_DBUS_LISTENER,
   PROP_NETWORK_INTERFACE,
   PROP_USE_ALTERNATIVE_PORT,
@@ -303,8 +312,13 @@
 vino_server_client_accepted (VinoServer *server,
                              VinoClient *client)
 {
+#ifdef VINO_ENABLE_APP_INDICATOR
+  if (server->priv->display_app_indicator)
+    vino_app_indicator_add_client (server->priv->indicator, client);
+#else
   if (server->priv->display_status_icon)
     vino_status_icon_add_client (server->priv->icon, client);
+#endif /* VINO_ENABLE_APP_INDICATOR */
 
   vino_server_unlock_screen ();
 
@@ -317,9 +331,15 @@
 vino_server_client_disconnected (VinoServer *server,
                                  VinoClient *client)
 {
+#ifdef VINO_ENABLE_APP_INDICATOR
+  if (server->priv->display_app_indicator)
+    {
+      if (vino_app_indicator_remove_client (server->priv->indicator, client))
+#else
   if (server->priv->display_status_icon)
     {
       if (vino_status_icon_remove_client (server->priv->icon, client))
+#endif /* VINO_ENABLE_APP_INDICATOR */
         {
           vino_server_lock_screen (server);
 
@@ -1122,9 +1142,15 @@
     g_object_unref (server->priv->listener);
   server->priv->listener = NULL;
 
+#ifdef VINO_ENABLE_APP_INDICATOR
+  if (server->priv->indicator)
+    g_object_unref (server->priv->indicator);
+  server->priv->indicator = NULL;
+#else
   if (server->priv->icon)
     g_object_unref (server->priv->icon);
   server->priv->icon = NULL;
+#endif /* VINO_ENABLE_APP_INDICATOR */
 
   if (server->priv->upnp)
     g_object_unref (server->priv->upnp);
@@ -1159,9 +1185,15 @@
     case PROP_VIEW_ONLY:
       vino_server_set_view_only (server, g_value_get_boolean (value));
       break;
+#ifdef VINO_ENABLE_APP_INDICATOR
+    case PROP_DISPLAY_APP_INDICATOR:
+      vino_server_set_display_app_indicator (server, g_value_get_boolean (value));
+      break;
+#else
     case PROP_DISPLAY_STATUS_ICON:
       vino_server_set_display_status_icon (server, g_value_get_boolean (value));
       break;
+#endif /* VINO_ENABLE_APP_INDICATOR */
     case PROP_USE_DBUS_LISTENER:
       vino_server_set_use_dbus_listener (server, g_value_get_boolean (value));
       break;
@@ -1223,9 +1255,15 @@
     case PROP_VIEW_ONLY:
       g_value_set_boolean (value, server->priv->view_only);
       break;
+#ifdef VINO_ENABLE_APP_INDICATOR
+    case PROP_DISPLAY_APP_INDICATOR:
+      g_value_set_boolean (value, server->priv->display_app_indicator);
+      break;
+#else
     case PROP_DISPLAY_STATUS_ICON:
       g_value_set_boolean (value, server->priv->display_status_icon);
       break;
+#endif /* VINO_ENABLE_APP_INDICATOR */
     case PROP_USE_DBUS_LISTENER:
       g_value_set_boolean (value, server->priv->use_dbus_listener);
       break;
@@ -1278,10 +1316,17 @@
   else
     server->priv->listener = NULL;
 
+#ifdef VINO_ENABLE_APP_INDICATOR
+  if (server->priv->display_app_indicator)
+    server->priv->indicator = vino_app_indicator_new (server);
+  else
+    server->priv->indicator = NULL;
+#else
   if (server->priv->display_status_icon)
     server->priv->icon = vino_status_icon_new (server, server->priv->screen);
   else
     server->priv->icon = NULL;
+#endif /* VINO_ENABLE_APP_INDICATOR */
 
 }
 
@@ -1351,6 +1396,17 @@
                                                          G_PARAM_STATIC_NICK |
                                                          G_PARAM_STATIC_BLURB));
 
+#ifdef VINO_ENABLE_APP_INDICATOR
+   g_object_class_install_property (gobject_class,
+				    PROP_DISPLAY_APP_INDICATOR,
+				    g_param_spec_boolean ("display-app-indicator",
+							  "Display the application indicator",
+							  "Allow to display the application indicator",
+							  TRUE,
+							  G_PARAM_READWRITE   |
+							  G_PARAM_CONSTRUCT   |
+							  G_PARAM_STATIC_STRINGS));
+#else
    g_object_class_install_property (gobject_class,
 				   PROP_DISPLAY_STATUS_ICON,
 				   g_param_spec_boolean ("display-status-icon",
@@ -1360,6 +1416,7 @@
                                                          G_PARAM_READWRITE   |
                                                          G_PARAM_CONSTRUCT   |
                                                          G_PARAM_STATIC_STRINGS));
+#endif /* VINO_ENABLE_APP_INDICATOR */
 
    g_object_class_install_property (gobject_class,
 				   PROP_USE_DBUS_LISTENER,
@@ -1555,6 +1612,16 @@
     }
 }
 
+#ifdef VINO_ENABLE_APP_INDICATOR
+void
+vino_server_set_display_app_indicator (VinoServer *server,
+    gboolean display_app_indicator)
+{
+  g_return_if_fail (VINO_IS_SERVER (server));
+
+  server->priv->display_app_indicator = display_app_indicator;
+}
+#else
 void
 vino_server_set_display_status_icon (VinoServer *server,
     gboolean display_status_icon)
@@ -1563,6 +1630,7 @@
 
   server->priv->display_status_icon = display_status_icon;
 }
+#endif /* VINO_ENABLE_APP_INDICATOR */
 
 void
 vino_server_set_use_dbus_listener (VinoServer *server,
@@ -1707,8 +1775,13 @@
 
       g_object_notify (G_OBJECT (server), "on-hold");
 
+#ifdef VINO_ENABLE_APP_INDICATOR
+      if (server->priv->indicator)
+        vino_app_indicator_update_state (server->priv->indicator);
+#else
       if (server->priv->icon)
         vino_status_icon_update_state (server->priv->icon);
+#endif /* VINO_ENABLE_APP_INDICATOR */
 
       vino_server_control_upnp (server);
     }
@@ -1897,6 +1970,15 @@
     }
 }
 
+#ifdef VINO_ENABLE_APP_INDICATOR
+VinoAppIndicator *
+vino_server_get_app_indicator (VinoServer *server)
+{
+  g_return_val_if_fail (VINO_IS_SERVER (server), NULL);
+
+  return server->priv->indicator;
+}
+#else
 VinoStatusIcon *
 vino_server_get_status_icon (VinoServer *server)
 {
@@ -1904,4 +1986,4 @@
 
   return server->priv->icon;
 }
-
+#endif /* VINO_ENABLE_APP_INDICATOR */

=== modified file 'server/vino-server.h'
--- old/server/vino-server.h	2010-09-09 21:16:40 +0000
+++ new/server/vino-server.h	2010-09-09 21:17:56 +0000
@@ -79,8 +79,13 @@
 void                 vino_server_set_view_only            (VinoServer     *server,
 							   gboolean        view_only);
 gboolean             vino_server_get_view_only            (VinoServer     *server);
+#ifdef VINO_ENABLE_APP_INDICATOR
+void                 vino_server_set_display_app_indicator  (VinoServer     *server,
+                                                             gboolean        display_app_indicator);
+#else
 void                 vino_server_set_display_status_icon  (VinoServer     *server,
                                                            gboolean        display_status_icon);
+#endif /* VINO_ENABLE_APP_INDICATOR */
 void                 vino_server_set_use_dbus_listener    (VinoServer     *server,
                                                            gboolean        use_dbus_listener);
 gboolean             vino_server_get_use_alternative_port (VinoServer     *server);
@@ -120,8 +125,13 @@
                                                            gboolean        disable_xdamage);
 gboolean             vino_server_get_disable_xdamage      (VinoServer     *server);
 
+#ifdef VINO_ENABLE_APP_INDICATOR
+#include "vino-app-indicator.h"
+VinoAppIndicator    *vino_server_get_app_indicator        (VinoServer      *server);
+#else
 #include "vino-status-icon.h"
 VinoStatusIcon      *vino_server_get_status_icon          (VinoServer      *server);
+#endif /* VINO_ENABLE_APP_INDICATOR */
 
 G_CONST_RETURN char *vino_client_get_hostname (VinoClient *client);
 void                 vino_client_disconnect   (VinoClient *client);

=== modified file 'server/vino-status-icon.c'
--- old/server/vino-status-icon.c	2010-09-09 21:16:40 +0000
+++ new/server/vino-status-icon.c	2010-09-09 21:17:56 +0000
@@ -39,7 +39,7 @@
   VinoServer *server;
   GSList     *clients;
   GtkWidget  *disconnect_dialog;
-  VinoStatusIconVisibility visibility;
+  VinoIconVisibility visibility;
 
 #ifdef VINO_ENABLE_LIBNOTIFY
   NotifyNotification *new_client_notification;
@@ -111,11 +111,11 @@
                                            "%d people are connected",
                                            n_clients),
                                  n_clients);
-      visible = (visible) && ( (icon->priv->visibility == VINO_STATUS_ICON_VISIBILITY_CLIENT) ||
-			     (icon->priv->visibility == VINO_STATUS_ICON_VISIBILITY_ALWAYS) );
+      visible = (visible) && ( (icon->priv->visibility == VINO_ICON_VISIBILITY_CLIENT) ||
+			     (icon->priv->visibility == VINO_ICON_VISIBILITY_ALWAYS) );
     }
   else
-    visible = visible && (icon->priv->visibility == VINO_STATUS_ICON_VISIBILITY_ALWAYS);
+    visible = visible && (icon->priv->visibility == VINO_ICON_VISIBILITY_ALWAYS);
 
   gtk_status_icon_set_tooltip_text (GTK_STATUS_ICON (icon), tooltip);
   gtk_status_icon_set_visible (GTK_STATUS_ICON (icon), visible);
@@ -544,8 +544,8 @@
 				   g_param_spec_enum ("visibility",
 						      "Icon visibility",
 						      "When the icon must be shown",
-						      VINO_TYPE_STATUS_ICON_VISIBILITY,
-						      VINO_STATUS_ICON_VISIBILITY_CLIENT,
+						      VINO_TYPE_ICON_VISIBILITY,
+						      VINO_ICON_VISIBILITY_CLIENT,
 						      G_PARAM_READWRITE |
 						      G_PARAM_CONSTRUCT |
 						      G_PARAM_STATIC_NAME |
@@ -654,10 +654,10 @@
 
 void
 vino_status_icon_set_visibility (VinoStatusIcon *icon,
-				 VinoStatusIconVisibility  visibility)
+				 VinoIconVisibility  visibility)
 {
   g_return_if_fail (VINO_IS_STATUS_ICON (icon));
-  g_return_if_fail (visibility != VINO_STATUS_ICON_VISIBILITY_INVALID);
+  g_return_if_fail (visibility != VINO_ICON_VISIBILITY_INVALID);
 
   if (visibility != icon->priv->visibility)
     {
@@ -666,10 +666,10 @@
     }
 }
 
-VinoStatusIconVisibility
+VinoIconVisibility
 vino_status_icon_get_visibility (VinoStatusIcon *icon)
 {
-  g_return_val_if_fail (VINO_IS_STATUS_ICON (icon), VINO_STATUS_ICON_VISIBILITY_INVALID);
+  g_return_val_if_fail (VINO_IS_STATUS_ICON (icon), VINO_ICON_VISIBILITY_INVALID);
 
   return icon->priv->visibility;
 }

=== modified file 'server/vino-status-icon.h'
--- old/server/vino-status-icon.h	2010-09-09 21:16:40 +0000
+++ new/server/vino-status-icon.h	2010-09-09 21:17:56 +0000
@@ -24,17 +24,10 @@
 #define __VINO_STATUS_ICON_H__
 
 #include <gtk/gtk.h>
+#include "vino-icon-visibility.h"
 
 G_BEGIN_DECLS
 
-typedef enum
-{
-  VINO_STATUS_ICON_VISIBILITY_INVALID = 0,
-  VINO_STATUS_ICON_VISIBILITY_ALWAYS,
-  VINO_STATUS_ICON_VISIBILITY_CLIENT,
-  VINO_STATUS_ICON_VISIBILITY_NEVER
-} VinoStatusIconVisibility;
-
 #define VINO_TYPE_STATUS_ICON         (vino_status_icon_get_type ())
 #define VINO_STATUS_ICON(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), VINO_TYPE_STATUS_ICON, VinoStatusIcon))
 #define VINO_STATUS_ICON_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), VINO_TYPE_STATUS_ICON, VinoStatusIconClass))
@@ -74,8 +67,8 @@
 
 void		vino_status_icon_update_state	(VinoStatusIcon *icon);
 void		vino_status_icon_set_visibility	(VinoStatusIcon           *icon,
-						 VinoStatusIconVisibility visibility);
-VinoStatusIconVisibility vino_status_icon_get_visibility (VinoStatusIcon *icon);
+						 VinoIconVisibility visibility);
+VinoIconVisibility vino_status_icon_get_visibility (VinoStatusIcon *icon);
 
 G_END_DECLS
 

=== modified file 'server/vino-status-tube-icon.c'
--- old/server/vino-status-tube-icon.c	2010-09-09 21:16:40 +0000
+++ new/server/vino-status-tube-icon.c	2010-09-09 21:17:56 +0000
@@ -37,7 +37,7 @@
   GtkMenu *menu;
   VinoTubeServer *server;
   GtkWidget *disconnect_dialog;
-  VinoStatusTubeIconVisibility visibility;
+  VinoTubeIconVisibility visibility;
 
 #ifdef VINO_ENABLE_LIBNOTIFY
   NotifyNotification *new_client_notification;
@@ -94,7 +94,7 @@
 
   tooltip = g_strdup (_("Desktop sharing is enabled"));
 
-  visible = visible && (icon->priv->visibility == VINO_STATUS_TUBE_ICON_VISIBILITY_ALWAYS);
+  visible = visible && (icon->priv->visibility == VINO_TUBE_ICON_VISIBILITY_ALWAYS);
 
   gtk_status_icon_set_tooltip_text (GTK_STATUS_ICON (icon), tooltip);
   gtk_status_icon_set_visible (GTK_STATUS_ICON (icon), visible);
@@ -341,8 +341,8 @@
       g_param_spec_enum ("visibility",
       "Icon visibility",
       "When the icon must be shown",
-      VINO_TYPE_STATUS_TUBE_ICON_VISIBILITY,
-      VINO_STATUS_TUBE_ICON_VISIBILITY_CLIENT,
+      VINO_TYPE_TUBE_ICON_VISIBILITY,
+      VINO_TUBE_ICON_VISIBILITY_CLIENT,
       G_PARAM_READWRITE |
       G_PARAM_CONSTRUCT |
       G_PARAM_STATIC_NAME |
@@ -354,10 +354,10 @@
 
 void
 vino_status_tube_icon_set_visibility (VinoStatusTubeIcon *icon,
-    VinoStatusTubeIconVisibility  visibility)
+    VinoTubeIconVisibility  visibility)
 {
   g_return_if_fail (VINO_IS_STATUS_TUBE_ICON (icon));
-  g_return_if_fail (visibility != VINO_STATUS_TUBE_ICON_VISIBILITY_INVALID);
+  g_return_if_fail (visibility != VINO_TUBE_ICON_VISIBILITY_INVALID);
 
   if (visibility != icon->priv->visibility)
     {

=== modified file 'server/vino-status-tube-icon.h'
--- old/server/vino-status-tube-icon.h	2010-09-09 21:16:40 +0000
+++ new/server/vino-status-tube-icon.h	2010-09-09 21:17:56 +0000
@@ -26,17 +26,10 @@
 #include <gdk/gdk.h>
 
 #include "vino-tube-server.h"
+#include "vino-tube-icon-visibility.h"
 
 G_BEGIN_DECLS
 
-typedef enum
-{
-  VINO_STATUS_TUBE_ICON_VISIBILITY_INVALID = 0,
-  VINO_STATUS_TUBE_ICON_VISIBILITY_ALWAYS,
-  VINO_STATUS_TUBE_ICON_VISIBILITY_CLIENT,
-  VINO_STATUS_TUBE_ICON_VISIBILITY_NEVER
-} VinoStatusTubeIconVisibility;
-
 #define VINO_TYPE_STATUS_TUBE_ICON (vino_status_tube_icon_get_type ())
 #define VINO_STATUS_TUBE_ICON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), \
     VINO_TYPE_STATUS_TUBE_ICON, VinoStatusTubeIcon))
@@ -72,7 +65,7 @@
 void vino_status_tube_icon_update_state (VinoStatusTubeIcon *icon);
 
 void vino_status_tube_icon_set_visibility (VinoStatusTubeIcon *icon,
-    VinoStatusTubeIconVisibility visibility);
+    VinoTubeIconVisibility visibility);
 
 void vino_status_tube_icon_show_notif (VinoStatusTubeIcon *icon,
     const gchar *summary, const gchar *body, gboolean invalidated);

=== added file 'server/vino-tube-app-indicator.c'
--- old/server/vino-tube-app-indicator.c	1970-01-01 00:00:00 +0000
+++ new/server/vino-tube-app-indicator.c	2010-09-13 21:32:18 +0000
@@ -0,0 +1,456 @@
+/*
+ * © 2010, Canonical Ltd
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ * Authors:
+ *      Travis B. Hartwell <nafai@travishartwell.net>
+ */
+
+#include <config.h>
+#include <string.h>
+#include <gtk/gtk.h>
+#ifdef VINO_ENABLE_LIBNOTIFY
+#include <glib/gi18n.h>
+#include <libnotify/notify.h>
+#endif
+#include <libappindicator/app-indicator.h>
+
+#include "vino-tube-app-indicator.h"
+#include "vino-enums.h"
+#include "vino-util.h"
+
+static void vino_tube_app_indicator_disconnect_confirm (VinoTubeAppIndicator *indicator);
+static void vino_tube_app_indicator_help (VinoTubeAppIndicator *indicator);
+static void vino_tube_app_indicator_preferences (VinoTubeAppIndicator *indicator);
+
+struct _VinoTubeAppIndicatorPrivate
+{
+  AppIndicator *indicator;
+  GtkMenu *menu;
+  GtkMenuItem *status_menu_item;
+  VinoTubeServer *server;
+  GtkWidget *disconnect_dialog;
+  VinoTubeIconVisibility visibility;
+
+#ifdef VINO_ENABLE_LIBNOTIFY
+  NotifyNotification *new_client_notification;
+#endif
+};
+
+G_DEFINE_TYPE (VinoTubeAppIndicator, vino_tube_app_indicator, G_TYPE_OBJECT);
+
+enum
+{
+  PROP_0,
+  PROP_SERVER,
+  PROP_VISIBILITY
+};
+
+static void
+vino_tube_app_indicator_finalize (GObject *object)
+{
+  VinoTubeAppIndicator *indicator = VINO_TUBE_APP_INDICATOR (object);
+
+#ifdef VINO_ENABLE_LIBNOTIFY
+  if (indicator->priv->new_client_notification != NULL)
+    {
+      notify_notification_close (indicator->priv->new_client_notification, NULL);
+      g_object_unref (indicator->priv->new_client_notification);
+      indicator->priv->new_client_notification = NULL;
+    }
+ #endif
+
+  if (indicator->priv->status_menu_item != NULL)
+    {
+      gtk_widget_destroy (GTK_WIDGET (indicator->priv->status_menu_item));
+      indicator->priv->status_menu_item = NULL;
+    }
+  if (indicator->priv->menu != NULL)
+    {
+      gtk_widget_destroy (GTK_WIDGET (indicator->priv->menu));
+      indicator->priv->menu = NULL;
+    }
+
+  if (indicator->priv->disconnect_dialog != NULL)
+    {
+      gtk_widget_destroy (indicator->priv->disconnect_dialog);
+      indicator->priv->disconnect_dialog = NULL;
+    }
+
+  if (indicator->priv->indicator != NULL)
+    {
+      g_object_unref (indicator->priv->indicator);
+      indicator->priv->indicator = NULL;
+    }
+
+  G_OBJECT_CLASS (vino_tube_app_indicator_parent_class)->finalize (object);
+}
+
+void
+vino_tube_app_indicator_update_state (VinoTubeAppIndicator *indicator)
+{
+  char     *tooltip;
+  gboolean visible;
+  AppIndicatorStatus status;
+
+  g_return_if_fail (VINO_IS_TUBE_APP_INDICATOR (indicator));
+
+  visible = !vino_server_get_on_hold (VINO_SERVER (indicator->priv->server));
+
+  tooltip = g_strdup (_("Desktop sharing is enabled"));
+
+  visible = visible && (indicator->priv->visibility == VINO_TUBE_ICON_VISIBILITY_ALWAYS);
+
+  gtk_menu_item_set_label (GTK_MENU_ITEM (indicator->priv->status_menu_item), tooltip);
+
+  status = visible ? APP_INDICATOR_STATUS_ACTIVE : APP_INDICATOR_STATUS_PASSIVE;
+  app_indicator_set_status (indicator->priv->indicator, status);
+
+  g_free (tooltip);
+}
+
+
+static void
+vino_tube_app_indicator_create_menu (VinoTubeAppIndicator *indicator)
+{
+  GtkWidget *item;
+  char *str;
+
+  indicator->priv->menu = (GtkMenu*) gtk_menu_new ();
+
+  indicator->priv->status_menu_item = (GtkMenuItem*) gtk_menu_item_new ();
+  gtk_widget_set_sensitive (GTK_WIDGET (indicator->priv->status_menu_item), FALSE);
+  gtk_widget_show (GTK_WIDGET (indicator->priv->status_menu_item));
+  gtk_menu_shell_append (GTK_MENU_SHELL (indicator->priv->menu), GTK_WIDGET (indicator->priv->status_menu_item));
+
+  item = gtk_separator_menu_item_new ();
+  gtk_widget_show (item);
+  gtk_menu_shell_append (GTK_MENU_SHELL (indicator->priv->menu), item);
+
+  item = gtk_image_menu_item_new_with_mnemonic (_("_Preferences"));
+  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (item),
+      gtk_image_new_from_stock (GTK_STOCK_PREFERENCES, GTK_ICON_SIZE_MENU));
+  g_signal_connect_swapped (item, "activate",
+      G_CALLBACK (vino_tube_app_indicator_preferences), indicator);
+  gtk_widget_show (item);
+  gtk_menu_shell_append (GTK_MENU_SHELL (indicator->priv->menu), item);
+
+  item = gtk_separator_menu_item_new ();
+  gtk_widget_show (item);
+  gtk_menu_shell_append (GTK_MENU_SHELL (indicator->priv->menu), item);
+
+  
+  /* Translators: %s is the alias of the telepathy contact */
+  if (indicator->priv->server != NULL) {
+    str = g_strdup_printf (_("Disconnect %s"),
+      vino_tube_server_get_alias (indicator->priv->server));
+  } else {
+    str = g_strdup_printf (_("Disconnect"));
+  }
+
+  item  = gtk_image_menu_item_new_with_label (str);
+  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (item),
+  gtk_image_new_from_stock (GTK_STOCK_NETWORK, GTK_ICON_SIZE_MENU));
+
+  g_signal_connect_swapped (item, "activate",
+      G_CALLBACK (vino_tube_app_indicator_disconnect_confirm), indicator);
+
+  gtk_widget_show (item);
+  gtk_menu_shell_append (GTK_MENU_SHELL (indicator->priv->menu), item);
+
+  g_free (str);
+
+  item = gtk_separator_menu_item_new ();
+  gtk_widget_show (item);
+  gtk_menu_shell_append (GTK_MENU_SHELL (indicator->priv->menu), item);
+
+  item = gtk_image_menu_item_new_with_mnemonic (_("_Help"));
+  gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (item),
+      gtk_image_new_from_stock (GTK_STOCK_HELP, GTK_ICON_SIZE_MENU));
+  g_signal_connect_swapped (item, "activate",
+      G_CALLBACK (vino_tube_app_indicator_help), indicator);
+  gtk_widget_show (item);
+  gtk_menu_shell_append (GTK_MENU_SHELL (indicator->priv->menu), item);
+  app_indicator_set_menu (indicator->priv->indicator, indicator->priv->menu);
+}
+
+static void
+vino_tube_app_indicator_init (VinoTubeAppIndicator *indicator)
+{
+  indicator->priv = G_TYPE_INSTANCE_GET_PRIVATE (indicator, VINO_TYPE_TUBE_APP_INDICATOR, VinoTubeAppIndicatorPrivate);
+
+  indicator->priv->indicator = app_indicator_new ("vino-tube-app-indicator",
+						  "preferences-desktop-remote-desktop",
+						  APP_INDICATOR_CATEGORY_APPLICATION_STATUS);
+
+  vino_tube_app_indicator_create_menu (indicator);
+  app_indicator_set_menu (indicator->priv->indicator, indicator->priv->menu);
+
+#ifdef VINO_ENABLE_LIBNOTIFY
+  indicator->priv->new_client_notification = NULL;
+#endif
+}
+
+static void
+vino_tube_app_indicator_set_property (GObject *object, guint prop_id,
+    const GValue *value, GParamSpec *pspec)
+{
+  VinoTubeAppIndicator *indicator = VINO_TUBE_APP_INDICATOR (object);
+
+  switch (prop_id)
+    {
+    case PROP_SERVER:
+      indicator->priv->server = g_value_get_object (value);
+      break;
+    case PROP_VISIBILITY:
+      vino_tube_app_indicator_set_visibility (indicator, g_value_get_enum (value));
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+    }
+}
+
+static void
+vino_tube_app_indicator_get_property (GObject *object, guint prop_id,
+    GValue *value, GParamSpec *pspec)
+{
+  VinoTubeAppIndicator *indicator = VINO_TUBE_APP_INDICATOR (object);
+
+  switch (prop_id)
+    {
+    case PROP_SERVER:
+      g_value_set_object (value, indicator->priv->server);
+      break;
+    case PROP_VISIBILITY:
+      g_value_set_enum (value, indicator->priv->visibility);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+    }
+}
+
+VinoTubeAppIndicator*
+vino_tube_app_indicator_new (VinoTubeServer *server)
+{
+  g_return_val_if_fail (VINO_IS_TUBE_SERVER (server), NULL);
+
+  return g_object_new (VINO_TYPE_TUBE_APP_INDICATOR, "server", server, NULL);
+}
+
+static void
+vino_tube_app_indicator_preferences (VinoTubeAppIndicator *indicator)
+{
+  GdkScreen *screen;
+  GError *error = NULL;
+
+  screen = gdk_screen_get_default ();
+  if (!gdk_spawn_command_line_on_screen (screen, "vino-preferences", &error))
+    {
+      vino_util_show_error (_("Error displaying preferences"),
+          error->message, NULL);
+      g_error_free (error);
+    }
+}
+
+static void
+vino_tube_app_indicator_help (VinoTubeAppIndicator *indicator)
+{
+  GdkScreen *screen;
+  GError    *error = NULL;
+
+  screen = gdk_screen_get_default ();
+  if (!gtk_show_uri (screen, "ghelp:user-guide?goscustdesk-90",
+      GDK_CURRENT_TIME, &error))
+    {
+      vino_util_show_error (_("Error displaying help"), error->message, NULL);
+      g_error_free (error);
+    }
+}
+
+static void
+vino_tube_app_indicator_disconnect_client (VinoTubeAppIndicator *indicator,
+    gint response)
+{
+  gtk_widget_destroy (indicator->priv->disconnect_dialog);
+  indicator->priv->disconnect_dialog = NULL;
+
+  if (response == GTK_RESPONSE_OK)
+    {
+      vino_tube_server_close_tube (indicator->priv->server);
+    }
+}
+
+static void
+vino_tube_app_indicator_disconnect_confirm (VinoTubeAppIndicator *indicator)
+{
+  char      *primary_msg;
+  char      *secondary_msg;
+
+  if (indicator->priv->disconnect_dialog)
+  {
+    gtk_window_present (GTK_WINDOW (indicator->priv->disconnect_dialog));
+    return;
+  }
+
+  /* Translators: %s is the alias of the telepathy contact */
+  primary_msg   = g_strdup_printf
+      (_("Are you sure you want to disconnect '%s'?"),
+      vino_tube_server_get_alias (indicator->priv->server));
+  secondary_msg = g_strdup_printf
+      (_("The remote user '%s' will be disconnected. Are you sure?"),
+      vino_tube_server_get_alias (indicator->priv->server));
+
+  indicator->priv->disconnect_dialog = gtk_message_dialog_new (NULL,
+      GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_QUESTION,
+      GTK_BUTTONS_CANCEL, "%s", primary_msg);
+
+  gtk_window_set_skip_taskbar_hint (GTK_WINDOW
+      (indicator->priv->disconnect_dialog), FALSE);
+
+  gtk_dialog_add_button (GTK_DIALOG (indicator->priv->disconnect_dialog),
+      _("Disconnect"), GTK_RESPONSE_OK);
+
+  gtk_message_dialog_format_secondary_text (GTK_MESSAGE_DIALOG
+      (indicator->priv->disconnect_dialog), "%s", secondary_msg);
+
+  g_signal_connect_swapped (indicator->priv->disconnect_dialog, "response",
+      G_CALLBACK (vino_tube_app_indicator_disconnect_client),
+      indicator);
+
+  gtk_widget_show_all (GTK_WIDGET (indicator->priv->disconnect_dialog));
+
+  g_free (primary_msg);
+  g_free (secondary_msg);
+
+}
+
+static void
+vino_tube_app_indicator_class_init (VinoTubeAppIndicatorClass *klass)
+{
+  GObjectClass       *gobject_class     = G_OBJECT_CLASS (klass);
+
+  gobject_class->finalize     = vino_tube_app_indicator_finalize;
+  gobject_class->set_property = vino_tube_app_indicator_set_property;
+  gobject_class->get_property = vino_tube_app_indicator_get_property;
+
+  g_object_class_install_property (gobject_class,
+      PROP_SERVER,
+      g_param_spec_object ("server",
+      "Server",
+      "The server",
+      VINO_TYPE_SERVER,
+      G_PARAM_READWRITE |
+      G_PARAM_CONSTRUCT_ONLY |
+      G_PARAM_STATIC_NAME |
+      G_PARAM_STATIC_NICK |
+      G_PARAM_STATIC_BLURB));
+  g_object_class_install_property (gobject_class,
+      PROP_VISIBILITY,
+      g_param_spec_enum ("visibility",
+      "Icon visibility",
+      "When the icon must be shown",
+      VINO_TYPE_TUBE_ICON_VISIBILITY,
+      VINO_TUBE_ICON_VISIBILITY_CLIENT,
+      G_PARAM_READWRITE |
+      G_PARAM_CONSTRUCT |
+      G_PARAM_STATIC_NAME |
+      G_PARAM_STATIC_NICK |
+      G_PARAM_STATIC_BLURB));
+
+  g_type_class_add_private (gobject_class, sizeof (VinoTubeAppIndicatorPrivate));
+}
+
+void
+vino_tube_app_indicator_set_visibility (VinoTubeAppIndicator *indicator,
+    VinoTubeIconVisibility  visibility)
+{
+  g_return_if_fail (VINO_IS_TUBE_APP_INDICATOR (indicator));
+  g_return_if_fail (visibility != VINO_TUBE_ICON_VISIBILITY_INVALID);
+
+  if (visibility != indicator->priv->visibility)
+    {
+      indicator->priv->visibility = visibility;
+      vino_tube_app_indicator_update_state (indicator);
+    }
+}
+
+#ifdef VINO_ENABLE_LIBNOTIFY
+static void
+vino_tube_app_indicator_show_invalidated_notif_closed
+    (VinoTubeAppIndicator *indicator)
+{
+  dprintf (TUBE, "Notification was closed");
+  vino_tube_server_fire_closed (indicator->priv->server);
+}
+#endif
+
+void
+vino_tube_app_indicator_show_notif (VinoTubeAppIndicator *indicator,
+    const gchar *summary, const gchar *body, gboolean invalidated)
+{
+#ifdef VINO_ENABLE_LIBNOTIFY
+#define NOTIFICATION_TIMEOUT 5
+
+  GError *error;
+  const gchar *filename = NULL;
+
+  if (!notify_is_initted () &&  !notify_init (g_get_application_name ()))
+    {
+      g_printerr (_("Error initializing libnotify\n"));
+      return;
+    }
+
+  if (indicator->priv->new_client_notification != NULL)
+    {
+      notify_notification_close (indicator->priv->new_client_notification, NULL);
+      g_object_unref (indicator->priv->new_client_notification);
+      indicator->priv->new_client_notification = NULL;
+    }
+
+  filename = vino_tube_server_get_avatar_filename (indicator->priv->server);
+
+  if (filename == NULL)
+      filename = "stock_person";
+
+  indicator->priv->new_client_notification =
+	  notify_notification_new (summary, body, filename);
+
+  notify_notification_set_timeout (indicator->priv->new_client_notification,
+      NOTIFICATION_TIMEOUT * 1000);
+
+  if (invalidated)
+    g_signal_connect_swapped (indicator->priv->new_client_notification, "closed",
+        G_CALLBACK (vino_tube_app_indicator_show_invalidated_notif_closed),
+        indicator);
+
+  error = NULL;
+  if (!notify_notification_show (indicator->priv->new_client_notification, &error))
+    {
+      g_printerr (_("Error while displaying notification bubble: %s\n"),
+                  error->message);
+      g_error_free (error);
+    }
+
+#undef NOTIFICATION_TIMEOUT
+#else
+  if (invalidated)
+    vino_tube_server_fire_closed (indicator->priv->server);
+#endif /* VINO_ENABLE_LIBNOTIFY */
+}
+

=== added file 'server/vino-tube-app-indicator.h'
--- old/server/vino-tube-app-indicator.h	1970-01-01 00:00:00 +0000
+++ new/server/vino-tube-app-indicator.h	2010-09-13 14:37:43 +0000
@@ -0,0 +1,73 @@
+/*
+ * © 2010, Canonical Ltd
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ * Authors:
+ *      Travis B. Hartwell <nafai@travishartwell.net>
+ */
+
+#ifndef __VINO_TUBE_APP_INDICATOR_H__
+#define __VINO_TUBE_APP_INDICATOR_H__
+
+#include <gdk/gdk.h>
+
+#include "vino-tube-server.h"
+#include "vino-tube-icon-visibility.h"
+
+G_BEGIN_DECLS
+
+#define VINO_TYPE_TUBE_APP_INDICATOR (vino_tube_app_indicator_get_type ())
+#define VINO_TUBE_APP_INDICATOR(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), \
+    VINO_TYPE_TUBE_APP_INDICATOR, VinoTubeAppIndicator))
+#define VINO_TUBE_APP_INDICATOR_CLASS(k) (G_TYPE_CHECK_CLASS_CAST((k), \
+    VINO_TYPE_TUBE_APP_INDICATOR, VinoTubeAppIndicatorClass))
+#define VINO_IS_TUBE_APP_INDICATOR(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), \
+    VINO_TYPE_TUBE_APP_INDICATOR))
+#define VINO_IS_TUBE_APP_INDICATOR_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), \
+    VINO_TYPE_TUBE_APP_INDICATOR))
+#define VINO_TUBE_APP_INDICATOR_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), \
+    VINO_TYPE_TUBE_APP_INDICATOR, VinoTubeAppIndicatorClass))
+
+typedef struct _VinoTubeAppIndicator VinoTubeAppIndicator;
+typedef struct _VinoTubeAppIndicatorClass VinoTubeAppIndicatorClass;
+typedef struct _VinoTubeAppIndicatorPrivate VinoTubeAppIndicatorPrivate;
+
+struct _VinoTubeAppIndicator
+{
+  GObject base;
+  VinoTubeAppIndicatorPrivate *priv;
+};
+
+struct _VinoTubeAppIndicatorClass
+{
+  GObjectClass base_class;
+};
+
+GType vino_tube_app_indicator_get_type (void) G_GNUC_CONST;
+
+VinoTubeAppIndicator* vino_tube_app_indicator_new (VinoTubeServer *server);
+
+void vino_tube_app_indicator_update_state (VinoTubeAppIndicator *indicator);
+
+void vino_tube_app_indicator_set_visibility (VinoTubeAppIndicator *indicator,
+    VinoTubeIconVisibility visibility);
+
+void vino_tube_app_indicator_show_notif (VinoTubeAppIndicator *indicator,
+    const gchar *summary, const gchar *body, gboolean invalidated);
+G_END_DECLS
+
+#endif /* __VINO_TUBE_APP_INDICATOR_H__ */

=== added file 'server/vino-tube-icon-visibility.h'
--- old/server/vino-tube-icon-visibility.h	1970-01-01 00:00:00 +0000
+++ new/server/vino-tube-icon-visibility.h	2010-09-09 21:17:56 +0000
@@ -0,0 +1,40 @@
+/*
+ * © 2009, Collabora Ltd
+ * © 2009, Canonical Ltd
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ * Authors:
+ *      Arnaud Maillet <arnaud.maillet@collabora.co.uk>
+ *      Travis B. Hartwell <nafai@travishartwell.net>
+ */
+
+#ifndef __VINO_TUBE_ICON_VISIBILITY_H__
+#define __VINO_TUBE_ICON_VISIBILITY_H__
+
+G_BEGIN_DECLS
+
+typedef enum
+{
+  VINO_TUBE_ICON_VISIBILITY_INVALID = 0,
+  VINO_TUBE_ICON_VISIBILITY_ALWAYS,
+  VINO_TUBE_ICON_VISIBILITY_CLIENT,
+  VINO_TUBE_ICON_VISIBILITY_NEVER
+} VinoTubeIconVisibility;
+
+G_END_DECLS
+
+#endif /* __VINO_TUBE_ICON_VISIBILITY_H__ */

=== modified file 'server/vino-tube-server.c'
--- old/server/vino-tube-server.c	2010-09-09 21:16:40 +0000
+++ new/server/vino-tube-server.c	2010-09-13 21:32:18 +0000
@@ -29,7 +29,6 @@
 #include <telepathy-glib/util.h>
 #include <telepathy-glib/contact.h>
 
-
 #include "vino-tube-server.h"
 #include "vino-dbus-error.h"
 #include "vino-util.h"
@@ -47,7 +46,11 @@
   TpConnection *connection;
   gchar *filename;
   gulong signal_invalidated_id;
+#ifdef VINO_ENABLE_APP_INDICATOR
+  VinoTubeAppIndicator *indicator;
+#else
   VinoStatusTubeIcon *icon_tube;
+#endif
   TpTubeChannelState state;
 };
 
@@ -80,11 +83,19 @@
       server->priv->tp_channel = NULL;
     }
 
+#ifdef VINO_ENABLE_APP_INDICATOR
+  if (server->priv->indicator != NULL)
+    {
+      g_object_unref (server->priv->indicator);
+      server->priv->indicator = NULL;
+    }
+#else
   if (server->priv->icon_tube != NULL)
     {
       g_object_unref (server->priv->icon_tube);
       server->priv->icon_tube = NULL;
     }
+#endif /* VINO_ENABLE_APP_INDICATOR */
 
   if (G_OBJECT_CLASS (vino_tube_server_parent_class)->dispose)
     G_OBJECT_CLASS (vino_tube_server_parent_class)->dispose (object);
@@ -187,7 +198,11 @@
 {
   self->priv = VINO_TUBE_SERVER_GET_PRIVATE (self);
   self->priv->tp_channel = NULL;
+#ifdef VINO_ENABLE_APP_INDICATOR
+  self->priv->indicator = NULL;
+#else
   self->priv->icon_tube = NULL;
+#endif /* VINO_ENABLE_APP_INDICATOR */
   self->priv->state = TP_TUBE_CHANNEL_STATE_NOT_OFFERED;
 }
 
@@ -276,8 +291,13 @@
       body = g_strdup_printf (_("'%s' disconnected"),
 			      vino_tube_server_get_alias (self));
 
+#ifdef VINO_ENABLE_APP_INDICATOR
+  vino_tube_app_indicator_show_notif (self->priv->indicator, summary,
+      (const gchar *)body, TRUE);
+#else
   vino_status_tube_icon_show_notif (self->priv->icon_tube, summary,
       (const gchar *)body, TRUE);
+#endif /* VINO_ENABLE_APP_INDICATOR */
 
   g_free (body);
 
@@ -302,8 +322,13 @@
         /* Translators: '%s' is the name of a contact, buddy coming from Empathy */
         body = g_strdup_printf (_("'%s' is remotely controlling your desktop."),
 				vino_tube_server_get_alias (server));
+#ifdef VINO_ENABLE_APP_INDICATOR
+        vino_tube_app_indicator_show_notif (server->priv->indicator, summary,
+            (const gchar*) body, FALSE);
+#else
         vino_status_tube_icon_show_notif (server->priv->icon_tube, summary,
             (const gchar*) body, FALSE);
+#endif /* VINO_ENABLE_APP_INDICATOR */
         g_free (body);
         server->priv->state = TP_TUBE_STATE_OPEN;
         break;
@@ -311,8 +336,13 @@
         /* Translators: '%s' is the name of a contact, buddy coming from Empathy */
         body =  g_strdup_printf (_("Waiting for '%s' to connect to the screen."),
 				 vino_tube_server_get_alias (server));
+#ifdef VINO_ENABLE_APP_INDICATOR
+        vino_tube_app_indicator_show_notif (server->priv->indicator, summary,
+            (const gchar*) body, FALSE);
+#else
         vino_status_tube_icon_show_notif (server->priv->icon_tube, summary,
             (const gchar*) body, FALSE);
+#endif /* VINO_ENABLE_APP_INDICATOR */
         g_free (body);
         server->priv->state = TP_TUBE_STATE_REMOTE_PENDING;
         break;
@@ -408,6 +438,7 @@
       server->priv->filename = vino_tube_server_contact_get_avatar_filename
           (contact, token, self);
     }
+
 }
 
 gboolean
@@ -425,11 +456,17 @@
   parameters = g_hash_table_new (g_str_hash, g_str_equal);
 
   screen = gdk_screen_get_default ();
+#ifdef VINO_ENABLE_APP_INDICATOR
+  server->priv->indicator = vino_tube_app_indicator_new (VINO_TUBE_SERVER (server));
+  vino_tube_app_indicator_set_visibility (server->priv->indicator,
+      VINO_TUBE_ICON_VISIBILITY_ALWAYS);
+#else
   server->priv->icon_tube = vino_status_tube_icon_new (server,
       screen);
 
   vino_status_tube_icon_set_visibility (server->priv->icon_tube,
-      VINO_STATUS_TUBE_ICON_VISIBILITY_ALWAYS);
+      VINO_TUBE_ICON_VISIBILITY_ALWAYS);
+#endif /* VINO_ENABLE_APP_INDICATOR */
 
   tp_cli_channel_interface_tube_connect_to_tube_channel_state_changed
       (server->priv->tp_channel, vino_tube_server_state_changed, server,

=== modified file 'server/vino-tube-server.h'
--- old/server/vino-tube-server.h	2010-09-09 21:16:40 +0000
+++ new/server/vino-tube-server.h	2010-09-09 21:17:56 +0000
@@ -27,7 +27,12 @@
 
 #include "vino-types.h"
 #include "vino-server.h"
+
+#ifdef VINO_ENABLE_APP_INDICATOR
+#include "vino-tube-app-indicator.h"
+#else
 #include "vino-status-tube-icon.h"
+#endif
 
 G_BEGIN_DECLS
 

=== modified file 'server/vino-tube-servers-manager.c'
--- old/server/vino-tube-servers-manager.c	2010-09-09 21:16:40 +0000
+++ new/server/vino-tube-servers-manager.c	2010-09-13 21:32:18 +0000
@@ -30,6 +30,7 @@
 #include "vino-server.h"
 #include "vino-tube-server.h"
 #include "vino-dbus-error.h"
+#include "vino-tube-app-indicator.h"
 #include "vino-status-tube-icon.h"
 #include "vino-util.h"
 
@@ -194,6 +195,27 @@
   display = gdk_display_get_default ();
   screen = gdk_display_get_default_screen (display);
 
+  #ifdef VINO_ENABLE_APP_INDICATOR
+  server = g_object_new (VINO_TYPE_TUBE_SERVER,
+      "display-app-indicator",  0,
+      "use-dbus-listener",    0,
+      "prompt-enabled",       0,
+      "view-only",            0,
+      "network-interface",    network_interface,
+      "use-alternative-port", 1,
+      "alternative-port",     self->priv->alternative_port,
+      "auth-methods",         1,
+      "require-encryption",   0,
+      "vnc-password",         NULL,
+      "on-hold",              0,
+      "screen",               screen,
+      "lock-screen",          0,
+      "disable-background",   0,
+      "use-upnp",             0,
+      "connection",           connection,
+      "tube",                 channel,
+      NULL);
+  #else
   server = g_object_new (VINO_TYPE_TUBE_SERVER,
       "display-status-icon",  0,
       "use-dbus-listener",    0,
@@ -213,6 +235,7 @@
       "connection",           connection,
       "tube",                 channel,
       NULL);
+  #endif /* VINO_ENABLE_APP_INDICATOR */
 
   self->priv->vino_tube_servers = g_slist_prepend
       (self->priv->vino_tube_servers, server);

