From: Alberto Mardegan <alberto.mardegan@canonical.com>
Author: Samuel Rodal <samuel.rodal@nokia.com>
Description: Fixed broken window surface flush when depth is 24 and bpp is not 32
 Some X servers use a compact representation of 24 depth visuals. In that
 case we can't use the shared memory or XPutImage paths, as Qt's RGB32
 does not match the internal memory layout.
 .
 Also fixed QPixmap::fromImage() to work in this case to prevent the red
 and blue channels from being swapped.
Origin: upstream; will be included in Qt 4.8
Bug: https://bugreports.qt.nokia.com/browse/QTBUG-21754
Bug-Ubuntu: https://bugs.launchpad.net/bugs/804784
Bug-Ubuntu: https://bugs.launchpad.net/bugs/805587
Index: qt4-x11-4.7.4/src/gui/image/qnativeimage.cpp
===================================================================
--- qt4-x11-4.7.4.orig/src/gui/image/qnativeimage.cpp	2011-08-23 14:02:27.000000000 +0200
+++ qt4-x11-4.7.4/src/gui/image/qnativeimage.cpp	2011-09-29 13:26:52.894076837 +0200
@@ -150,7 +150,12 @@
 QNativeImage::QNativeImage(int width, int height, QImage::Format format,bool /* isTextBuffer */, QWidget *widget)
     : xshmimg(0), xshmpm(0)
 {
-    if (!X11->use_mitshm) {
+    QX11Info info = widget->x11Info();
+    
+    int dd = info.depth();
+    Visual *vis = (Visual*) info.visual();
+   
+    if (!X11->use_mitshm || format != QImage::Format_RGB16 && X11->bppForDepth.value(dd) != 32) {
         image = QImage(width, height, format);
         // follow good coding practice and set xshminfo attributes, though values not used in this case
         xshminfo.readOnly = true;
@@ -160,11 +165,6 @@
         return;
     }
 
-    QX11Info info = widget->x11Info();
-
-    int dd = info.depth();
-    Visual *vis = (Visual*) info.visual();
-
     xshmimg = XShmCreateImage(X11->display, vis, dd, ZPixmap, 0, &xshminfo, width, height);
     if (!xshmimg) {
         qWarning("QNativeImage: Unable to create shared XImage.");
Index: qt4-x11-4.7.4/src/gui/image/qpixmap_x11.cpp
===================================================================
--- qt4-x11-4.7.4.orig/src/gui/image/qpixmap_x11.cpp	2011-08-23 14:02:27.000000000 +0200
+++ qt4-x11-4.7.4/src/gui/image/qpixmap_x11.cpp	2011-09-29 13:19:31.667888914 +0200
@@ -897,12 +897,20 @@
                     }
                     )
                     break;
-            case BPP24_888:                        // 24 bit MSB
+            case BPP24_888:
                 CYCLE(
-                    for (int x=0; x<w; x++) {
-                        *dst++ = qRed  (*p);
-                        *dst++ = qGreen(*p);
-                        *dst++ = qBlue (*p++);
+                    if (QSysInfo::ByteOrder == QSysInfo::BigEndian) {
+                        for (int x=0; x<w; x++) {
+                            *dst++ = qRed  (*p);
+                            *dst++ = qGreen(*p);
+                            *dst++ = qBlue (*p++);
+                        }
+                    } else {
+                        for (int x=0; x<w; x++) {
+                            *dst++ = qBlue (*p);
+                            *dst++ = qGreen(*p);
+                            *dst++ = qRed  (*p++);
+                        }
                     }
                     )
                     break;
Index: qt4-x11-4.7.4/src/gui/kernel/qapplication_x11.cpp
===================================================================
--- qt4-x11-4.7.4.orig/src/gui/kernel/qapplication_x11.cpp	2011-09-29 13:15:50.000000000 +0200
+++ qt4-x11-4.7.4/src/gui/kernel/qapplication_x11.cpp	2011-09-29 13:19:31.671888935 +0200
@@ -1919,6 +1919,12 @@
         X11->defaultScreen = DefaultScreen(X11->display);
         X11->screenCount = ScreenCount(X11->display);
 
+        int formatCount = 0;
+        XPixmapFormatValues *values = XListPixmapFormats(X11->display, &formatCount);
+        for (int i = 0; i < formatCount; ++i)
+            X11->bppForDepth[values[i].depth] = values[i].bits_per_pixel;
+        XFree(values);
+
         X11->screens = new QX11InfoData[X11->screenCount];
         X11->argbVisuals = new Visual *[X11->screenCount];
         X11->argbColormaps = new Colormap[X11->screenCount];
Index: qt4-x11-4.7.4/src/gui/kernel/qt_x11_p.h
===================================================================
--- qt4-x11-4.7.4.orig/src/gui/kernel/qt_x11_p.h	2011-09-29 13:15:50.000000000 +0200
+++ qt4-x11-4.7.4/src/gui/kernel/qt_x11_p.h	2011-09-29 13:19:31.675888960 +0200
@@ -54,6 +54,7 @@
 //
 
 #include "QtGui/qwindowdefs.h"
+#include "QtCore/qhash.h"
 #include "QtCore/qlist.h"
 #include "QtCore/qvariant.h"
 
@@ -474,6 +475,7 @@
     Colormap *argbColormaps;
     int screenCount;
     int defaultScreen;
+    QHash<int, int> bppForDepth;
 
     Time time;
     Time userTime;
Index: qt4-x11-4.7.4/src/gui/painting/qwindowsurface_raster.cpp
===================================================================
--- qt4-x11-4.7.4.orig/src/gui/painting/qwindowsurface_raster.cpp	2011-09-29 13:15:42.000000000 +0200
+++ qt4-x11-4.7.4/src/gui/painting/qwindowsurface_raster.cpp	2011-09-29 13:19:31.675888960 +0200
@@ -245,9 +245,10 @@
     } else
 #endif
     {
+        int depth = widget->x11Info().depth();
         const QImage &src = d->image->image;
         br = br.intersected(src.rect());
-        if (src.format() != QImage::Format_RGB32 || widget->x11Info().depth() < 24) {
+        if (src.format() != QImage::Format_RGB32 || depth < 24 || X11->bppForDepth.value(depth) != 32) {
             Q_ASSERT(src.depth() >= 16);
             const QImage sub_src(src.scanLine(br.y()) + br.x() * (uint(src.depth()) / 8),
                                  br.width(), br.height(), src.bytesPerLine(), src.format());
@@ -259,7 +260,7 @@
         } else {
             // qpaintengine_x11.cpp
             extern void qt_x11_drawImage(const QRect &rect, const QPoint &pos, const QImage &image, Drawable hd, GC gc, Display *dpy, Visual *visual, int depth);
-            qt_x11_drawImage(br, wbr.topLeft(), src, widget->handle(), d_ptr->gc, X11->display, (Visual *)widget->x11Info().visual(), widget->x11Info().depth());
+            qt_x11_drawImage(br, wbr.topLeft(), src, widget->handle(), d_ptr->gc, X11->display, (Visual *)widget->x11Info().visual(), depth);
         }
     }
 
