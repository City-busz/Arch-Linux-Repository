Index: qt4-x11-4.7.4/examples/declarative/ui-components/slideswitch/content/Switch.qml
===================================================================
--- qt4-x11-4.7.4.orig/examples/declarative/ui-components/slideswitch/content/Switch.qml	2011-08-23 14:02:26.000000000 +0200
+++ qt4-x11-4.7.4/examples/declarative/ui-components/slideswitch/content/Switch.qml	2011-09-02 13:16:17.418865549 +0200
@@ -44,6 +44,7 @@
 Item {
     id: toggleswitch
     width: background.width; height: background.height
+    property string accessibleRole : "CheckBox"
 
 //![1]
     property bool on: false
Index: qt4-x11-4.7.4/src/declarative/accessible/accessible.pri
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ qt4-x11-4.7.4/src/declarative/accessible/accessible.pri	2011-09-02 13:16:17.422865561 +0200
@@ -0,0 +1,2 @@
+SOURCES += $$PWD/qdeclarativeaccessible.cpp
+HEADERS += $$PWD/qdeclarativeaccessible_p.h
Index: qt4-x11-4.7.4/src/declarative/accessible/qdeclarativeaccessible.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ qt4-x11-4.7.4/src/declarative/accessible/qdeclarativeaccessible.cpp	2011-09-02 13:16:17.422865561 +0200
@@ -0,0 +1,80 @@
+/****************************************************************************
+**
+** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the QtDeclarative module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** No Commercial Usage
+** This file contains pre-release code and may not be distributed.
+** You may use this file in accordance with the terms and conditions
+** contained in the Technology Preview License Agreement accompanying
+** this package.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights.  These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** If you have questions regarding the use of this file, please contact
+** Nokia at qt-info@nokia.com.
+**
+**
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qdeclarativeaccessible_p.h"
+
+#include <qdeclarativeexpression.h>
+#include <qdeclarativecontext.h>
+#include <qdeclarativeinfo.h>
+
+#include <private/qdeclarativeproperty_p.h>
+#include <private/qdeclarativeitem_p.h>
+
+#include <QtCore/qdebug.h>
+#include <QtCore/qstringlist.h>
+
+#include <QtGui/qevent.h>
+
+#include <private/qobject_p.h>
+
+#ifndef QT_NO_ACCESSIBILITY
+
+QT_BEGIN_NAMESPACE
+
+
+QDeclarativeAccessibleAttached::QDeclarativeAccessibleAttached(QObject *parent=0)
+    : QObject(parent)
+{
+    Q_ASSERT(parent);
+}
+
+QDeclarativeAccessibleAttached::~QDeclarativeAccessibleAttached()
+{
+}
+
+QDeclarativeAccessibleAttached *QDeclarativeAccessibleAttached::qmlAttachedProperties(QObject *obj)
+{
+    return new QDeclarativeAccessibleAttached(obj);
+}
+
+QT_END_NAMESPACE
+
+#endif // QT_NO_GESTURES
Index: qt4-x11-4.7.4/src/declarative/accessible/qdeclarativeaccessible_p.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ qt4-x11-4.7.4/src/declarative/accessible/qdeclarativeaccessible_p.h	2011-09-02 13:16:17.426865582 +0200
@@ -0,0 +1,298 @@
+/****************************************************************************
+**
+** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the QtDeclarative module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** No Commercial Usage
+** This file contains pre-release code and may not be distributed.
+** You may use this file in accordance with the terms and conditions
+** contained in the Technology Preview License Agreement accompanying
+** this package.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights.  These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** If you have questions regarding the use of this file, please contact
+** Nokia at qt-info@nokia.com.
+**
+**
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QDECLARATIVEACCESSIBLE_H
+#define QDECLARATIVEACCESSIBLE_H
+
+#include <qdeclarativeitem.h>
+
+#include <QtCore/qobject.h>
+#include <QtCore/qstring.h>
+
+#ifndef QT_NO_ACCESSIBILITY
+
+#include <private/qdeclarativeglobal_p.h>
+#include <qaccessible.h>
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Declarative)
+
+class Q_DECLARATIVE_PRIVATE_EXPORT QDeclarativeAccessibleAttached : public QObject
+{
+    Q_OBJECT
+    Q_PROPERTY(Role role READ role WRITE setRole NOTIFY roleChanged)
+    Q_PROPERTY(QString name READ name WRITE setName NOTIFY nameChanged)
+    Q_PROPERTY(QString description READ description WRITE setDescription NOTIFY descriptionChanged)
+
+public:
+    Q_ENUMS(Role Event Action)
+
+    /* Stupid copy of enums from QAccessible */
+    enum Role {
+        NoRole         = 0x00000000,
+        TitleBar       = 0x00000001,
+        MenuBar        = 0x00000002,
+        ScrollBar      = 0x00000003,
+        Grip           = 0x00000004,
+        Sound          = 0x00000005,
+        Cursor         = 0x00000006,
+        Caret          = 0x00000007,
+        AlertMessage   = 0x00000008,
+        Window         = 0x00000009,
+        Client         = 0x0000000A,
+        PopupMenu      = 0x0000000B,
+        MenuItem       = 0x0000000C,
+        ToolTip        = 0x0000000D,
+        Application    = 0x0000000E,
+        Document       = 0x0000000F,
+        Pane           = 0x00000010,
+        Chart          = 0x00000011,
+        Dialog         = 0x00000012,
+        Border         = 0x00000013,
+        Grouping       = 0x00000014,
+        Separator      = 0x00000015,
+        ToolBar        = 0x00000016,
+        StatusBar      = 0x00000017,
+        Table          = 0x00000018,
+        ColumnHeader   = 0x00000019,
+        RowHeader      = 0x0000001A,
+        Column         = 0x0000001B,
+        Row            = 0x0000001C,
+        Cell           = 0x0000001D,
+        Link           = 0x0000001E,
+        HelpBalloon    = 0x0000001F,
+        Assistant      = 0x00000020,
+        List           = 0x00000021,
+        ListItem       = 0x00000022,
+        Tree           = 0x00000023,
+        TreeItem       = 0x00000024,
+        PageTab        = 0x00000025,
+        PropertyPage   = 0x00000026,
+        Indicator      = 0x00000027,
+        Graphic        = 0x00000028,
+        StaticText     = 0x00000029,
+        EditableText   = 0x0000002A,  // Editable, selectable, etc.
+        PushButton     = 0x0000002B,
+        Button         = PushButton,
+        CheckBox       = 0x0000002C,
+        RadioButton    = 0x0000002D,
+        ComboBox       = 0x0000002E,
+        // DropList       = 0x0000002F,
+        ProgressBar    = 0x00000030,
+        Dial           = 0x00000031,
+        HotkeyField    = 0x00000032,
+        Slider         = 0x00000033,
+        SpinBox        = 0x00000034,
+        Canvas         = 0x00000035,
+        Animation      = 0x00000036,
+        Equation       = 0x00000037,
+        ButtonDropDown = 0x00000038,
+        ButtonMenu     = 0x00000039,
+        ButtonDropGrid = 0x0000003A,
+        Whitespace     = 0x0000003B,
+        PageTabList    = 0x0000003C,
+        Clock          = 0x0000003D,
+        Splitter       = 0x0000003E,
+        // Additional Qt roles where enum value does not map directly to MSAA:
+        LayeredPane    = 0x0000003F,
+        UserRole       = 0x0000ffff
+    };
+
+    enum Event {
+        SoundPlayed          = 0x0001,
+        Alert                = 0x0002,
+        ForegroundChanged    = 0x0003,
+        MenuStart            = 0x0004,
+        MenuEnd              = 0x0005,
+        PopupMenuStart       = 0x0006,
+        PopupMenuEnd         = 0x0007,
+        ContextHelpStart     = 0x000C,
+        ContextHelpEnd       = 0x000D,
+        DragDropStart        = 0x000E,
+        DragDropEnd          = 0x000F,
+        DialogStart          = 0x0010,
+        DialogEnd            = 0x0011,
+        ScrollingStart       = 0x0012,
+        ScrollingEnd         = 0x0013,
+
+        MenuCommand          = 0x0018,
+
+        // Values from IAccessible2
+        ActionChanged        = 0x0101,
+        ActiveDescendantChanged,
+        AttributeChanged,
+        DocumentContentChanged,
+        DocumentLoadComplete,
+        DocumentLoadStopped,
+        DocumentReload,
+        HyperlinkEndIndexChanged,
+        HyperlinkNumberOfAnchorsChanged,
+        HyperlinkSelectedLinkChanged,
+        HypertextLinkActivated,
+        HypertextLinkSelected,
+        HyperlinkStartIndexChanged,
+        HypertextChanged,
+        HypertextNLinksChanged,
+        ObjectAttributeChanged,
+        PageChanged,
+        SectionChanged,
+        TableCaptionChanged,
+        TableColumnDescriptionChanged,
+        TableColumnHeaderChanged,
+        TableModelChanged,
+        TableRowDescriptionChanged,
+        TableRowHeaderChanged,
+        TableSummaryChanged,
+        TextAttributeChanged,
+        TextCaretMoved,
+        // TextChanged, deprecated, use TextUpdated
+        TextColumnChanged = TextCaretMoved + 2,
+        TextInserted,
+        TextRemoved,
+        TextUpdated,
+        TextSelectionChanged,
+        VisibleDataChanged,
+
+        ObjectCreated        = 0x8000,
+        ObjectDestroyed      = 0x8001,
+        ObjectShow           = 0x8002,
+        ObjectHide           = 0x8003,
+        ObjectReorder        = 0x8004,
+        Focus                = 0x8005,
+        Selection            = 0x8006,
+        SelectionAdd         = 0x8007,
+        SelectionRemove      = 0x8008,
+        SelectionWithin      = 0x8009,
+        StateChanged         = 0x800A,
+        LocationChanged      = 0x800B,
+        NameChanged          = 0x800C,
+        DescriptionChanged   = 0x800D,
+        ValueChanged         = 0x800E,
+        ParentChanged        = 0x800F,
+        HelpChanged          = 0x80A0,
+        DefaultActionChanged = 0x80B0,
+        AcceleratorChanged   = 0x80C0
+    };
+
+    enum Action {
+        DefaultAction       = 0,
+        Press               = -1,
+        FirstStandardAction = Press,
+        SetFocus            = -2,
+        Increase            = -3,
+        Decrease            = -4,
+        Accept              = -5,
+        Cancel              = -6,
+        Select              = -7,
+        ClearSelection      = -8,
+        RemoveSelection     = -9,
+        ExtendSelection     = -10,
+        AddToSelection      = -11,
+        LastStandardAction  = AddToSelection
+    };
+
+    QDeclarativeAccessibleAttached(QObject *parent);
+    ~QDeclarativeAccessibleAttached();
+
+    Role role() const { return (Role)m_role; }
+    void setRole(Role role) { m_role = (char)role; }
+
+    QString name() const { return m_name; }
+    void setName(const QString &name) { m_name = name; }
+
+    QString description() const { return m_description; }
+    void setDescription(const QString &description) { m_description = description; }
+
+    QDeclarativeItem *item() const {
+        return static_cast<QDeclarativeItem*>(parent());
+    }
+
+    // Factory function
+    static QDeclarativeAccessibleAttached *qmlAttachedProperties(QObject *);
+
+    // Property getter
+    static QObject *attachedProperties(const QObject *obj)
+    {
+        return qmlAttachedPropertiesObject<QDeclarativeAccessibleAttached>(obj, false);
+    }
+
+    static QVariant property(const QObject *object, const char *propertyName)
+    {
+        if (QObject *attachedObject = QDeclarativeAccessibleAttached::attachedProperties(object))
+            return attachedObject->property(propertyName);
+        return QVariant();
+    }
+
+    static bool setProperty(QObject *object, const char *propertyName, const QVariant &value)
+    {
+        QObject *obj = qmlAttachedPropertiesObject<QDeclarativeAccessibleAttached>(object, true);
+        if (!obj) {
+            qWarning("cannot set property Accessible.%s of QObject %s", propertyName, object->metaObject()->className());
+            return false;
+        }
+        return obj->setProperty(propertyName, value);
+    }
+
+
+Q_SIGNALS:
+    void roleChanged();
+    void nameChanged();
+    void descriptionChanged();
+private:
+    char m_role;
+    QString m_name;
+    QString m_description;
+};
+
+
+QT_END_NAMESPACE
+
+QML_DECLARE_TYPE(QDeclarativeAccessibleAttached)
+QML_DECLARE_TYPEINFO(QDeclarativeAccessibleAttached, QML_HAS_ATTACHED_PROPERTIES)
+
+QT_END_HEADER
+
+#endif // QT_NO_ACCESSIBILITY
+
+#endif
Index: qt4-x11-4.7.4/src/declarative/declarative.pro
===================================================================
--- qt4-x11-4.7.4.orig/src/declarative/declarative.pro	2011-08-23 14:02:27.000000000 +0200
+++ qt4-x11-4.7.4/src/declarative/declarative.pro	2011-09-02 13:16:17.426865582 +0200
@@ -23,6 +23,7 @@
 include(graphicsitems/graphicsitems.pri)
 include(qml/qml.pri)
 include(debugger/debugger.pri)
+include(accessible/accessible.pri)
 
 symbian: {
     TARGET.UID3=0x2001E623
Index: qt4-x11-4.7.4/src/declarative/graphicsitems/qdeclarativeitem.cpp
===================================================================
--- qt4-x11-4.7.4.orig/src/declarative/graphicsitems/qdeclarativeitem.cpp	2011-08-23 14:02:27.000000000 +0200
+++ qt4-x11-4.7.4/src/declarative/graphicsitems/qdeclarativeitem.cpp	2011-09-02 13:16:17.426865582 +0200
@@ -53,6 +53,8 @@
 #include <qdeclarativestategroup_p.h>
 #include <qdeclarativecomponent.h>
 #include <qdeclarativeinfo.h>
+// ### Due to the workaround mentioned in accessibleRole()
+#include <qdeclarativetext_p.h>
 
 #include <QDebug>
 #include <QPen>
@@ -62,6 +64,8 @@
 #include <QtScript/qscriptengine.h>
 #include <QtGui/qgraphicstransform.h>
 #include <qlistmodelinterface_p.h>
+#include <QAccessible>
+#include <private/qdeclarativeaccessible_p.h>
 
 #include <float.h>
 
@@ -1718,7 +1722,11 @@
 */
 void QDeclarativeItem::setParentItem(QDeclarativeItem *parent)
 {
+    Q_D(QDeclarativeItem);
     QGraphicsObject::setParentItem(parent);
+    if (d->isAccessible && parentItem()) {
+        parentItem()->d_func()->setAccessibleFlagAndListener();
+    }
 }
 
 /*!
@@ -2894,6 +2902,13 @@
         d->keyHandler->componentComplete();
     if (d->_contents)
         d->_contents->complete();
+
+    // Enable accessibility for items with accessible content. This also
+    // enables accessibility for the ancestors of souch items.
+    if (accessibleRole() != QAccessible::Pane) {
+        QAccessible::updateAccessibility(this, 0, QAccessible::ObjectCreated);
+        d->setAccessibleFlagAndListener();
+    }
 }
 
 QDeclarativeStateGroup *QDeclarativeItemPrivate::_states()
@@ -2928,6 +2943,19 @@
     baseline.anchorLine = QDeclarativeAnchorLine::Baseline;
 }
 
+void QDeclarativeItemPrivate::setAccessibleFlagAndListener()
+{
+    Q_Q(QDeclarativeItem);
+    QDeclarativeItem *item = q;
+    while (item) {
+        if (item->d_func()->isAccessible)
+            break; // already set - grandparents should have the flag set as well.
+
+        item->d_func()->isAccessible = true;
+        item = item->parentItem();
+    }
+}
+
 QPointF QDeclarativeItemPrivate::computeTransformOrigin() const
 {
     Q_Q(const QDeclarativeItem);
@@ -3134,6 +3162,29 @@
     update();
 }
 
+QAccessible::Role QDeclarativeItem::accessibleRole() const
+{
+    // ### Workaround for setAccessibleRole() not working.
+    // Text items are special since they are defined
+    // entirely from C++ (setting the role from QML works.)
+    // See http://bugreports.qt.nokia.com/browse/QTBUG-20077
+    if (qobject_cast<QDeclarativeText*>(const_cast<QDeclarativeItem *>(this)))
+        return QAccessible::StaticText;
+
+    QVariant v = QDeclarativeAccessibleAttached::property(this, "role");
+    bool ok;
+    QAccessible::Role role = (QAccessible::Role)v.toInt(&ok);
+    if (!ok)    // Not sure if this check is needed.
+        role = QAccessible::Pane;
+    return role;
+}
+
+void QDeclarativeItem::setAccessibleRole(QAccessible::Role role)
+{
+    QDeclarativeAccessibleAttached::setProperty(this, "role", QVariant(int(role)));
+}
+
+
 /*!
   \property QDeclarativeItem::anchors
   \internal
Index: qt4-x11-4.7.4/src/declarative/graphicsitems/qdeclarativeitem.h
===================================================================
--- qt4-x11-4.7.4.orig/src/declarative/graphicsitems/qdeclarativeitem.h	2011-08-23 14:02:27.000000000 +0200
+++ qt4-x11-4.7.4/src/declarative/graphicsitems/qdeclarativeitem.h	2011-09-02 13:16:17.430865607 +0200
@@ -51,6 +51,7 @@
 #include <QtGui/qgraphicstransform.h>
 #include <QtGui/qfont.h>
 #include <QtGui/qaction.h>
+#include <QtGui/qaccessible.h>
 
 QT_BEGIN_HEADER
 
@@ -139,6 +140,9 @@
     bool smooth() const;
     void setSmooth(bool);
 
+    QAccessible::Role accessibleRole() const;
+    void setAccessibleRole(QAccessible::Role);
+
     QRectF boundingRect() const;
     virtual void paint(QPainter *, const QStyleOptionGraphicsItem *, QWidget *);
 
Index: qt4-x11-4.7.4/src/declarative/graphicsitems/qdeclarativeitem_p.h
===================================================================
--- qt4-x11-4.7.4.orig/src/declarative/graphicsitems/qdeclarativeitem_p.h	2011-08-23 14:02:27.000000000 +0200
+++ qt4-x11-4.7.4/src/declarative/graphicsitems/qdeclarativeitem_p.h	2011-09-02 13:17:56.443356579 +0200
@@ -70,6 +70,7 @@
 
 #include <QtCore/qlist.h>
 #include <QtCore/qdebug.h>
+#include <QtGui/qaccessible.h>
 
 #include <private/qgraphicsitem_p.h>
 
@@ -289,6 +290,7 @@
     bool isMirrorImplicit:1;
     bool inheritMirrorFromParent:1;
     bool inheritMirrorFromItem:1;
+    bool isAccessible:1;
 
     QDeclarativeItemKeyFilter *keyHandler;
 
@@ -300,6 +302,7 @@
     QDeclarativeLayoutMirroringAttached* attachedLayoutDirection;
 
     bool hadSubFocusItem;
+    void setAccessibleFlagAndListener();
 
     QPointF computeTransformOrigin() const;
 
@@ -610,6 +613,7 @@
     static const SigMap sigMap[];
 };
 
+
 Q_DECLARE_OPERATORS_FOR_FLAGS(QDeclarativeItemPrivate::ChangeTypes);
 
 QT_END_NAMESPACE
Index: qt4-x11-4.7.4/src/declarative/graphicsitems/qdeclarativeitemsmodule.cpp
===================================================================
--- qt4-x11-4.7.4.orig/src/declarative/graphicsitems/qdeclarativeitemsmodule.cpp	2011-08-23 14:02:27.000000000 +0200
+++ qt4-x11-4.7.4/src/declarative/graphicsitems/qdeclarativeitemsmodule.cpp	2011-09-02 13:16:17.430865607 +0200
@@ -45,6 +45,7 @@
 #include <QtGui/qvalidator.h>
 #include <QtGui/qgraphicseffect.h>
 
+#include "private/qdeclarativeaccessible_p.h"
 #include "private/qdeclarativeevents_p_p.h"
 #include "private/qdeclarativescalegrid_p_p.h"
 #include "private/qdeclarativeanimatedimage_p.h"
@@ -174,6 +175,10 @@
 
     qmlRegisterUncreatableType<QDeclarativeKeyNavigationAttached>("QtQuick",1,0,"KeyNavigation",QDeclarativeKeyNavigationAttached::tr("KeyNavigation is only available via attached properties"));
     qmlRegisterUncreatableType<QDeclarativeKeysAttached>("QtQuick",1,0,"Keys",QDeclarativeKeysAttached::tr("Keys is only available via attached properties"));
+#ifndef QT_NO_ACCESSIBILITY
+    qmlRegisterUncreatableType<QDeclarativeAccessibleAttached>("QtQuick",1,0,"Accessible",QDeclarativeAccessibleAttached::tr("Accessible is only available via attached properties"));
+    qmlRegisterUncreatableType<QDeclarativeAccessibleAttached>("QtQuick",1,1,"Accessible",QDeclarativeAccessibleAttached::tr("Accessible is only available via attached properties"));
+#endif
 
     // QtQuick 1.1 items
     qmlRegisterType<QDeclarativePinchArea>("QtQuick",1,1,"PinchArea");
Index: qt4-x11-4.7.4/src/declarative/graphicsitems/qdeclarativetext.cpp
===================================================================
--- qt4-x11-4.7.4.orig/src/declarative/graphicsitems/qdeclarativetext.cpp	2011-08-23 14:02:27.000000000 +0200
+++ qt4-x11-4.7.4/src/declarative/graphicsitems/qdeclarativetext.cpp	2011-09-02 13:16:17.430865607 +0200
@@ -736,6 +736,8 @@
 
 QDeclarativeText::~QDeclarativeText()
 {
+    // Enable this when QTBUG-20077 is fixed.
+    //setAccessibleRole(QAccessible::StaticText);
 }
 
 /*!
Index: qt4-x11-4.7.4/src/declarative/graphicsitems/qdeclarativetextinput.cpp
===================================================================
--- qt4-x11-4.7.4.orig/src/declarative/graphicsitems/qdeclarativetextinput.cpp	2011-08-23 14:02:27.000000000 +0200
+++ qt4-x11-4.7.4/src/declarative/graphicsitems/qdeclarativetextinput.cpp	2011-09-02 13:16:17.434865621 +0200
@@ -1850,6 +1850,7 @@
 void QDeclarativeTextInputPrivate::init()
 {
     Q_Q(QDeclarativeTextInput);
+    control->setParent(q);
     control->setCursorWidth(1);
     control->setPasswordCharacter(QLatin1Char('*'));
     q->setSmooth(smooth);
Index: qt4-x11-4.7.4/src/declarative/graphicsitems/qdeclarativetextinput_p_p.h
===================================================================
--- qt4-x11-4.7.4.orig/src/declarative/graphicsitems/qdeclarativetextinput_p_p.h	2011-08-23 14:02:27.000000000 +0200
+++ qt4-x11-4.7.4/src/declarative/graphicsitems/qdeclarativetextinput_p_p.h	2011-09-02 13:16:17.434865621 +0200
@@ -70,7 +70,7 @@
 {
     Q_DECLARE_PUBLIC(QDeclarativeTextInput)
 public:
-    QDeclarativeTextInputPrivate() : control(new QLineControl(QString())),
+    QDeclarativeTextInputPrivate() : control(new QLineControl),
                  color((QRgb)0), style(QDeclarativeText::Normal),
                  styleColor((QRgb)0), hAlign(QDeclarativeTextInput::AlignLeft),
                  mouseSelectionMode(QDeclarativeTextInput::SelectCharacters), inputMethodHints(Qt::ImhNone),
@@ -84,12 +84,10 @@
             showInputPanelOnFocus = false;
         }
 #endif
-
     }
 
     ~QDeclarativeTextInputPrivate()
     {
-        delete control;
     }
 
     int xToPos(int x, QTextLine::CursorPosition betweenOrOn = QTextLine::CursorBetweenCharacters) const
Index: qt4-x11-4.7.4/src/declarative/util/qdeclarativebehavior.cpp
===================================================================
--- qt4-x11-4.7.4.orig/src/declarative/util/qdeclarativebehavior.cpp	2011-08-23 14:02:27.000000000 +0200
+++ qt4-x11-4.7.4/src/declarative/util/qdeclarativebehavior.cpp	2011-09-02 13:16:17.434865621 +0200
@@ -143,6 +143,7 @@
 void QDeclarativeBehavior::qtAnimationStateChanged(QAbstractAnimation::State newState,QAbstractAnimation::State)
 {
     Q_D(QDeclarativeBehavior);
+
     if (!d->blockRunningChanged)
         d->animation->notifyRunningChanged(newState == QAbstractAnimation::Running);
 }
Index: qt4-x11-4.7.4/src/declarative/util/qdeclarativetransitionmanager.cpp
===================================================================
--- qt4-x11-4.7.4.orig/src/declarative/util/qdeclarativetransitionmanager.cpp	2011-08-23 14:02:27.000000000 +0200
+++ qt4-x11-4.7.4/src/declarative/util/qdeclarativetransitionmanager.cpp	2011-09-02 13:16:17.434865621 +0200
@@ -43,6 +43,7 @@
 
 #include "private/qdeclarativestate_p_p.h"
 #include "private/qdeclarativestate_p.h"
+#include "private/qdeclarativeengine_p.h"
 
 #include <qdeclarativebinding_p.h>
 #include <qdeclarativeglobal_p.h>
@@ -64,6 +65,7 @@
     QDeclarativeTransition *transition;
     QDeclarativeStateOperation::ActionList bindingsList;
     SimpleActionList completeList;
+    QSet<QObject *>accessibilityTargets;
 };
 
 QDeclarativeTransitionManager::QDeclarativeTransitionManager()
@@ -121,6 +123,9 @@
     QDeclarativeStateOperation::ActionList applyList = list;
     // Determine which actions are binding changes.
     foreach(const QDeclarativeAction &action, applyList) {
+        if (action.property.object())
+            d->accessibilityTargets.insert(action.property.object());
+
         if (action.toBinding)
             d->bindingsList << action;
         if (action.fromBinding)
Index: qt4-x11-4.7.4/src/declarative/util/qdeclarativeview.cpp
===================================================================
--- qt4-x11-4.7.4.orig/src/declarative/util/qdeclarativeview.cpp	2011-08-23 14:02:27.000000000 +0200
+++ qt4-x11-4.7.4/src/declarative/util/qdeclarativeview.cpp	2011-09-02 13:16:17.438865646 +0200
@@ -722,4 +722,10 @@
         qDebug() << "paintEvent:" << d->frameTimer.elapsed() << "time since last frame:" << time;
 }
 
+QDeclarativeItem * QDeclarativeView::accessibleRootItem() const
+{
+    Q_D(const QDeclarativeView);
+    return d->declarativeItemRoot;
+}
+
 QT_END_NAMESPACE
Index: qt4-x11-4.7.4/src/declarative/util/qdeclarativeview.h
===================================================================
--- qt4-x11-4.7.4.orig/src/declarative/util/qdeclarativeview.h	2011-08-23 14:02:27.000000000 +0200
+++ qt4-x11-4.7.4/src/declarative/util/qdeclarativeview.h	2011-09-02 13:16:17.438865646 +0200
@@ -58,6 +58,7 @@
 class QDeclarativeEngine;
 class QDeclarativeContext;
 class QDeclarativeError;
+class QDeclarativeItem;
 
 class QDeclarativeViewPrivate;
 class Q_DECLARATIVE_EXPORT QDeclarativeView : public QGraphicsView
@@ -109,6 +110,9 @@
 private:
     Q_DISABLE_COPY(QDeclarativeView)
     Q_DECLARE_PRIVATE(QDeclarativeView)
+// Accessibility support:
+    friend class QAccessibleDeclarativeView;
+    QDeclarativeItem *accessibleRootItem() const;
 };
 
 QT_END_NAMESPACE
Index: qt4-x11-4.7.4/src/gui/accessible/accessible.pri
===================================================================
--- qt4-x11-4.7.4.orig/src/gui/accessible/accessible.pri	2011-08-23 14:02:27.000000000 +0200
+++ qt4-x11-4.7.4/src/gui/accessible/accessible.pri	2011-09-02 13:16:17.438865646 +0200
@@ -15,6 +15,7 @@
       mac:!embedded {
         HEADERS += accessible/qaccessible_mac_p.h
         OBJECTIVE_SOURCES += accessible/qaccessible_mac.mm \
+                             accessible/qaccessibleuielement_mac.mm \
                              accessible/qaccessible_mac_cocoa.mm
       } else:win32 { 
         SOURCES += accessible/qaccessible_win.cpp
Index: qt4-x11-4.7.4/src/gui/accessible/qaccessible.cpp
===================================================================
--- qt4-x11-4.7.4.orig/src/gui/accessible/qaccessible.cpp	2011-08-23 14:02:27.000000000 +0200
+++ qt4-x11-4.7.4/src/gui/accessible/qaccessible.cpp	2011-09-02 13:16:17.438865646 +0200
@@ -363,14 +363,17 @@
     This enum specifies string information that an accessible object
     returns.
 
-    \value Name         The name of the object. This can be used both
-                        as an identifier or a short description by
-                        accessible clients.
-    \value Description  A short text describing the object.
-    \value Value        The value of the object.
-    \value Help         A longer text giving information about how to use the object.
-    \value Accelerator  The keyboard shortcut that executes the object's default action.
-    \value UserText     The first value to be used for user defined text.
+    \value Name             The name of the object. This can be used both
+                            as an identifier or a short description by
+                            accessible clients.
+    \value Description      A short text describing the object.
+    \value Value            The value of the object.
+    \value Help             A longer text giving information about how to use the object.
+    \value Accelerator      The keyboard shortcut that executes the object's default action.
+    \value DebugDescription A short text describing the accessible object type,
+                            for example the class name. The content of this text
+                            might change and is only suitable for debug output.
+    \value UserText         The first value to be used for user defined text.
 */
 
 /*!
@@ -794,14 +797,20 @@
     \a target. It is the caller's responsibility to delete *\a target
     after use.
 
-    If an object is found, \a target is set to point to the object, and
-    the index of the child of \a target is returned. The return value
-    is 0 if \a target itself is the requested object. \a target is set
-    to null if this object is the target object (i.e. the requested
-    object is a handled by this object).
+    The return value is 0 if \a target itself is the requested object.
 
-    If no object is found \a target is set to null, and the return
-    value is -1.
+    \list
+    \i If an object is found, \a target is set to point to the object, and 0
+    is returned.
+    \i If an object is found, but it is a child object that is handled by
+    this interface, \a target is set to 0 and the child index of the found
+    object is returned.
+    \i If the object found is itself, \a target will be refer to the same
+    object (however, the interface pointer might be different), and 0 is
+    returned.
+    \i If no object is found \a target is set to null, and the return value
+    is -1.
+    \endlist
 
     The \a entry parameter has two different meanings:
     \list
Index: qt4-x11-4.7.4/src/gui/accessible/qaccessible.h
===================================================================
--- qt4-x11-4.7.4.orig/src/gui/accessible/qaccessible.h	2011-08-23 14:02:27.000000000 +0200
+++ qt4-x11-4.7.4/src/gui/accessible/qaccessible.h	2011-09-02 13:16:17.438865646 +0200
@@ -83,6 +83,42 @@
 
         MenuCommand          = 0x0018,
 
+        // Values from IAccessible2
+        ActionChanged        = 0x0101,
+        ActiveDescendantChanged,
+        AttributeChanged,
+        DocumentContentChanged,
+        DocumentLoadComplete,
+        DocumentLoadStopped,
+        DocumentReload,
+        HyperlinkEndIndexChanged,
+        HyperlinkNumberOfAnchorsChanged,
+        HyperlinkSelectedLinkChanged,
+        HypertextLinkActivated,
+        HypertextLinkSelected,
+        HyperlinkStartIndexChanged,
+        HypertextChanged,
+        HypertextNLinksChanged,
+        ObjectAttributeChanged,
+        PageChanged,
+        SectionChanged,
+        TableCaptionChanged,
+        TableColumnDescriptionChanged,
+        TableColumnHeaderChanged,
+        TableModelChanged,
+        TableRowDescriptionChanged,
+        TableRowHeaderChanged,
+        TableSummaryChanged,
+        TextAttributeChanged,
+        TextCaretMoved,
+        // TextChanged, deprecated, use TextUpdated
+        TextColumnChanged = TextCaretMoved + 2,
+        TextInserted,
+        TextRemoved,
+        TextUpdated,
+        TextSelectionChanged,
+        VisibleDataChanged,
+
         ObjectCreated        = 0x8000,
         ObjectDestroyed      = 0x8001,
         ObjectShow           = 0x8002,
@@ -191,6 +227,7 @@
         StaticText     = 0x00000029,
         EditableText   = 0x0000002A,  // Editable, selectable, etc.
         PushButton     = 0x0000002B,
+        Button         = PushButton,
         CheckBox       = 0x0000002C,
         RadioButton    = 0x0000002D,
         ComboBox       = 0x0000002E,
@@ -221,6 +258,7 @@
         Value,
         Help,
         Accelerator,
+        DebugDescription,
         UserText     = 0x0000ffff
     };
 
Index: qt4-x11-4.7.4/src/gui/accessible/qaccessible2.cpp
===================================================================
--- qt4-x11-4.7.4.orig/src/gui/accessible/qaccessible2.cpp	2011-08-23 14:02:27.000000000 +0200
+++ qt4-x11-4.7.4/src/gui/accessible/qaccessible2.cpp	2011-09-02 13:16:17.442865660 +0200
@@ -132,6 +132,111 @@
     \link http://www.linux-foundation.org/en/Accessibility/IAccessible2 IAccessible2 Specification \endlink
 */
 
+
+#include <qtextboundaryfinder.h>
+
+QString QAccessibleTextInterface::textBeforeOffsetFromString(int offset, QAccessible2::BoundaryType boundaryType,
+        int *startOffset, int *endOffset, const QString& text)
+{
+    QTextBoundaryFinder::BoundaryType type;
+    switch (boundaryType) {
+    case QAccessible2::CharBoundary:
+        type = QTextBoundaryFinder::Grapheme;
+        break;
+    case QAccessible2::WordBoundary:
+        type = QTextBoundaryFinder::Word;
+        break;
+    case QAccessible2::SentenceBoundary:
+        type = QTextBoundaryFinder::Sentence;
+        break;
+    default:
+        // in any other case return the whole line
+        *startOffset = 0;
+        *endOffset = text.length();
+        return text;
+    }
+
+    QTextBoundaryFinder boundary(type, text);
+    boundary.setPosition(offset);
+
+    if (!boundary.isAtBoundary()) {
+        boundary.toPreviousBoundary();
+    }
+    boundary.toPreviousBoundary();
+    *startOffset = boundary.position();
+    boundary.toNextBoundary();
+    *endOffset = boundary.position();
+
+    return text.mid(*startOffset, *endOffset - *startOffset);
+}
+
+QString QAccessibleTextInterface::textAfterOffsetFromString(int offset, QAccessible2::BoundaryType boundaryType,
+        int *startOffset, int *endOffset, const QString& text)
+{
+    QTextBoundaryFinder::BoundaryType type;
+    switch (boundaryType) {
+    case QAccessible2::CharBoundary:
+        type = QTextBoundaryFinder::Grapheme;
+        break;
+    case QAccessible2::WordBoundary:
+        type = QTextBoundaryFinder::Word;
+        break;
+    case QAccessible2::SentenceBoundary:
+        type = QTextBoundaryFinder::Sentence;
+        break;
+    default:
+        // in any other case return the whole line
+        *startOffset = 0;
+        *endOffset = text.length();
+        return text;
+    }
+
+    QTextBoundaryFinder boundary(type, text);
+    boundary.setPosition(offset);
+
+    boundary.toNextBoundary();
+    *startOffset = boundary.position();
+    boundary.toNextBoundary();
+    *endOffset = boundary.position();
+
+    return text.mid(*startOffset, *endOffset - *startOffset);
+}
+
+QString QAccessibleTextInterface::textAtOffsetFromString(int offset, QAccessible2::BoundaryType boundaryType,
+        int *startOffset, int *endOffset, const QString& text)
+{
+    QTextBoundaryFinder::BoundaryType type;
+    switch (boundaryType) {
+    case QAccessible2::CharBoundary:
+        type = QTextBoundaryFinder::Grapheme;
+        break;
+    case QAccessible2::WordBoundary:
+        type = QTextBoundaryFinder::Word;
+        break;
+    case QAccessible2::SentenceBoundary:
+        type = QTextBoundaryFinder::Sentence;
+        break;
+    default:
+        // in any other case return the whole line
+        *startOffset = 0;
+        *endOffset = text.length();
+        return text;
+    }
+
+    QTextBoundaryFinder boundary(type, text);
+    boundary.setPosition(offset);
+
+    if (!boundary.isAtBoundary()) {
+        boundary.toPreviousBoundary();
+    }
+    *startOffset = boundary.position();
+    boundary.toNextBoundary();
+    *endOffset = boundary.position();
+
+    return text.mid(*startOffset, *endOffset - *startOffset);
+}
+
+
 QAccessibleSimpleEditableTextInterface::QAccessibleSimpleEditableTextInterface(
                 QAccessibleInterface *accessibleInterface)
     : iface(accessibleInterface)
Index: qt4-x11-4.7.4/src/gui/accessible/qaccessible2.h
===================================================================
--- qt4-x11-4.7.4.orig/src/gui/accessible/qaccessible2.h	2011-08-23 14:02:27.000000000 +0200
+++ qt4-x11-4.7.4/src/gui/accessible/qaccessible2.h	2011-09-02 13:16:17.442865660 +0200
@@ -132,6 +132,14 @@
     virtual void setSelection(int selectionIndex, int startOffset, int endOffset) = 0;
     virtual int characterCount() = 0;
     virtual void scrollToSubstring(int startIndex, int endIndex) = 0;
+
+protected:
+    static QString textBeforeOffsetFromString(int offset, QAccessible2::BoundaryType boundaryType,
+            int *startOffset, int *endOffset, const QString& text);
+    static QString textAfterOffsetFromString(int offset, QAccessible2::BoundaryType boundaryType,
+            int *startOffset, int *endOffset, const QString& text);
+    static QString textAtOffsetFromString(int offset, QAccessible2::BoundaryType boundaryType,
+            int *startOffset, int *endOffset, const QString& text);
 };
 
 class Q_GUI_EXPORT QAccessibleEditableTextInterface: public QAccessible2Interface
Index: qt4-x11-4.7.4/src/gui/accessible/qaccessible_mac.mm
===================================================================
--- qt4-x11-4.7.4.orig/src/gui/accessible/qaccessible_mac.mm	2011-08-23 14:02:27.000000000 +0200
+++ qt4-x11-4.7.4/src/gui/accessible/qaccessible_mac.mm	2011-09-02 13:16:17.442865660 +0200
@@ -446,7 +446,7 @@
         return qHash(item.cachedObject()) + qHash(item.id());
 }
 
-QAInterface QAInterface::navigate(RelationFlag relation, int entry) const
+QAInterface QAInterface::navigate(QAccessible::RelationFlag relation, int entry) const
 {
         if (!checkValid())
             return QAInterface();
@@ -668,9 +668,10 @@
         return false;
 
     // Some roles are not interesting:
-    if (role == QAccessible::Border ||    // QFrame
+    if (role == QAccessible::Border ||      // QFrame
         role == QAccessible::Application || // We use the system-provided application element.
-        role == QAccessible::MenuItem)      // The system also provides the menu items.
+        role == QAccessible::MenuItem ||    // The system also provides the menu items.
+        role == QAccessible::Pane)          // Generic Container.
         return false;
 
     // It is probably better to access the toolbar buttons directly than having
Index: qt4-x11-4.7.4/src/gui/accessible/qaccessible_mac_cocoa.mm
===================================================================
--- qt4-x11-4.7.4.orig/src/gui/accessible/qaccessible_mac_cocoa.mm	2011-08-23 14:02:27.000000000 +0200
+++ qt4-x11-4.7.4/src/gui/accessible/qaccessible_mac_cocoa.mm	2011-09-02 13:16:17.446865683 +0200
@@ -42,6 +42,7 @@
 
 #include "qaccessible.h"
 #include "qaccessible_mac_p.h"
+#include "qaccessibleuielement_mac_p.h"
 #include "qdebug.h"
 #include "qtabwidget.h"
 
@@ -49,7 +50,6 @@
 #include <private/qcocoaview_mac_p.h>
 #include <private/qwidget_p.h>
 
-
 #ifndef QT_NO_ACCESSIBILITY
 
 #ifdef QT_MAC_USE_COCOA
@@ -71,9 +71,17 @@
 typedef QMap<QAccessible::Role, NSString *> QMacAccessibiltyRoleMap;
 Q_GLOBAL_STATIC(QMacAccessibiltyRoleMap, qMacAccessibiltyRoleMap);
 
-static QAInterface interfaceForView(QT_MANGLE_NAMESPACE(QCocoaView) *view)
+static QAccessibleInterface *interfaceForView(QT_MANGLE_NAMESPACE(QCocoaView) *view)
 {
-    return QAInterface(QAccessible::queryAccessibleInterface([view qt_qwidget]));
+    return QAccessible::queryAccessibleInterface([view qt_qwidget]);
+}
+
+static QAccessibleUIElement *createUIElementForView(QT_MANGLE_NAMESPACE(QCocoaView) *view)
+{
+    QAccessibleInterface * interface = QAccessible::queryAccessibleInterface([view qt_qwidget]);
+    id parent = [view superview];
+    QAccessibleUIElement *element = [QAccessibleUIElement elementWithAccessibleInterface:interface parent:parent];
+    return element;
 }
 
 /*
@@ -128,25 +136,40 @@
     Returns a Mac accessibility role for the given interface, or
     NSAccessibilityUnknownRole if no role mapping is found.
 */
-static NSString *macRoleForInterface(QAInterface interface)
+NSString *macRoleForInterface(QAInterface interface)
+{
+    return macRoleForInterface(interface.interfaceWrapper().interface);
+}
+
+NSString *macRoleForInterface(QAccessibleInterface *interface)
 {
-    const QAccessible::Role qtRole = interface.role();
+    if (!interface)
+        return NSAccessibilityUnknownRole;
+
+    const QAccessible::Role qtRole = interface->role(0);
     QMacAccessibiltyRoleMap &roleMap = *qMacAccessibiltyRoleMap();
 
+    // qDebug() << interface->object() << "qtRole" << qtRole;
+
     if (roleMap.isEmpty())
         populateRoleMap();
 
-    MAC_ACCESSIBILTY_DEBUG() << "role for" << interface.object() << "interface role" << hex << qtRole;
+    //MAC_ACCESSIBILTY_DEBUG() << "role for" << interface->object() << "interface role" << hex << qtRole;
 
     if (roleMap.contains(qtRole)) {
-        MAC_ACCESSIBILTY_DEBUG() << "return" <<  roleMap[qtRole];
+        //MAC_ACCESSIBILTY_DEBUG() << "return" <<  roleMap[qtRole];
         return roleMap[qtRole];
     }
 
+#ifdef MAC_ACCESSIBILTY_DEVELOPER_MODE
+    return NSAccessibilityGroupRole;
+#else
     MAC_ACCESSIBILTY_DEBUG() << "return NSAccessibilityUnknownRole";
     return NSAccessibilityUnknownRole;
+#endif
 }
 
+
 /*
     Is the interface a QTabBar embedded in a QTabWidget?
     (as opposed to a stand-alone tab bar)
@@ -199,36 +222,26 @@
 
 - (BOOL)accessibilityIsIgnored
 {
-    QT_PREPEND_NAMESPACE(QAInterface) interface = QT_PREPEND_NAMESPACE(interfaceForView)(self);
-    return isInterfaceIgnored(interface);
+   // MAC_ACCESSIBILTY_DEBUG() << "accessibilityIsIgnored" << self;
+
+    QAccessibleUIElement *acccessibleUIElement = QT_PREPEND_NAMESPACE(createUIElementForView)(self);
+    return [acccessibleUIElement accessibilityIsIgnored];
 }
 
 - (NSArray *)accessibilityAttributeNames
 {
-    QT_PREPEND_NAMESPACE(QAInterface) interface = QT_PREPEND_NAMESPACE(interfaceForView)(self);
-
-    static NSArray *attributes = nil;
-    if (attributes == nil) {
-        attributes = [super accessibilityAttributeNames];
-
-    }
-    return attributes;
+    //MAC_ACCESSIBILTY_DEBUG() << "accessibilityAttributeNames" << self;
+    QAccessibleUIElement *acccessibleUIElement = QT_PREPEND_NAMESPACE(createUIElementForView)(self);
+    return [acccessibleUIElement accessibilityAttributeNames];
 }
 
 - (id)accessibilityAttributeValue:(NSString *)attribute
 {
-    MAC_ACCESSIBILTY_DEBUG() << "accessibilityAttributeValue" << self <<  
-            QT_PREPEND_NAMESPACE(QCFString)::toQString(reinterpret_cast<CFStringRef>(attribute));
+    //MAC_ACCESSIBILTY_DEBUG() << "accessibilityAttributeValue" << self <<
+    //        QT_PREPEND_NAMESPACE(QCFString)::toQString(reinterpret_cast<CFStringRef>(attribute));
 
-    QT_PREPEND_NAMESPACE(QAInterface) interface = QT_PREPEND_NAMESPACE(interfaceForView)(self);
-
-    // Switch on the attribute name and call the appropriate handler function.
-    // Pass the call on to the NSView class for attributes we don't handle.
-    if ([attribute isEqualToString:@"AXRole"]) {
-        return macRoleForInterface(interface);
-    } else {
-        return [super accessibilityAttributeValue:attribute];    
-    }
+    QAccessibleUIElement *acccessibleUIElement = QT_PREPEND_NAMESPACE(createUIElementForView)(self);
+    return [acccessibleUIElement accessibilityAttributeValue : attribute];
 }
 
 @end
Index: qt4-x11-4.7.4/src/gui/accessible/qaccessible_mac_p.h
===================================================================
--- qt4-x11-4.7.4.orig/src/gui/accessible/qaccessible_mac_p.h	2011-08-23 14:02:27.000000000 +0200
+++ qt4-x11-4.7.4/src/gui/accessible/qaccessible_mac_p.h	2011-09-02 13:16:17.454865723 +0200
@@ -160,7 +160,7 @@
     bool operator==(const QAInterface &other) const;
     bool operator!=(const QAInterface &other) const;
 
-    inline QString actionText (int action, Text text) const
+    inline QString actionText (int action, QAccessible::Text text) const
     { return base.interface->actionText(action, text, child); }
 
     QAInterface childAt(int x, int y) const
@@ -230,7 +230,7 @@
         base.interface->doAction(action, child, params);
     }
 
-    QAInterface navigate(RelationFlag relation, int entry) const;
+    QAInterface navigate(QAccessible::RelationFlag relation, int entry) const;
 
     inline QObject * object() const
     {
@@ -283,28 +283,28 @@
         return base.interface->rect(child);
     }
 
-    inline Role role() const
+    inline QAccessible::Role role() const
     {
         if (!checkValid())
             return QAccessible::NoRole;
         return base.interface->role(child);
     }
 
-    inline void setText(Text t, const QString &text) const
+    inline void setText(QAccessible::Text t, const QString &text) const
     {
         if (!checkValid())
             return;
         base.interface->setText(t, child, text);
     }
 
-    inline State state() const
+    inline QAccessible::State state() const
     {
         if (!checkValid())
             return 0;
         return base.interface->state(child);
     }
 
-    inline QString text (Text text) const
+    inline QString text (QAccessible::Text text) const
     {
         if (!checkValid())
             return QString();
Index: qt4-x11-4.7.4/src/gui/accessible/qaccessible_win.cpp
===================================================================
--- qt4-x11-4.7.4.orig/src/gui/accessible/qaccessible_win.cpp	2011-08-23 14:02:27.000000000 +0200
+++ qt4-x11-4.7.4/src/gui/accessible/qaccessible_win.cpp	2011-09-02 13:16:17.454865723 +0200
@@ -47,6 +47,11 @@
 #include "qt_windows.h"
 #include "qwidget.h"
 #include "qsettings.h"
+#include <QtCore/qmap.h>
+#include <QtCore/qpair.h>
+#include <QtGui/qgraphicsitem.h>
+#include <QtGui/qgraphicsscene.h>
+#include <QtGui/qgraphicsview.h>
 
 #include <winuser.h>
 #if !defined(WINABLEAPI)
@@ -143,10 +148,110 @@
        "UserRole"       /* = 0x0000ffff*/
    };
 
-   if (role >=0x40)
-        role = QAccessible::UserRole;
-   return roles[int(role)];
-}
+   if (role > 0x40)
+       role = QAccessible::NoRole;
+   return roles[role];
+}
+
+static const char *eventString(QAccessible::Event ev)
+{
+    static const char *events[] = {
+        "null",                                 // 0
+        "SoundPlayed"          /*= 0x0001*/,
+        "Alert"                /*= 0x0002*/,
+        "ForegroundChanged"    /*= 0x0003*/,
+        "MenuStart"            /*= 0x0004*/,
+        "MenuEnd"              /*= 0x0005*/,
+        "PopupMenuStart"       /*= 0x0006*/,
+        "PopupMenuEnd"         /*= 0x0007*/,
+        "ContextHelpStart"     /*= 0x000C*/,    // 8
+        "ContextHelpEnd"       /*= 0x000D*/,
+        "DragDropStart"        /*= 0x000E*/,
+        "DragDropEnd"          /*= 0x000F*/,
+        "DialogStart"          /*= 0x0010*/,
+        "DialogEnd"            /*= 0x0011*/,
+        "ScrollingStart"       /*= 0x0012*/,
+        "ScrollingEnd"         /*= 0x0013*/,
+        "MenuCommand"          /*= 0x0018*/,    // 16
+
+        // Values from IAccessible2
+        "ActionChanged"        /*= 0x0101*/,    // 17
+        "ActiveDescendantChanged",
+        "AttributeChanged",
+        "DocumentContentChanged",
+        "DocumentLoadComplete",
+        "DocumentLoadStopped",
+        "DocumentReload",
+        "HyperlinkEndIndexChanged",
+        "HyperlinkNumberOfAnchorsChanged",
+        "HyperlinkSelectedLinkChanged",
+        "HypertextLinkActivated",
+        "HypertextLinkSelected",
+        "HyperlinkStartIndexChanged",
+        "HypertextChanged",
+        "HypertextNLinksChanged",
+        "ObjectAttributeChanged",
+        "PageChanged",
+        "SectionChanged",
+        "TableCaptionChanged",
+        "TableColumnDescriptionChanged",
+        "TableColumnHeaderChanged",
+        "TableModelChanged",
+        "TableRowDescriptionChanged",
+        "TableRowHeaderChanged",
+        "TableSummaryChanged",
+        "TextAttributeChanged",
+        "TextCaretMoved",
+        // TextChanged, deprecated, use TextUpdated
+        //TextColumnChanged = TextCaretMoved + 2,
+        "TextInserted",
+        "TextRemoved",
+        "TextUpdated",
+        "TextSelectionChanged",
+        "VisibleDataChanged",  /*= 0x0101+32*/
+        "ObjectCreated"        /*= 0x8000*/,    // 49
+        "ObjectDestroyed"      /*= 0x8001*/,
+        "ObjectShow"           /*= 0x8002*/,
+        "ObjectHide"           /*= 0x8003*/,
+        "ObjectReorder"        /*= 0x8004*/,
+        "Focus"                /*= 0x8005*/,
+        "Selection"            /*= 0x8006*/,
+        "SelectionAdd"         /*= 0x8007*/,
+        "SelectionRemove"      /*= 0x8008*/,
+        "SelectionWithin"      /*= 0x8009*/,
+        "StateChanged"         /*= 0x800A*/,
+        "LocationChanged"      /*= 0x800B*/,
+        "NameChanged"          /*= 0x800C*/,
+        "DescriptionChanged"   /*= 0x800D*/,
+        "ValueChanged"         /*= 0x800E*/,
+        "ParentChanged"        /*= 0x800F*/,
+        "HelpChanged"          /*= 0x80A0*/,
+        "DefaultActionChanged" /*= 0x80B0*/,
+        "AcceleratorChanged"   /*= 0x80C0*/
+    };
+    int e = int(ev);
+    if (e <= 0x80c0) {
+        const int last = sizeof(events)/sizeof(char*) - 1;
+
+        if (e <= 0x07)
+            return events[e];
+        else if (e <= 0x13)
+            return events[e - 0x0c + 8];
+        else if (e == 0x18)
+            return events[16];
+        else if (e <= 0x0101 + 32)
+            return events[e - 0x101 + 17];
+        else if (e <= 0x800f)
+            return events[e - 0x8000 + 49];
+        else if (e == 0x80a0)
+            return events[last - 2];
+        else if (e == 0x80b0)
+            return events[last - 1];
+        else if (e == 0x80c0)
+            return events[last];
+    }
+    return "unknown";
+};
 
 void showDebug(const char* funcName, const QAccessibleInterface *iface)
 {
@@ -159,6 +264,12 @@
 # define showDebug(f, iface)
 #endif
 
+// This stuff is used for widgets/items with no window handle:
+typedef QMap<int, QPair<QObject*,int> > NotifyMap;
+Q_GLOBAL_STATIC(NotifyMap, qAccessibleRecentSentEvents)
+static int eventNum = 0;
+
+
 void QAccessible::initialize()
 {
 
@@ -251,18 +362,35 @@
     // An event has to be associated with a window,
     // so find the first parent that is a widget.
     QWidget *w = 0;
-    if (o->isWidgetType()) {
-        w = (QWidget*)o;
-    } else {
-        QObject *p = o;
-        while ((p = p->parent()) != 0) {
-            if (p->isWidgetType()) {
-                w = (QWidget*)p;
+    QObject *p = o;
+    do {
+        if (p->isWidgetType()) {
+            w = static_cast<QWidget*>(p);
+            if (w->internalWinId())
                 break;
+        }
+        if (QGraphicsObject *gfxObj = qobject_cast<QGraphicsObject*>(p)) {
+            QGraphicsItem *parentItem = gfxObj->parentItem();
+            if (parentItem) {
+                p = parentItem->toGraphicsObject();
+            } else {
+                QGraphicsView *view = 0;
+                if (QGraphicsScene *scene = gfxObj->scene()) {
+                    QWidget *fw = QApplication::focusWidget();
+                    const QList<QGraphicsView*> views = scene->views();
+                    for (int i = 0 ; i < views.count() && view != fw; ++i) {
+                        view = views.at(i);
+                    }
+                }
+                p = view;
             }
+        } else {
+            p = p->parent();
         }
-    }
 
+    } while (p);
+
+    //qDebug() << "updateAccessibility(), hwnd:" << w << ", object:" << o << "," << eventString(reason);
     if (!w) {
         if (reason != QAccessible::ContextHelpStart &&
              reason != QAccessible::ContextHelpEnd)
@@ -282,12 +410,81 @@
         }
     }
 
+    WId wid = w->internalWinId();
     if (reason != MenuCommand) { // MenuCommand is faked
-        ptrNotifyWinEvent(reason, w->winId(), OBJID_CLIENT, who);
+        if (w != o) {
+            // See comment "SENDING EVENTS TO OBJECTS WITH NO WINDOW HANDLE"
+            eventNum %= 50;              //[0..49]
+            int eventId = - eventNum - 1;
+
+            qAccessibleRecentSentEvents()->insert(eventId, qMakePair(o,who));
+            ptrNotifyWinEvent(reason, wid, OBJID_CLIENT, eventId );
+
+            ++eventNum;
+        } else {
+            ptrNotifyWinEvent(reason, wid, OBJID_CLIENT, who);
+        }
     }
 #endif // Q_WS_WINCE
 }
 
+/*  == SENDING EVENTS TO OBJECTS WITH NO WINDOW HANDLE ==
+
+    If the user requested to send the event to a widget with no window,
+    we need to send an event to an object with no hwnd.
+    The way we do that is to send it to the *first* ancestor widget
+    with a window.
+    Then we'll need a way of identifying the child:
+    We'll just keep a list of the most recent events that we have sent,
+    where each entry in the list is identified by a negative value
+    between [-50,-1]. This negative value we will pass on to
+    NotifyWinEvent() as the child id. When the negative value have
+    reached -50, it will wrap around to -1. This seems to be enough
+
+    Now, when the client receives that event, he will first call
+    AccessibleObjectFromEvent() where dwChildID is the special
+    negative value. AccessibleObjectFromEvent does two steps:
+    1. It will first sent a WM_GETOBJECT to the server, asking
+       for the IAccessible interface for the HWND.
+    2. With the IAccessible interface it got hold of it will call
+       acc_getChild where the child id argument is the special
+       negative identifier. In our reimplementation of get_accChild
+       we check for this if the child id is negative. If it is, then
+       we'll look up in our table for the entry that is associated
+       with that value.
+       The entry will then contain a pointer to the QObject /QWidget
+       that we can use to call queryAccessibleInterface() on.
+
+
+    The following figure shows how the interaction between server and
+    client is in the case when the server is sending an event.
+
+SERVER (Qt)                                 | CLIENT                                |
+--------------------------------------------+---------------------------------------+
+                                            |
+acc->updateAccessibility(obj,  childIndex)  |
+                                            |
+recentEvents()->insert(- 1 - eventNum,      |
+            qMakePair(obj, childIndex)      |
+NotifyWinEvent(hwnd, childId) =>            |
+                                            |   AccessibleObjectFromEvent(event, hwnd, OBJID_CLIENT, childId )
+                                            |   will do:
+                                          <===  1. send WM_GETOBJECT(hwnd, OBJID_CLIENT)
+widget ~= hwnd
+iface = queryAccessibleInteface(widget)
+(create IAccessible interface wrapper for
+ iface)
+ return iface                              ===> IAccessible* iface; (for hwnd)
+                                            |
+                                          <===  call iface->get_accChild(childId)
+get_accChild() {                            |
+    if (varChildID.lVal < 0) {
+        QPair ref = recentEvents().value(varChildID.lVal);
+        [...]
+    }
+*/
+
+
 void QAccessible::setRootObject(QObject *o)
 {
     if (rootObjectHandler) {
@@ -418,15 +615,18 @@
         delete accessible;
     }
 
+    /* IUnknown */
     HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID *);
     ULONG STDMETHODCALLTYPE AddRef();
     ULONG STDMETHODCALLTYPE Release();
 
+    /* IDispatch */
     HRESULT STDMETHODCALLTYPE GetTypeInfoCount(unsigned int *);
     HRESULT STDMETHODCALLTYPE GetTypeInfo(unsigned int, unsigned long, ITypeInfo **);
     HRESULT STDMETHODCALLTYPE GetIDsOfNames(const _GUID &, wchar_t **, unsigned int, unsigned long, long *);
     HRESULT STDMETHODCALLTYPE Invoke(long, const _GUID &, unsigned long, unsigned short, tagDISPPARAMS *, tagVARIANT *, tagEXCEPINFO *, unsigned int *);
 
+    /* IAccessible */
     HRESULT STDMETHODCALLTYPE accHitTest(long xLeft, long yTop, VARIANT *pvarID);
     HRESULT STDMETHODCALLTYPE accLocation(long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varID);
     HRESULT STDMETHODCALLTYPE accNavigate(long navDir, VARIANT varStart, VARIANT *pvarEnd);
@@ -451,6 +651,7 @@
     HRESULT STDMETHODCALLTYPE get_accFocus(VARIANT *pvarID);
     HRESULT STDMETHODCALLTYPE get_accSelection(VARIANT *pvarChildren);
 
+    /* IOleWindow */
     HRESULT STDMETHODCALLTYPE GetWindow(HWND *phwnd);
     HRESULT STDMETHODCALLTYPE ContextSensitiveHelp(BOOL fEnterMode);
 
@@ -754,7 +955,9 @@
 }
 
 /*
-  IAccessible
+  Used for:
+  * Reading the contents below where the mouse cursor hovers?
+  * A11y development tools (Inspect, Accessibility Explorer, ...)
 */
 HRESULT STDMETHODCALLTYPE QWindowsAccessible::accHitTest(long xLeft, long yTop, VARIANT *pvarID)
 {
@@ -762,20 +965,32 @@
     if (!accessible->isValid())
         return E_FAIL;
 
-    int control = accessible->childAt(xLeft, yTop);
-    if (control == -1) {
-        (*pvarID).vt = VT_EMPTY;
-        return S_FALSE;
-    }
     QAccessibleInterface *acc = 0;
-    if (control)
-        accessible->navigate(Child, control, &acc);
+    if (QGraphicsView *gv = qobject_cast<QGraphicsView*>(accessible->object())) {
+        /* Optimize hit testing for QGraphicsView, since the default implementation
+         * of QAccessibleDeclarativeObject::childAt() might be very slow.
+         */
+        QPoint p(xLeft, yTop);
+        p = gv->mapFromGlobal(p);
+        QGraphicsItem *item = gv->itemAt(p);
+        QObject *obj = item ? item->toGraphicsObject() : 0;
+        if (obj)
+            acc = QAccessible::queryAccessibleInterface(obj);
+    }
     if (!acc) {
-        (*pvarID).vt = VT_I4;
-        (*pvarID).lVal = control;
-        return S_OK;
+        int control = accessible->childAt(xLeft, yTop);
+        if (control == -1) {
+            (*pvarID).vt = VT_EMPTY;
+            return S_FALSE;
+        }
+        if (control)
+            accessible->navigate(Child, control, &acc);
+        if (!acc) {
+            (*pvarID).vt = VT_I4;
+            (*pvarID).lVal = control;
+            return S_OK;
+        }
     }
-
     QWindowsAccessible* wacc = new QWindowsAccessible(acc);
     IDispatch *iface = 0;
     wacc->QueryInterface(IID_IDispatch, (void**)&iface);
@@ -896,9 +1111,30 @@
     if (varChildID.vt == VT_EMPTY)
         return E_INVALIDARG;
 
+
+    int childIndex = varChildID.lVal;
     QAccessibleInterface *acc = 0;
-    RelationFlag rel = varChildID.lVal ? Child : Self;
-    accessible->navigate(rel, varChildID.lVal, &acc);
+
+    if (childIndex < 0) {
+        const int entry = childIndex;
+        QPair<QObject*, int> ref = qAccessibleRecentSentEvents()->value(entry);
+        if (ref.first) {
+            acc = queryAccessibleInterface(ref.first);
+            if (acc && ref.second) {
+                if (ref.second) {
+                    QAccessibleInterface *res;
+                    int index = acc->navigate(Child, ref.second, &res);
+                    delete acc;
+                    if (index == -1)
+                        return E_INVALIDARG;
+                    acc = res;
+                }
+            }
+        }
+    } else {
+        RelationFlag rel = childIndex ? Child : Self;
+        accessible->navigate(rel, childIndex, &acc);
+    }
 
     if (acc) {
         QWindowsAccessible* wacc = new QWindowsAccessible(acc);
@@ -1203,7 +1439,7 @@
     if (!o || !o->isWidgetType())
         return E_FAIL;
 
-    *phwnd = static_cast<QWidget*>(o)->winId();
+    *phwnd = static_cast<QWidget*>(o)->effectiveWinId();
     return S_OK;
 }
 
Index: qt4-x11-4.7.4/src/gui/accessible/qaccessibleobject.cpp
===================================================================
--- qt4-x11-4.7.4.orig/src/gui/accessible/qaccessibleobject.cpp	2011-08-23 14:02:27.000000000 +0200
+++ qt4-x11-4.7.4/src/gui/accessible/qaccessibleobject.cpp	2011-09-02 13:16:17.454865723 +0200
@@ -322,9 +322,7 @@
 {
     switch (t) {
     case Name:
-        if (QApplication::activeWindow())
-            return QApplication::activeWindow()->windowTitle();
-        break;
+        return QApplication::applicationName();
     case Description:
         return QApplication::applicationFilePath();
     default:
Index: qt4-x11-4.7.4/src/gui/accessible/qaccessibleuielement_mac.mm
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ qt4-x11-4.7.4/src/gui/accessible/qaccessibleuielement_mac.mm	2011-09-02 13:16:17.454865723 +0200
@@ -0,0 +1,182 @@
+#import "qaccessibleuielement_mac_p.h"
+
+#import <AppKit/NSAccessibility.h>
+
+#include <qaccessible.h>
+#include <qdebug.h>
+
+NSString *macRoleForInterface(QAccessibleInterface *interface);
+
+@implementation QAccessibleUIElement
+
+#define MAC_ACCESSIBILTY_DEVELOPER_MODE
+
+- (id)initWithAccessibleInterface:(QAccessibleInterface *)aInterface parent:(id)aParent {
+    if ((self = [super init])) {
+        role = macRoleForInterface(aInterface);
+        interface = aInterface;
+        parent = [aParent retain];
+    }
+    return self;
+}
+
++ (QAccessibleUIElement *)elementWithAccessibleInterface:(QAccessibleInterface *)aInterface parent:(id)aParent {
+    return [[[self alloc] initWithAccessibleInterface:aInterface parent:aParent] autorelease];
+}
+
+- (void)dealloc {
+    delete interface;
+    [parent autorelease];
+    [super dealloc];
+}
+
+- (BOOL)isEqual:(id)object {
+    if ([object isKindOfClass:[QAccessibleUIElement self]]) {
+        QAccessibleUIElement *other = object;
+        return [role isEqualToString:other->role] && [parent isEqual:other->parent];
+    } else {
+        return NO;
+    }
+}
+
+- (NSUInteger)hash {
+    // Equal objects must hash the same.
+    return qHash(interface->object());
+}
+
+//
+// accessibility protocol
+//
+
+// attributes
+
+- (NSArray *)accessibilityAttributeNames {
+    static NSArray *attributes = nil;
+    if (attributes == nil) {
+	attributes = [[NSArray alloc] initWithObjects:
+	    NSAccessibilityRoleAttribute,
+	    NSAccessibilityRoleDescriptionAttribute,
+            NSAccessibilityChildrenAttribute,
+#ifdef MAC_ACCESSIBILTY_DEVELOPER_MODE
+            NSAccessibilityDescriptionAttribute,
+#endif
+	    NSAccessibilityFocusedAttribute,
+	    NSAccessibilityParentAttribute,
+	    NSAccessibilityWindowAttribute,
+	    NSAccessibilityTopLevelUIElementAttribute,
+	    NSAccessibilityPositionAttribute,
+	    NSAccessibilitySizeAttribute,
+	    nil];
+    }
+    return attributes;
+}
+
+- (id)accessibilityAttributeValue:(NSString *)attribute {
+    if ([attribute isEqualToString:NSAccessibilityRoleAttribute]) {
+	return role;
+    } else if ([attribute isEqualToString:NSAccessibilityRoleDescriptionAttribute]) {
+	return NSAccessibilityRoleDescription(role, nil);
+    } else if ([attribute isEqualToString:NSAccessibilityChildrenAttribute]) {
+//        NSMutableArray *kids = [NSMutableArray arrayWithCapacity: 0];
+//        return kids;
+
+        int childCount = interface->childCount();
+        //qDebug() << "widget" << interface->object() << childCount;
+        NSMutableArray *kids = [NSMutableArray arrayWithCapacity: 0];
+        for (int i = 0; i < childCount; ++i) {
+          //  qDebug() << "testing" <<  i;
+            QAccessibleInterface *child = 0;
+            int ret = interface->navigate(QAccessible::Child, i + 1, &child);
+            if (child && ret == 0) {
+                QAccessibleUIElement *uielement = [QAccessibleUIElement elementWithAccessibleInterface:child parent:self];
+//                qDebug() << "add kid"<< i << uielement;
+                [kids addObject: uielement];
+            } else {
+                delete child;
+            }
+        }
+        return kids;
+        //return NSAccessibilityUnignoredChildren(kids);
+
+#ifdef MAC_ACCESSIBILTY_DEVELOPER_MODE
+    } else if ([attribute isEqualToString: NSAccessibilityDescriptionAttribute]) {
+        QObject *object = interface->object();
+        if (object) {
+            const char *className = object->metaObject()->className();
+            return [NSString stringWithUTF8String : className];
+        } else {
+            return @"(no object)";
+        }
+#endif
+    } else if ([attribute isEqualToString:NSAccessibilityFocusedAttribute]) {
+        // Just check if the app thinks we're focused.
+        id focusedElement = [NSApp accessibilityAttributeValue:NSAccessibilityFocusedUIElementAttribute];
+        return [NSNumber numberWithBool:[focusedElement isEqual:self]];
+    } else if ([attribute isEqualToString:NSAccessibilityParentAttribute]) {
+        return NSAccessibilityUnignoredAncestor(parent);
+    } else if ([attribute isEqualToString:NSAccessibilityWindowAttribute]) {
+        // We're in the same window as our parent.
+        return [parent accessibilityAttributeValue:NSAccessibilityWindowAttribute];
+    } else if ([attribute isEqualToString:NSAccessibilityTopLevelUIElementAttribute]) {
+        // We're in the same top level element as our parent.
+        return [parent accessibilityAttributeValue:NSAccessibilityTopLevelUIElementAttribute];
+    } else if ([attribute isEqualToString:NSAccessibilityPositionAttribute]) {
+        QRect rect = interface->rect(0);
+        // qDebug() << "rect" << rect << rect.x()<< rect.y();
+        return [NSValue valueWithPoint: NSMakePoint(rect.x(), rect.y())];
+    } else if ([attribute isEqualToString:NSAccessibilitySizeAttribute]) {
+        QRect rect = interface->rect(0);
+        return [NSValue valueWithSize: NSMakeSize(rect.width(), rect.height())];
+    } else {
+        return nil;
+    }
+}
+
+- (BOOL)accessibilityIsAttributeSettable:(NSString *)attribute {
+    if ([attribute isEqualToString:NSAccessibilityFocusedAttribute]) {
+        // return [parent isFauxUIElementFocusable:self];
+        return YES;
+    } else {
+        return NO;
+    }
+}
+
+- (void)accessibilitySetValue:(id)value forAttribute:(NSString *)attribute {
+    if ([attribute isEqualToString:NSAccessibilityFocusedAttribute]) {
+        // [parent fauxUIElement:self setFocus:value];
+    }
+}
+
+
+// actions
+
+- (NSArray *)accessibilityActionNames {
+    return [NSArray array];
+}
+
+- (NSString *)accessibilityActionDescription:(NSString *)action {
+    Q_UNUSED(action);
+    return nil;
+}
+
+- (void)accessibilityPerformAction:(NSString *)action {
+    Q_UNUSED(action);
+}
+
+
+// misc
+
+- (BOOL)accessibilityIsIgnored {
+    return NO;
+}
+
+- (id)accessibilityHitTest:(NSPoint)point {
+    Q_UNUSED(point);
+    return NSAccessibilityUnignoredAncestor(self);
+}
+
+- (id)accessibilityFocusedUIElement {
+    return NSAccessibilityUnignoredAncestor(self);
+}
+
+@end
Index: qt4-x11-4.7.4/src/gui/accessible/qaccessibleuielement_mac_p.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ qt4-x11-4.7.4/src/gui/accessible/qaccessibleuielement_mac_p.h	2011-09-02 13:16:17.454865723 +0200
@@ -0,0 +1,27 @@
+#import <Cocoa/Cocoa.h>
+
+class QAccessibleInterface;
+@interface QAccessibleUIElement : NSObject {
+    QAccessibleInterface *interface;
+    NSString *role;
+    id parent;
+}
+
+- (id)initWithAccessibleInterface:(QAccessibleInterface *)aInterface parent:(id)aParent;
++ (QAccessibleUIElement *)elementWithAccessibleInterface:(QAccessibleInterface *)aInterface parent:(id)aParent;
+
+@end
+
+/*
+@interface NSObject (FauxUIElementChildSupport)
+
+// Anyone serving as a parent for FauxUIElements must implement this protocol.
+
+- (BOOL)isFauxUIElementFocusable:(FauxUIElement *)fauxElement;
+- (void)fauxUIElement:(FauxUIElement *)fauxElement setFocus:(id)value;
+
+- (NSPoint)fauxUIElementPosition:(FauxUIElement *)fauxElement;
+- (NSSize)fauxUIElementSize:(FauxUIElement *)fauxElement;
+
+@end
+*/
Index: qt4-x11-4.7.4/src/gui/graphicsview/qgraphicsitem.cpp
===================================================================
--- qt4-x11-4.7.4.orig/src/gui/graphicsview/qgraphicsitem.cpp	2011-08-23 14:02:27.000000000 +0200
+++ qt4-x11-4.7.4/src/gui/graphicsview/qgraphicsitem.cpp	2011-09-02 13:16:17.466865787 +0200
@@ -7395,15 +7395,19 @@
     if (QWidget *fw = QApplication::focusWidget()) {
         if (scene()) {
             for (int i = 0 ; i < scene()->views().count() ; ++i) {
-                if (scene()->views().at(i) == fw)
-                    if (QInputContext *inputContext = fw->inputContext())
+                if (scene()->views().at(i) == fw) {
+                    if (QInputContext *inputContext = fw->inputContext()) {
                         inputContext->update();
-            }
-        }
 #ifndef QT_NO_ACCESSIBILITY
-        // ##### is this correct
-        QAccessible::updateAccessibility(fw, 0, QAccessible::StateChanged);
+                        // ##### is this correct
+                        if (toGraphicsObject())
+                            QAccessible::updateAccessibility(toGraphicsObject(), 0, QAccessible::StateChanged);
 #endif
+                        break;
+                    }
+                }
+            }
+        }
     }
 #endif
 }
Index: qt4-x11-4.7.4/src/gui/graphicsview/qgraphicsscene.cpp
===================================================================
--- qt4-x11-4.7.4.orig/src/gui/graphicsview/qgraphicsscene.cpp	2011-09-02 13:14:01.000000000 +0200
+++ qt4-x11-4.7.4/src/gui/graphicsview/qgraphicsscene.cpp	2011-09-02 13:16:17.470865800 +0200
@@ -245,6 +245,10 @@
 #include <QtGui/qtransform.h>
 #include <QtGui/qinputcontext.h>
 #include <QtGui/qgraphicseffect.h>
+#ifndef QT_NO_ACCESSIBILITY
+# include <QtGui/qaccessible.h>
+#endif
+
 #include <private/qapplication_p.h>
 #include <private/qobject_p.h>
 #ifdef Q_WS_X11
@@ -837,6 +841,14 @@
     if (item)
         focusItem = item;
     updateInputMethodSensitivityInViews();
+
+#ifndef QT_NO_ACCESSIBILITY
+    if (focusItem) {
+        if (QGraphicsObject *focusObj = focusItem->toGraphicsObject()) {
+            QAccessible::updateAccessibility(focusObj, 0, QAccessible::Focus);
+        }
+    }
+#endif
     if (item) {
         QFocusEvent event(QEvent::FocusIn, focusReason);
         sendEvent(item, &event);
Index: qt4-x11-4.7.4/src/gui/kernel/qwidget.cpp
===================================================================
--- qt4-x11-4.7.4.orig/src/gui/kernel/qwidget.cpp	2011-08-23 14:02:27.000000000 +0200
+++ qt4-x11-4.7.4/src/gui/kernel/qwidget.cpp	2011-09-02 13:16:17.478865847 +0200
@@ -11121,6 +11121,7 @@
 {
     Q_D(QWidget);
     d->accessibleName = name;
+    QAccessible::updateAccessibility(this, 0, QAccessible::NameChanged);
 }
 
 QString QWidget::accessibleName() const
@@ -11142,6 +11143,7 @@
 {
     Q_D(QWidget);
     d->accessibleDescription = description;
+    QAccessible::updateAccessibility(this, 0, QAccessible::DescriptionChanged);
 }
 
 QString QWidget::accessibleDescription() const
@@ -11257,8 +11259,10 @@
     }
 #endif
 #ifndef QT_NO_ACCESSIBILITY
-    // ##### is this correct
-    QAccessible::updateAccessibility(this, 0, QAccessible::StateChanged);
+    if (isVisible()) {
+        // ##### is this correct
+        QAccessible::updateAccessibility(this, 0, QAccessible::StateChanged);
+    }
 #endif
 }
 
Index: qt4-x11-4.7.4/src/gui/widgets/qlinecontrol.cpp
===================================================================
--- qt4-x11-4.7.4.orig/src/gui/widgets/qlinecontrol.cpp	2011-08-23 14:02:27.000000000 +0200
+++ qt4-x11-4.7.4/src/gui/widgets/qlinecontrol.cpp	2011-09-02 13:16:17.526866085 +0200
@@ -687,7 +687,12 @@
     m_modifiedState =  m_undoState = 0;
     m_cursor = (pos < 0 || pos > m_text.length()) ? m_text.length() : pos;
     m_textDirty = (oldText != m_text);
-    finishChange(-1, true, edited);
+    bool changed = finishChange(-1, true, edited);
+
+#ifndef QT_NO_ACCESSIBILITY
+    if (changed)
+        QAccessible::updateAccessibility(parent(), 0, QAccessible::TextUpdated);
+#endif
 }
 
 
@@ -1284,6 +1289,9 @@
         const int oldLast = m_lastCursorPos;
         m_lastCursorPos = m_cursor;
         cursorPositionChanged(oldLast, m_cursor);
+#ifndef QT_NO_ACCESSIBILITY
+        QAccessible::updateAccessibility(parent(), 0, QAccessible::TextCaretMoved);
+#endif
     }
 }
 
Index: qt4-x11-4.7.4/src/gui/widgets/qlinecontrol_p.h
===================================================================
--- qt4-x11-4.7.4.orig/src/gui/widgets/qlinecontrol_p.h	2011-08-23 14:02:27.000000000 +0200
+++ qt4-x11-4.7.4/src/gui/widgets/qlinecontrol_p.h	2011-09-02 13:16:17.526866085 +0200
@@ -61,10 +61,10 @@
 #include "QtGui/qtextlayout.h"
 #include "QtGui/qstyleoption.h"
 #include "QtCore/qpointer.h"
-#include "QtGui/qlineedit.h"
 #include "QtGui/qclipboard.h"
 #include "QtCore/qpoint.h"
 #include "QtGui/qcompleter.h"
+#include "QtGui/qaccessible.h"
 
 #include "qplatformdefs.h"
 
Index: qt4-x11-4.7.4/src/gui/widgets/qlineedit_p.cpp
===================================================================
--- qt4-x11-4.7.4.orig/src/gui/widgets/qlineedit_p.cpp	2011-08-23 14:02:27.000000000 +0200
+++ qt4-x11-4.7.4/src/gui/widgets/qlineedit_p.cpp	2011-09-02 13:16:17.526866085 +0200
@@ -145,6 +145,7 @@
 {
     Q_Q(QLineEdit);
     control = new QLineControl(txt);
+    control->setParent(q);
     control->setFont(q->font());
     QObject::connect(control, SIGNAL(textChanged(QString)),
             q, SIGNAL(textChanged(QString)));
Index: qt4-x11-4.7.4/src/gui/widgets/qlineedit_p.h
===================================================================
--- qt4-x11-4.7.4.orig/src/gui/widgets/qlineedit_p.h	2011-08-23 14:02:27.000000000 +0200
+++ qt4-x11-4.7.4/src/gui/widgets/qlineedit_p.h	2011-09-02 13:16:17.526866085 +0200
@@ -84,7 +84,6 @@
 
     ~QLineEditPrivate()
     {
-        delete control;
     }
 
     QLineControl *control;
Index: qt4-x11-4.7.4/src/plugins/accessible/widgets/complexwidgets.cpp
===================================================================
--- qt4-x11-4.7.4.orig/src/plugins/accessible/widgets/complexwidgets.cpp	2011-08-23 14:02:27.000000000 +0200
+++ qt4-x11-4.7.4/src/plugins/accessible/widgets/complexwidgets.cpp	2011-09-02 13:16:17.526866085 +0200
@@ -971,7 +971,11 @@
             return QAccessibleAbstractScrollArea::text(t, child);
 
         QAccessibleItemRow item(itemView(), childIndex(child));
-        return item.text(t, 1);
+        if (item.isValid()) {
+            return item.text(t, 1);
+        } else {
+            return QString();
+        }
     } else {
         return QAccessibleAbstractScrollArea::text(t, child);
     }
Index: qt4-x11-4.7.4/src/plugins/accessible/widgets/main.cpp
===================================================================
--- qt4-x11-4.7.4.orig/src/plugins/accessible/widgets/main.cpp	2011-08-23 14:02:27.000000000 +0200
+++ qt4-x11-4.7.4/src/plugins/accessible/widgets/main.cpp	2011-09-02 13:16:17.530866098 +0200
@@ -44,6 +44,11 @@
 #include "simplewidgets.h"
 #include "rangecontrols.h"
 #include "complexwidgets.h"
+#include "qaccessibledeclarativeview.h"
+#include "qaccessibledeclarativeobject.h"
+#include "qaccessiblegraphicsviewimplementation.h"
+#include "qdeclarativeitem.h"
+#include "qgraphicsview.h"
 
 #include <qaccessibleplugin.h>
 #include <qplugin.h>
@@ -72,6 +77,8 @@
 QStringList AccessibleFactory::keys() const
 {
     QStringList list;
+    list << QLatin1String("QSGItem");
+    list << QLatin1String("QDeclarativeItem");
 #ifndef QT_NO_LINEEDIT
     list << QLatin1String("QLineEdit");
 #endif
@@ -156,11 +163,28 @@
 QAccessibleInterface *AccessibleFactory::create(const QString &classname, QObject *object)
 {
     QAccessibleInterface *iface = 0;
+
+    if (0) {
+    } else if (QDeclarativeItem *item = qobject_cast<QDeclarativeItem *>(object)) {
+        if (!item->scene())
+            return 0;
+
+        QList<QGraphicsView *> views = item->scene()->views();
+        if (views.isEmpty())
+            return 0;
+        QGraphicsView *view = views.at(0); // Accessibility support for the first view only.
+                                           // (Not a problem for QDeclarative)
+        iface = QAccessibleGraphicsViewImplementation::instantiateObject(item, view);
+    }
+
     if (!object || !object->isWidgetType())
         return iface;
+
     QWidget *widget = static_cast<QWidget*>(object);
 
-    if (false) {
+    if (iface) {
+    } else if (qobject_cast<QDeclarativeView *>(widget) != 0) {
+        iface = new QAccessibleDeclarativeView(widget);
 #ifndef QT_NO_LINEEDIT
     } else if (classname == QLatin1String("QLineEdit")) {
         iface = new QAccessibleLineEdit(widget);
Index: qt4-x11-4.7.4/src/plugins/accessible/widgets/qaccessibledeclarativeimplementation.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ qt4-x11-4.7.4/src/plugins/accessible/widgets/qaccessibledeclarativeimplementation.cpp	2011-09-02 13:16:17.530866098 +0200
@@ -0,0 +1,11 @@
+#include "qaccessibledeclarativeimplementation.h"
+
+QAccessibleDeclarativeImplementation::QAccessibleDeclarativeImplementation()
+    :m_accessibleObject(0)
+{
+}
+
+void QAccessibleDeclarativeImplementation::setBaseObject(QAccessibleObjectEx *accessibleObject)
+{
+    m_accessibleObject = accessibleObject;
+}
Index: qt4-x11-4.7.4/src/plugins/accessible/widgets/qaccessibledeclarativeimplementation.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ qt4-x11-4.7.4/src/plugins/accessible/widgets/qaccessibledeclarativeimplementation.h	2011-09-02 13:16:17.530866098 +0200
@@ -0,0 +1,37 @@
+#ifndef QACCESSIBLEDECLARATIVEIMPLEMENTATION_H
+#define QACCESSIBLEDECLARATIVEIMPLEMENTATION_H
+
+#include <qaccessibleobject.h>
+
+#ifndef QT_NO_ACCESSIBILITY
+
+class QAccessibleDeclarativeObject;
+class QAccessibleDeclarativeImplementation
+{
+public:
+    QAccessibleDeclarativeImplementation();
+    void setBaseObject(QAccessibleObjectEx *accessibleObject);
+
+    /* geometry */
+    virtual QRect itemRect() const = 0;
+    virtual QRect viewRect() const = 0;
+
+    /* hit testing */
+    virtual bool clipsChildren() const = 0;
+
+    /* hierarchy */
+    virtual int childCount() const = 0;
+    virtual int navigate(QAccessible::RelationFlag rel, int entry, QAccessibleInterface **target) const = 0;
+    virtual int indexOfChild(const QAccessibleInterface *iface) const = 0;
+
+    virtual QFlags<QAccessible::StateFlag> state() const = 0;
+    virtual bool isAccessible() const  = 0;
+protected:
+    QAccessibleObjectEx *m_accessibleObject;
+};
+
+#endif // QT_NO_ACCESSIBILITY
+
+QT_END_NAMESPACE
+
+#endif // QACCESSIBLEDECLARATIVEIMPLEMENTATION_H
Index: qt4-x11-4.7.4/src/plugins/accessible/widgets/qaccessibledeclarativeobject.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ qt4-x11-4.7.4/src/plugins/accessible/widgets/qaccessibledeclarativeobject.cpp	2011-09-02 13:16:17.530866098 +0200
@@ -0,0 +1,401 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** No Commercial Usage
+** This file contains pre-release code and may not be distributed.
+** You may use this file in accordance with the terms and conditions
+** contained in the Technology Preview License Agreement accompanying
+** this package.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights.  These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** If you have questions regarding the use of this file, please contact
+** Nokia at qt-info@nokia.com.
+**
+**
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qaccessibledeclarativeobject.h"
+#include <qnamespace.h>
+
+#ifndef QT_NO_ACCESSIBILITY
+
+QT_BEGIN_NAMESPACE
+
+
+/*
+    Creates a new QAccessibleDeclarativeObject instance bases on the objects
+    accessibleRole. Takes ownership of the implementation object.
+*/
+QAccessibleDeclarativeObject *QAccessibleDeclarativeObject::instantiateObject(QObject *object, QAccessibleDeclarativeImplementation *implementation)
+{
+    const QVariant role = QDeclarativeAccessibleAttached::property(object, "role");
+    const QAccessible::Role roleAttribute = static_cast<QAccessible::Role>(role.toInt());
+
+    QAccessibleDeclarativeObject *accessibleObject = 0;
+
+    // Add code here to map roleAttributes to QAccessibleRoles and
+    // QAccessibleDeclarativeObject subclasses.
+    if (0) {
+    } else if (roleAttribute == QAccessible::PushButton) {
+        accessibleObject = new QAccessibleDeclarativeObject(object, implementation, QAccessible::PushButton);
+    } else if (roleAttribute == QAccessible::StaticText) {
+        accessibleObject = new QAccessibleDeclarativeObject(object, implementation, QAccessible::StaticText);
+    } else if (roleAttribute == QAccessible::CheckBox) {
+        accessibleObject = new QAccessibleDeclarativeObject(object, implementation, QAccessible::CheckBox);
+    } else if (roleAttribute == QAccessible::RadioButton) {
+        accessibleObject = new QAccessibleDeclarativeObject(object, implementation, QAccessible::RadioButton);
+    } else if (roleAttribute == QAccessible::EditableText) {
+        accessibleObject = new QAccessibleDeclarativeEditableTextObject(object, implementation, QAccessible::EditableText);
+
+    /*
+    TODO
+    } else if (roleAttribute == QLatin1String("ProgressBar")) {
+       accessibleObject = new QAccessibleDeclarativeObject(object, implementation, QAccessible::ProgressBar);
+    } else if (roleAttribute == QLatin1String("Slider")) {
+       accessibleObject = new QAccessibleDeclarativeObject(object, implementation, QAccessible::Slider);
+*/
+    } else {
+        // This handles unknown roles and items with no role set.
+        accessibleObject = new QAccessibleDeclarativeObject(object, implementation, QAccessible::Pane);
+    }
+
+    // the graphicsview/scene graph implementation might need to call down to
+    // QAccessibleObjectEx, give it a pointer (we still own the object).
+    implementation->setBaseObject(accessibleObject);
+
+    return accessibleObject;
+}
+
+QAccessibleDeclarativeObject::QAccessibleDeclarativeObject(QObject *object, QAccessibleDeclarativeImplementation *implementation, QAccessible::Role role)
+    :QAccessibleObjectEx(object)
+    ,m_implementation(implementation)
+    ,m_role(role)
+{
+
+}
+
+QAccessibleDeclarativeObject::~QAccessibleDeclarativeObject()
+{
+    delete m_implementation;
+}
+
+bool QAccessibleDeclarativeObject::hasChildren() const
+{
+    if (m_role == PushButton ||
+        m_role == CheckBox ||
+        m_role == RadioButton ||
+        m_role == EditableText) {
+        return false;
+    }
+    return true;
+}
+
+QRect QAccessibleDeclarativeObject::rect(int child) const
+{
+    return m_implementation->itemRect();
+}
+
+int QAccessibleDeclarativeObject::childCount() const
+{
+    if (!hasChildren())
+       return 0;
+
+    if (!m_implementation->isAccessible())
+        return 0;
+
+    return m_implementation->childCount();
+}
+
+int QAccessibleDeclarativeObject::navigate(RelationFlag rel, int entry, QAccessibleInterface **target) const
+{
+    if (rel == QAccessible::Child && !hasChildren()) {
+        *target = 0;
+        return -1;
+    }
+
+    return m_implementation->navigate(rel, entry, target);
+}
+
+int QAccessibleDeclarativeObject::indexOfChild(const QAccessibleInterface *iface) const
+{
+    if (iface) {
+        return m_implementation->indexOfChild(iface);
+    }
+    return -1;
+
+}
+
+QFlags<QAccessible::RelationFlag> QAccessibleDeclarativeObject::relationTo(int, const QAccessibleInterface*, int) const
+{
+    return 0;
+}
+
+int QAccessibleDeclarativeObject::childAt(int x, int y) const
+{
+    // Look for children first.
+    // Start with the last child first, because children are ordered in paint order
+    // (which is opposite of hit test order)
+    int hitChild = -1;
+    // If the item clips its children, we can return early if the coordinate is outside its rect
+    if (m_implementation->clipsChildren()) {
+        if (!m_implementation->itemRect().contains(x, y))
+            return -1;
+    }
+    for (int i = childCount(); i > 0 && hitChild == -1; --i) {
+        QAccessibleInterface *child = 0;
+        int id = navigate(QAccessible::Child, i, &child);
+        if (child && id == 0) {
+            if (!(child->state(0) & QAccessible::Invisible)) {
+                if (child->childAt(x, y) != -1)
+                    hitChild = i;
+            }
+            delete child;
+        }
+    }
+
+    if (hitChild == -1) {
+        if (m_implementation->itemRect().contains(x, y))
+            hitChild = 0;
+    }
+
+    return hitChild;
+}
+
+QString QAccessibleDeclarativeObject::text(QAccessible::Text textType, int) const
+{
+    // handles generic behaviour not specific to an item
+    switch (textType) {
+    case QAccessible::DebugDescription:
+        return object()->metaObject()->className();
+        break;
+    case QAccessible::Name: {
+        QVariant accessibleName = QDeclarativeAccessibleAttached::property(object(), "name");
+        if (!accessibleName.isNull())
+            return accessibleName.toString();
+        break;}
+    case QAccessible::Description: {
+        QVariant accessibleDecription = QDeclarativeAccessibleAttached::property(object(), "description");
+        if (!accessibleDecription.isNull())
+            return accessibleDecription.toString();
+        break;}
+    case Value:
+    case Help:
+    case Accelerator:
+    default:
+        break;
+    }
+
+
+    // the following blocks handles item-specific behaviour
+    if (m_role == QAccessible::EditableText) {
+        if (textType == QAccessible::Value) {
+            QVariant text = object()->property("text");
+            return text.toString();
+        } else if (textType == QAccessible::Name) {
+            return object()->objectName();
+        }
+    } else {
+        if (textType == QAccessible::Name) {
+            QVariant text = object()->property("text");
+            return text.toString();
+        }
+    }
+
+
+    return QString();
+}
+
+QAccessible::Role QAccessibleDeclarativeObject::role(int) const
+{
+    return m_role;
+}
+
+QFlags<QAccessible::StateFlag> QAccessibleDeclarativeObject::state(int) const
+{
+    QAccessible::State state = m_implementation->state();
+
+    //QRect viewRect(QPoint(0, 0), m_implementation->size());
+    //QRect itemRect(m_item->scenePos().toPoint(), m_item->boundingRect().size().toSize());
+
+    QRect viewRect = m_implementation->viewRect();
+    QRect itemRect = m_implementation->itemRect();
+
+   // qDebug() << "viewRect" << viewRect << "itemRect" << itemRect;
+    // error case:
+    if (viewRect.isNull() || itemRect.isNull()) {
+        state |= QAccessible::Invisible;
+    }
+
+    if (!viewRect.intersects(itemRect)) {
+        state |= QAccessible::Offscreen;
+        // state |= QAccessible::Invisible; // no set at this point to ease development
+    }
+
+    if (!object()->property("visible").toBool() || qFuzzyIsNull(object()->property("opacity").toDouble())) {
+        state |= QAccessible::Invisible;
+    }
+
+    if ((m_role == CheckBox || m_role == RadioButton) && object()->property("checked").toBool()) {
+        state |= QAccessible::Checked;
+    }
+
+    if (m_role == QAccessible::EditableText)
+        state |= QAccessible::Focusable;
+
+    //qDebug() << "state?" << m_item->property("state").toString() << m_item->property("status").toString() << m_item->property("visible").toString();
+
+    return state;
+}
+
+bool QAccessibleDeclarativeObject::doAction(int action, int child, const QVariantList &params)
+{
+    if (m_role == PushButton && action == QAccessible::Press) {
+        QMetaObject::invokeMethod(object(), "accessibleAction", Q_ARG(QVariant, action));
+    }
+    if ((m_role == CheckBox || m_role == RadioButton) && action == QAccessible::Press) {
+        bool checked = object()->property("checked").toBool();
+        object()->setProperty("checked",  QVariant(!checked));
+    }
+
+    return QAccessibleObjectEx::doAction(action, child, params);
+}
+
+QVariant QAccessibleDeclarativeObject::invokeMethodEx(QAccessible::Method method, int, const QVariantList&)
+{
+    return QVariant();
+}
+
+
+// TEXT interface
+
+QAccessibleDeclarativeTextObject::QAccessibleDeclarativeTextObject(QObject *object, QAccessibleDeclarativeImplementation *implementation, QAccessible::Role role)
+    : QAccessibleDeclarativeObject(object, implementation, role)
+{
+}
+
+QFlags<QAccessible::StateFlag> QAccessibleDeclarativeTextObject::state(int child) const
+{
+    Q_ASSERT(child == 0);
+    return QAccessibleDeclarativeObject::state(child) | HasInvokeExtension;
+}
+
+QString QAccessibleDeclarativeTextObject::text() const
+{
+    QVariant text = object()->property("text");
+    return text.toString();
+}
+
+void QAccessibleDeclarativeTextObject::setText(QAccessible::Text t, int child, const QString& text)
+{
+    Q_ASSERT(child == 0);
+    // do we care about the type?
+    object()->setProperty("text", text);
+}
+
+int QAccessibleDeclarativeTextObject::characterCount()
+{
+    return text().length();
+}
+
+QString QAccessibleDeclarativeTextObject::text(int startOffset, int endOffset)
+{
+    // FIXME: password mode in all of these?
+    return text().mid(startOffset, endOffset - startOffset);
+}
+
+
+
+QString QAccessibleDeclarativeTextObject::textAfterOffset(int offset, QAccessible2::BoundaryType boundaryType, int* startOffset, int* endOffset)
+{
+    return textAfterOffsetFromString(offset, boundaryType, startOffset, endOffset, text());
+}
+
+QString QAccessibleDeclarativeTextObject::textAtOffset(int offset, QAccessible2::BoundaryType boundaryType, int* startOffset, int* endOffset)
+{
+    return textAtOffsetFromString(offset, boundaryType, startOffset, endOffset, text());
+}
+
+QString QAccessibleDeclarativeTextObject::textBeforeOffset(int offset, QAccessible2::BoundaryType boundaryType, int* startOffset, int* endOffset)
+{
+    return textBeforeOffsetFromString(offset, boundaryType, startOffset, endOffset, text());
+}
+
+int QAccessibleDeclarativeTextObject::offsetAtPoint(const QPoint& point, QAccessible2::CoordinateType coordType)
+{
+    // TODO
+    return 0;
+}
+QString QAccessibleDeclarativeTextObject::attributes(int offset, int* startOffset, int* endOffset)
+{
+    // TODO
+    return QString();
+}
+QRect QAccessibleDeclarativeTextObject::characterRect(int offset, QAccessible2::CoordinateType coordType)
+{
+    // TODO
+    return QRect();
+}
+
+
+int QAccessibleDeclarativeTextObject::cursorPosition()
+{
+    return 0;
+}
+void QAccessibleDeclarativeTextObject::setCursorPosition(int position)
+{
+
+}
+void QAccessibleDeclarativeTextObject::scrollToSubstring(int startIndex, int endIndex)
+{
+
+}
+
+int QAccessibleDeclarativeTextObject::selectionCount()
+{
+    return 0;
+}
+void QAccessibleDeclarativeTextObject::selection(int selectionIndex, int* startOffset, int* endOffset)
+{
+
+}
+void QAccessibleDeclarativeTextObject::setSelection(int selectionIndex, int startOffset, int endOffset)
+{
+
+}
+void QAccessibleDeclarativeTextObject::addSelection(int startOffset, int endOffset)
+{
+
+}
+void QAccessibleDeclarativeTextObject::removeSelection(int selectionIndex)
+{
+
+}
+
+QT_END_NAMESPACE
+
+#endif // QT_NO_ACCESSIBILITY
Index: qt4-x11-4.7.4/src/plugins/accessible/widgets/qaccessibledeclarativeobject.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ qt4-x11-4.7.4/src/plugins/accessible/widgets/qaccessibledeclarativeobject.h	2011-09-02 13:16:17.530866098 +0200
@@ -0,0 +1,172 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** No Commercial Usage
+** This file contains pre-release code and may not be distributed.
+** You may use this file in accordance with the terms and conditions
+** contained in the Technology Preview License Agreement accompanying
+** this package.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights.  These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** If you have questions regarding the use of this file, please contact
+** Nokia at qt-info@nokia.com.
+**
+**
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QACCESSIBLEDECLARATIVEITEM_H
+#define QACCESSIBLEDECLARATIVEITEM_H
+
+#include "complexwidgets.h"
+#include "qaccessibledeclarativeimplementation.h"
+#include <QtDeclarative/qdeclarativeview.h>
+#include <QtDeclarative/qdeclarativeitem.h>
+#include <QtDeclarative/qdeclarativeproperty.h>
+#include <private/qdeclarativeaccessible_p.h>
+
+
+QT_BEGIN_NAMESPACE
+
+#ifndef QT_NO_ACCESSIBILITY
+
+/*
+    -- Declarative Accessibility Overview. --
+
+    QML accessibility is implemented using two class hierarchies and two "view" interface classes.
+
+    * The interface hierarchy.
+    This hierarchy implements QAccessibleInterfaces for the various QML interfaces.
+    The root of the hierarchy is QAccessibleDeclarativeObject - subclass as necessary
+    to implement QML items.
+
+    * The implementation hierarchy.
+    This hierarchy abstracts the implementation differences between Qt Quick1 and Qt Quick2.
+    The base class is QAccessibleDeclarativeImplementation, with two subclasses:
+    QAccessibleGraphicsViewImplementation
+    QAccessibleSceneGraphImplementation
+
+    The two hierarchies are connected: each QAccessibleDeclarativeObject owns a
+    QAccessibleDeclarativeImplementation. (This is the Bridge pattern, for the
+    design pattern inclined.)
+
+    * View interface classes.
+
+    These are the root of the QML accessible tree and connects it to the widget hierarchy.
+
+    QAccessbileDeclarativeView is the root for the QGraphicsView implementation
+    QAccessbileSceneGraphView is the root for the SceneGraph implementation
+
+
+*/
+class QAccessibleDeclarativeObject: public QAccessibleObjectEx
+{
+    Q_ACCESSIBLE_OBJECT
+public:
+    // Use this factory method to instantiate objects. This will create an accessible object of the
+    // correct type depending the accessibleRole attribute. Implementation should be one of
+    // graphicsview or scenegraph.
+    static QAccessibleDeclarativeObject *instantiateObject(QObject *item, QAccessibleDeclarativeImplementation *implementation);
+
+    ~QAccessibleDeclarativeObject();
+
+    QRect rect(int child) const;
+    int childCount() const;
+    int navigate(RelationFlag rel, int entry, QAccessibleInterface **target) const;
+    int indexOfChild(const QAccessibleInterface*) const;
+    QFlags<QAccessible::RelationFlag> relationTo(int, const QAccessibleInterface*, int) const;
+    int childAt(int, int) const;
+    QString text(QAccessible::Text, int) const;
+    QAccessible::Role role(int) const;
+    QFlags<QAccessible::StateFlag> state(int) const;
+    bool doAction(int action, int child, const QVariantList &params);
+    QVariant invokeMethodEx(QAccessible::Method, int, const QVariantList&);
+protected:
+    // For sublcasses, use instantiateObject factory methotd outside the class.
+    QAccessibleDeclarativeObject(QObject *object, QAccessibleDeclarativeImplementation *implementation, QAccessible::Role role);
+
+private:
+    bool hasChildren() const;
+
+private:
+    QAccessibleDeclarativeImplementation *m_implementation;
+    QAccessible::Role m_role;
+};
+
+class QAccessibleDeclarativeTextObject
+        : public QAccessibleDeclarativeObject, public QAccessibleTextInterface
+{
+    Q_ACCESSIBLE_OBJECT
+public:
+    virtual void addSelection(int startOffset, int endOffset);
+    virtual QString attributes(int offset, int *startOffset, int *endOffset);
+    virtual int cursorPosition();
+    virtual QRect characterRect(int offset, QAccessible2::CoordinateType coordType);
+    virtual int selectionCount();
+    virtual int offsetAtPoint(const QPoint &point, QAccessible2::CoordinateType coordType);
+    virtual void selection(int selectionIndex, int *startOffset, int *endOffset);
+    virtual QString text(int startOffset, int endOffset);
+    virtual QString textBeforeOffset (int offset, QAccessible2::BoundaryType boundaryType,
+                              int *startOffset, int *endOffset);
+    virtual QString textAfterOffset(int offset, QAccessible2::BoundaryType boundaryType,
+                            int *startOffset, int *endOffset);
+    virtual QString textAtOffset(int offset, QAccessible2::BoundaryType boundaryType,
+                         int *startOffset, int *endOffset);
+    virtual void removeSelection(int selectionIndex);
+    virtual void setCursorPosition(int position);
+    virtual void setSelection(int selectionIndex, int startOffset, int endOffset);
+    virtual int characterCount();
+    virtual void scrollToSubstring(int startIndex, int endIndex);
+
+    // add invoke extension
+    QFlags<QAccessible::StateFlag> state(int) const;
+
+    virtual void setText(Text t, int child, const QString &text);
+
+protected:
+    QAccessibleDeclarativeTextObject(QObject *object, QAccessibleDeclarativeImplementation *implementation, QAccessible::Role role);
+    QString text() const;
+friend class QAccessibleDeclarativeObject;
+};
+
+class QAccessibleDeclarativeEditableTextObject
+        : public QAccessibleDeclarativeTextObject, public QAccessibleSimpleEditableTextInterface
+{
+
+protected:
+    QAccessibleDeclarativeEditableTextObject(QObject *object, QAccessibleDeclarativeImplementation *implementation, QAccessible::Role role)
+        : QAccessibleDeclarativeTextObject(object, implementation, role), QAccessibleSimpleEditableTextInterface(this)
+    {}
+
+friend class QAccessibleDeclarativeObject;
+};
+
+#endif // QT_NO_ACCESSIBILITY
+
+QT_END_NAMESPACE
+
+#endif // QACCESSIBLEDECLARATIVEITEM_H
Index: qt4-x11-4.7.4/src/plugins/accessible/widgets/qaccessibledeclarativeview.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ qt4-x11-4.7.4/src/plugins/accessible/widgets/qaccessibledeclarativeview.cpp	2011-09-02 13:16:17.530866098 +0200
@@ -0,0 +1,104 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** No Commercial Usage
+** This file contains pre-release code and may not be distributed.
+** You may use this file in accordance with the terms and conditions
+** contained in the Technology Preview License Agreement accompanying
+** this package.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights.  These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** If you have questions regarding the use of this file, please contact
+** Nokia at qt-info@nokia.com.
+**
+**
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qaccessibledeclarativeview.h"
+#include "qaccessibledeclarativeobject.h"
+#include "qaccessiblegraphicsviewimplementation.h"
+
+#ifndef QT_NO_ACCESSIBILITY
+
+QT_BEGIN_NAMESPACE
+
+QAccessibleDeclarativeView::QAccessibleDeclarativeView(QWidget *widget)
+    :QAccessibleAbstractScrollArea(widget)
+{
+    m_view = static_cast<QDeclarativeView *>(widget);
+}
+
+int QAccessibleDeclarativeView::childCount() const
+{
+    return 1;
+}
+
+int QAccessibleDeclarativeView::navigate(RelationFlag rel, int entry, QAccessibleInterface **target) const
+{
+    //qDebug() << "navigate" << rel << entry << "root" << (void*)m_view->accessibleRootItem();
+    QDeclarativeItem *declarativeRoot = m_view->accessibleRootItem();
+
+    if (rel == QAccessible::Child) {
+        if (entry != 1 || !declarativeRoot) {
+            *target = 0;
+            return -1;
+        }
+        *target = QAccessibleGraphicsViewImplementation::instantiateObject(declarativeRoot, m_view);
+        return 0;
+    }
+
+    return QAccessibleAbstractScrollArea::navigate(rel, entry, target);
+}
+
+QString QAccessibleDeclarativeView::text(QAccessible::Text textType, int child) const
+{
+    if (textType == QAccessible::DebugDescription) {
+        return QLatin1String("QDeclarativeView");
+    }
+    return QAccessibleAbstractScrollArea::text(textType, child);
+}
+
+int QAccessibleDeclarativeView::childAt(int x, int y) const
+{
+    return 1; // return the top-level QML item
+}
+
+int QAccessibleDeclarativeView::indexOfChild(const QAccessibleInterface *iface) const
+{
+    if (iface) {
+        QDeclarativeItem *declarativeRoot = m_view->accessibleRootItem();
+        if (declarativeRoot == iface->object())
+            return 1;
+    }
+    return -1;
+
+}
+
+QT_END_NAMESPACE
+
+#endif // QT_NO_ACCESSIBILITY
Index: qt4-x11-4.7.4/src/plugins/accessible/widgets/qaccessibledeclarativeview.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ qt4-x11-4.7.4/src/plugins/accessible/widgets/qaccessibledeclarativeview.h	2011-09-02 13:16:17.530866098 +0200
@@ -0,0 +1,73 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** No Commercial Usage
+** This file contains pre-release code and may not be distributed.
+** You may use this file in accordance with the terms and conditions
+** contained in the Technology Preview License Agreement accompanying
+** this package.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights.  These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** If you have questions regarding the use of this file, please contact
+** Nokia at qt-info@nokia.com.
+**
+**
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QACCESSIBLEDECLARATIVEVIEW_H
+#define QACCESSIBLEDECLARATIVEVIEW_H
+
+#include "complexwidgets.h"
+#include <QtDeclarative/qdeclarativeview.h>
+#include <QtDeclarative/qdeclarativeitem.h>
+
+QT_BEGIN_NAMESPACE
+
+#ifndef QT_NO_ACCESSIBILITY
+
+class QAccessibleDeclarativeView: public QAccessibleAbstractScrollArea
+{
+    Q_ACCESSIBLE_OBJECT
+public:
+    explicit QAccessibleDeclarativeView(QWidget *widget);
+
+    int childCount() const;
+    int navigate(RelationFlag rel, int entry, QAccessibleInterface **target) const;
+    QString text(QAccessible::Text, int) const;
+    int childAt(int x, int y) const;
+    int indexOfChild(const QAccessibleInterface *iface) const;
+
+private:
+    QDeclarativeView *m_view;
+};
+
+#endif // QT_NO_ACCESSIBILITY
+
+QT_END_NAMESPACE
+
+#endif // QACCESSIBLEDECLARATIVEVIEW_H
Index: qt4-x11-4.7.4/src/plugins/accessible/widgets/qaccessiblegraphicsviewimplementation.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ qt4-x11-4.7.4/src/plugins/accessible/widgets/qaccessiblegraphicsviewimplementation.cpp	2011-09-02 13:16:17.534866119 +0200
@@ -0,0 +1,168 @@
+#include "qaccessiblegraphicsviewimplementation.h"
+#include "qaccessibledeclarativeobject.h"
+
+QAccessibleGraphicsViewImplementation::QAccessibleGraphicsViewImplementation(QGraphicsItem *item, QGraphicsView *view)
+    :QAccessibleDeclarativeImplementation()
+    ,m_item(item)
+    ,m_view(view)
+{
+
+}
+
+
+QAccessibleDeclarativeObject *QAccessibleGraphicsViewImplementation::instantiateObject(QGraphicsObject *item, QGraphicsView *view)
+{
+    QAccessibleGraphicsViewImplementation * impl = new QAccessibleGraphicsViewImplementation(item, view);
+    return QAccessibleDeclarativeObject::instantiateObject(item, impl);
+}
+
+
+int QAccessibleGraphicsViewImplementation::childCount() const
+{
+    QList<QGraphicsItem *> children = m_item->childItems();
+    return children.count();
+}
+
+QRect QAccessibleGraphicsViewImplementation::itemRect() const
+{
+    QRectF sceneRect = m_item->sceneTransform().mapRect(m_item->boundingRect());
+    QPoint pos = m_view->mapFromScene(m_view->mapToGlobal(sceneRect.topLeft().toPoint()));
+    QSize size = sceneRect.size().toSize();
+    return QRect(pos, size);
+}
+
+QRect QAccessibleGraphicsViewImplementation::viewRect() const
+{
+    QPoint screenPos = m_view->mapToGlobal(m_view->pos());
+    return QRect(screenPos, m_view->size());
+}
+
+bool QAccessibleGraphicsViewImplementation::clipsChildren() const
+{
+    return static_cast<QDeclarativeItem *>(m_item)->clip();
+}
+
+static inline bool isAncestor(const QObject *ancestorCandidate, const QObject *child)
+{
+    while (child) {
+        if (child == ancestorCandidate)
+            return true;
+        child = child->parent();
+    }
+    return false;
+}
+
+int QAccessibleGraphicsViewImplementation::navigate(QAccessible::RelationFlag rel, int entry, QAccessibleInterface **target) const
+{
+    //qDebug() << "QAccessibleDeclarativeItem navigate" << rel << entry;
+    Q_ASSERT(entry >= 0);
+
+    *target = 0;
+    if (entry == 0) {
+        *target = instantiateObject(m_item->toGraphicsObject(), m_view);
+        return 0;
+    }
+
+    switch (rel) {
+    case QAccessible::Child: {
+        QList<QGraphicsItem *> children = m_item->childItems();
+        const int childIndex = entry - 1;
+
+        if (childIndex >= children.count())
+            return -1;
+
+        QGraphicsItem *child = children.at(childIndex);
+        QGraphicsObject *childObject = qobject_cast<QGraphicsObject *>(child);
+        if (!childObject)
+            return -1;
+
+        *target = instantiateObject(childObject, m_view);
+        return 0;
+        break;}
+    case QAccessible::Ancestor: {
+        Q_ASSERT(entry >= 1);
+        QGraphicsItem *parent = m_item->parentItem();
+        QGraphicsObject *parentObj = parent ? parent->toGraphicsObject() : 0;
+        if (parent && !parentObj)
+            qWarning("Can not make QGraphicsItems accessible");
+        QAccessibleInterface *ancestor = (parentObj
+                 ? instantiateObject(parentObj, m_view)
+                 : QAccessible::queryAccessibleInterface(m_view));
+        if (entry == 1) {
+            *target = ancestor;
+            return 0;
+        } else if (entry > 1) {
+            int ret = ancestor->navigate(QAccessible::Ancestor, entry - 1, target);
+            delete ancestor;
+            return ret;
+        }
+        break;}
+    case QAccessible::Sibling: {
+        QAccessibleInterface *iface = 0;
+        if (navigate(QAccessible::Ancestor, 1, &iface) == 0) {
+            if (iface) {
+                int ret = iface->navigate(QAccessible::Child, entry, target);
+                delete iface;
+                return ret;
+            }
+        }
+        return -1;
+        break;}
+    case QAccessible::FocusChild: {
+        QGraphicsObject *focusObject = 0;
+        if (m_item->hasFocus()) {
+            focusObject = m_item->toGraphicsObject();
+        } else {
+            if (QGraphicsItem *focusItem = m_view->scene()->focusItem()) {
+                if (m_item->isAncestorOf(focusItem)) {
+                    focusObject = focusItem->toGraphicsObject();
+                }
+            }
+        }
+        //qDebug() << "QAccessibleDeclarativeItem navigate QAccessible::FocusChild" << rel << entry;
+        if (focusObject) {
+            *target = instantiateObject(focusObject, m_view);
+            return 0;
+        }
+    }
+    default: break;
+    }
+
+    return -1;
+
+}
+
+int QAccessibleGraphicsViewImplementation::indexOfChild(const QAccessibleInterface *iface) const
+{
+    // ### No QAccessibleInterfaces are created with a QGraphicsItem.
+    // However, we want to support QML, not QGraphicsView in general.
+    // And since the UI is written in QML, this means we can assume that *all*
+    // QGraphicsItems are actually QGraphicsObjects
+
+    const QGraphicsObject *childObj = static_cast<QGraphicsObject*>(iface->object());
+    if (m_item == childObj)
+        return 0;
+
+    QList<QGraphicsItem*> kids = m_item->childItems();
+    int index = kids.indexOf(const_cast<QGraphicsItem*>(static_cast<const QGraphicsItem*>(childObj)));
+    if (index != -1) {
+        ++index;
+    }
+    return index;
+}
+
+QFlags<QAccessible::StateFlag> QAccessibleGraphicsViewImplementation::state() const
+{
+    QAccessible::State state = QAccessible::Normal;
+
+    if (m_item->hasFocus()) {
+        state |= QAccessible::Focused;
+    }
+    return state;
+}
+
+bool QAccessibleGraphicsViewImplementation::isAccessible() const
+{
+    return true;
+}
+
Index: qt4-x11-4.7.4/src/plugins/accessible/widgets/qaccessiblegraphicsviewimplementation.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ qt4-x11-4.7.4/src/plugins/accessible/widgets/qaccessiblegraphicsviewimplementation.h	2011-09-02 13:16:17.534866119 +0200
@@ -0,0 +1,30 @@
+#ifndef QACCESSIBLEGRAPHICSVIEWIMPLEMENTATION_H
+#define QACCESSIBLEGRAPHICSVIEWIMPLEMENTATION_H
+
+#include "qaccessibledeclarativeimplementation.h"
+#include <QGraphicsView>
+#include <QGraphicsItem>
+
+class QAccessibleGraphicsViewImplementation : public QAccessibleDeclarativeImplementation
+{
+public:
+    QAccessibleGraphicsViewImplementation(QGraphicsItem *item, QGraphicsView *view);
+    static QAccessibleDeclarativeObject *instantiateObject(QGraphicsObject *item, QGraphicsView *view);
+
+    QRect itemRect() const;
+    QRect viewRect() const;
+
+    bool clipsChildren() const;
+
+    int childCount() const;
+    int navigate(QAccessible::RelationFlag rel, int entry, QAccessibleInterface **target) const;
+    int indexOfChild(const QAccessibleInterface *iface) const;
+
+    QFlags<QAccessible::StateFlag> state() const;
+    virtual bool isAccessible() const;
+private:
+   QGraphicsItem *m_item;
+   QGraphicsView *m_view;
+};
+
+#endif // QACCESSIBLEGRAPHICSVIEWIMPLEMENTATION_H
Index: qt4-x11-4.7.4/src/plugins/accessible/widgets/qaccessiblewidgets.cpp
===================================================================
--- qt4-x11-4.7.4.orig/src/plugins/accessible/widgets/qaccessiblewidgets.cpp	2011-08-23 14:02:27.000000000 +0200
+++ qt4-x11-4.7.4/src/plugins/accessible/widgets/qaccessiblewidgets.cpp	2011-09-02 13:16:17.534866119 +0200
@@ -401,9 +401,14 @@
 
 int QAccessibleStackedWidget::indexOfChild(const QAccessibleInterface *child) const
 {
-    if (!child || (stackedWidget()->currentWidget() != child->object()))
+    if (!child)
         return -1;
-    return 1;
+
+    QWidget* widget = qobject_cast<QWidget*>(child->object());
+    int index = stackedWidget()->indexOf(widget);
+    if (index >= 0) // one based counting of children
+        return index + 1;
+    return -1;
 }
 
 int QAccessibleStackedWidget::navigate(RelationFlag relation, int entry, QAccessibleInterface **target) const
@@ -413,9 +418,9 @@
     QObject *targetObject = 0;
     switch (relation) {
     case Child:
-        if (entry != 1)
+        if (entry < 1 || entry > stackedWidget()->count())
             return -1;
-        targetObject = stackedWidget()->currentWidget();
+        targetObject = stackedWidget()->widget(entry-1);
         break;
     default:
         return QAccessibleWidgetEx::navigate(relation, entry, target);
@@ -1334,7 +1339,7 @@
 
     QRect r = edit->cursorRect(cursor);
     if (cursor.movePosition(QTextCursor::NextCharacter)) {
-        r.setWidth(edit->cursorRect(cursor).y() - r.y());
+        r.setWidth(edit->cursorRect(cursor).x() - r.x());
     } else {
         // we don't know the width of the character - maybe because we're at document end
         // in that case, IAccessible2 tells us to return the width of a default character
@@ -1603,7 +1608,7 @@
 
 #ifndef QT_NO_MAINWINDOW
 QAccessibleMainWindow::QAccessibleMainWindow(QWidget *widget)
-    : QAccessibleWidgetEx(widget, Application) { }
+    : QAccessibleWidgetEx(widget, Window) { }
 
 QVariant QAccessibleMainWindow::invokeMethodEx(QAccessible::Method /*method*/, int /*child*/, const QVariantList & /*params*/)
 {
Index: qt4-x11-4.7.4/src/plugins/accessible/widgets/simplewidgets.cpp
===================================================================
--- qt4-x11-4.7.4.orig/src/plugins/accessible/widgets/simplewidgets.cpp	2011-08-23 14:02:27.000000000 +0200
+++ qt4-x11-4.7.4/src/plugins/accessible/widgets/simplewidgets.cpp	2011-09-02 13:16:17.534866119 +0200
@@ -131,7 +131,7 @@
 /*! \reimp */
 bool QAccessibleButton::doAction(int action, int child, const QVariantList &params)
 {
-    if (child || !widget()->isEnabled() || !widget()->isVisible())
+    if (child || !widget()->isEnabled())
         return false;
 
     switch (action) {
@@ -155,9 +155,6 @@
 QString QAccessibleButton::text(Text t, int child) const
 {
     QString str;
-    if (!widget()->isVisible())
-        return str;
-
     switch (t) {
     case Accelerator:
         {
@@ -227,6 +224,9 @@
 {
     switch (actionIndex) {
     case 0:
+        if (button()->isCheckable()) {
+            return QLatin1String("Toggles the button.");
+        }
         return QLatin1String("Clicks the button.");
     default:
         return QString();
@@ -237,6 +237,13 @@
 {
     switch (actionIndex) {
     case 0:
+        if (button()->isCheckable()) {
+            if (button()->isChecked()) {
+                return QLatin1String("Uncheck");
+            } else {
+                return QLatin1String("Check");
+            }
+        }
         return QLatin1String("Press");
     default:
         return QString();
@@ -247,6 +254,13 @@
 {
     switch (actionIndex) {
     case 0:
+        if (button()->isCheckable()) {
+            if (button()->isChecked()) {
+                return tr("Uncheck");
+            } else {
+                return tr("Check");
+            }
+        }
         return tr("Press");
     default:
         return QString();
@@ -380,9 +394,6 @@
 QString QAccessibleToolButton::text(Text t, int child) const
 {
     QString str;
-    if (!toolButton()->isVisible())
-        return str;
-
     switch (t) {
     case Name:
         str = toolButton()->text();
@@ -454,7 +465,7 @@
 */
 bool QAccessibleToolButton::doAction(int action, int child, const QVariantList &params)
 {
-    if (!widget()->isEnabled() || !widget()->isVisible())
+    if (!widget()->isEnabled())
         return false;
     if (action == 1 || child == ButtonDropMenu) {
         if(!child)
@@ -513,8 +524,6 @@
 QString QAccessibleDisplay::text(Text t, int child) const
 {
     QString str;
-    if (!widget()->isVisible())
-        return str;
     switch (t) {
     case Name:
         str = widget()->accessibleName();
@@ -674,8 +683,6 @@
 QString QAccessibleLineEdit::text(Text t, int child) const
 {
     QString str;
-    if (!lineEdit()->isVisible())
-        return str;
     switch (t) {
     case Value:
         if (lineEdit()->echoMode() == QLineEdit::Normal)
@@ -692,8 +699,6 @@
 /*! \reimp */
 void QAccessibleLineEdit::setText(Text t, int control, const QString &text)
 {
-    if (!lineEdit()->isVisible())
-        return;
     if (t != Value || control) {
         QAccessibleWidgetEx::setText(t, control, text);
         return;
@@ -794,30 +799,39 @@
 
 QString QAccessibleLineEdit::text(int startOffset, int endOffset)
 {
+    // FIXME: passwords:
+//    lineEdit()->echoMode() == QLineEdit::Normal
+
     if (startOffset > endOffset)
         return QString();
     return lineEdit()->text().mid(startOffset, endOffset - startOffset);
 }
 
-QString QAccessibleLineEdit::textBeforeOffset (int /*offset*/, BoundaryType /*boundaryType*/,
-        int * /*startOffset*/, int * /*endOffset*/)
-{
-    // TODO
-    return QString();
+// Note: for consistency we always include the following spaces or signs with a word.
+// Therefor " Hello.  " becomes "Hello.  ".
+QString QAccessibleLineEdit::textBeforeOffset (int offset, BoundaryType boundaryType,
+        int *startOffset, int *endOffset)
+{    
+    // FIXME: passwords:
+//    lineEdit()->echoMode() == QLineEdit::Normal
+    return textBeforeOffsetFromString(offset, boundaryType, startOffset, endOffset, lineEdit()->text());
 }
 
-QString QAccessibleLineEdit::textAfterOffset(int /*offset*/, BoundaryType /*boundaryType*/,
-        int * /*startOffset*/, int * /*endOffset*/)
+
+QString QAccessibleLineEdit::textAfterOffset(int offset, BoundaryType boundaryType,
+        int *startOffset, int *endOffset)
 {
-    // TODO
-    return QString();
+    // FIXME: passwords:
+//    lineEdit()->echoMode() == QLineEdit::Normal
+    return textAfterOffsetFromString(offset, boundaryType, startOffset, endOffset, lineEdit()->text());
 }
 
-QString QAccessibleLineEdit::textAtOffset(int /*offset*/, BoundaryType /*boundaryType*/,
-        int * /*startOffset*/, int * /*endOffset*/)
+QString QAccessibleLineEdit::textAtOffset(int offset, BoundaryType boundaryType,
+        int *startOffset, int *endOffset)
 {
-    // TODO
-    return QString();
+    // FIXME: passwords:
+//    lineEdit()->echoMode() == QLineEdit::Normal
+    return textAtOffsetFromString(offset, boundaryType, startOffset, endOffset, lineEdit()->text());
 }
 
 void QAccessibleLineEdit::removeSelection(int selectionIndex)
Index: qt4-x11-4.7.4/src/plugins/accessible/widgets/widgets.pro
===================================================================
--- qt4-x11-4.7.4.orig/src/plugins/accessible/widgets/widgets.pro	2011-08-23 14:02:27.000000000 +0200
+++ qt4-x11-4.7.4/src/plugins/accessible/widgets/widgets.pro	2011-09-02 13:16:17.534866119 +0200
@@ -5,16 +5,26 @@
 QTDIR_build:DESTDIR  = $$QT_BUILD_TREE/plugins/accessible
 
 QTDIR_build:REQUIRES += "contains(QT_CONFIG, accessibility)"
+QT += declarative
+win32:!wince*: DEFINES += QT_NO_EGL
 
 SOURCES  += main.cpp \
 	    simplewidgets.cpp \
 	    rangecontrols.cpp \
 	    complexwidgets.cpp \
 	    qaccessiblewidgets.cpp \
-	    qaccessiblemenu.cpp
+	    qaccessiblemenu.cpp \
+            qaccessibledeclarativeview.cpp \
+    qaccessiblegraphicsviewimplementation.cpp \
+    qaccessibledeclarativeimplementation.cpp \
+    qaccessibledeclarativeobject.cpp
 
 HEADERS  += qaccessiblewidgets.h \
 	    simplewidgets.h \
 	    rangecontrols.h \
 	    complexwidgets.h \
-	    qaccessiblemenu.h
+	    qaccessiblemenu.h \
+            qaccessibledeclarativeview.h \
+    qaccessiblegraphicsviewimplementation.h \
+    qaccessibledeclarativeimplementation.h \
+    qaccessibledeclarativeobject.h
Index: qt4-x11-4.7.4/tools/accessibilityinspector/accessibilityinspector.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ qt4-x11-4.7.4/tools/accessibilityinspector/accessibilityinspector.cpp	2011-09-02 13:16:17.534866119 +0200
@@ -0,0 +1,142 @@
+#include "accessibilityinspector.h"
+
+#include "screenreader.h"
+#include "optionswidget.h"
+#include "accessibilityscenemanager.h"
+#include <qsgview.h>
+#include <qsgitem.h>
+#include <qdeclarativeitem.h>
+
+void MouseInterceptingGraphicsScene::mousePressEvent(QGraphicsSceneMouseEvent *event)
+{
+    emit mousePressed(event->scenePos().toPoint());
+    QGraphicsScene::mousePressEvent(event);
+}
+
+void MouseInterceptingGraphicsScene::mouseDoubleClickEvent(QGraphicsSceneMouseEvent *event)
+{
+    emit mouseDobleClicked();
+    QGraphicsScene::mouseDoubleClickEvent(event);
+}
+
+AccessibilitySceneManager *sceneManager = 0;
+QAccessible::UpdateHandler previousUpdateHandler = 0;
+bool updateHandlerRecursion = false;
+void accessibilityUpdateHandler(QObject *object, int who, QAccessible::Event reason)
+{
+    if (updateHandlerRecursion)
+        return;
+
+    if (!qobject_cast<QSGItem *>(object) && !qobject_cast<QDeclarativeItem *>(object))
+        return;
+
+    updateHandlerRecursion = true;
+
+    if (sceneManager) {
+        sceneManager->handleUpdate(object, reason);
+
+        //qDebug() << "update";
+    }
+
+    if (previousUpdateHandler) // call prev just to be sure.
+        previousUpdateHandler(object, who, reason);
+
+    updateHandlerRecursion = false;
+}
+
+AccessibilityInspector::AccessibilityInspector(QObject *parent) :
+    QObject(parent)
+{
+}
+
+AccessibilityInspector::~AccessibilityInspector()
+{
+    delete optionsWidget;
+    delete accessibilityScene;
+    delete accessibilityView;
+    delete accessibilityTreeScene;
+    delete accessibilityTreeView;
+    delete screenReader;
+}
+
+void AccessibilityInspector::inspectWindow(QWidget *window)
+{
+    optionsWidget = new OptionsWidget();
+
+    accessibilityScene = new MouseInterceptingGraphicsScene();
+
+    accessibilityView = new QGraphicsView();
+    accessibilityView->setScene(accessibilityScene);
+    accessibilityView->resize(1024, 768);
+    accessibilityView->scale(1.3, 1.3);
+
+    accessibilityTreeScene = new QGraphicsScene();
+
+    accessibilityTreeView = new QGraphicsView();
+    accessibilityTreeView->setScene(accessibilityTreeScene);
+    accessibilityTreeView->resize(1024, 768);
+
+    sceneManager = new AccessibilitySceneManager();
+    QObject::connect(optionsWidget, SIGNAL(optionsChanged()), sceneManager, SLOT(updateAccessibilitySceneItemFlags()));
+    QObject::connect(optionsWidget, SIGNAL(refreshClicked()), sceneManager, SLOT(populateAccessibilityScene()));
+    QObject::connect(optionsWidget, SIGNAL(refreshClicked()), sceneManager, SLOT(populateAccessibilityTreeScene()));
+    QObject::connect(optionsWidget, SIGNAL(scaleChanged(int)), sceneManager, SLOT(changeScale(int)));
+
+    sceneManager->setOptionsWidget(optionsWidget);
+    sceneManager->setRootWidget(window);
+    sceneManager->setScene(accessibilityScene);
+    sceneManager->setView(accessibilityView);
+    sceneManager->setTreeScene(accessibilityTreeScene);
+    sceneManager->setTreeView(accessibilityTreeView);
+
+    screenReader = new ScreenReader;
+    QObject::connect(accessibilityScene, SIGNAL(mousePressed(QPoint)), screenReader, SLOT(touchPoint(QPoint)));
+    QObject::connect(accessibilityScene, SIGNAL(mouseDobleClicked()), screenReader, SLOT(activate()));
+    QObject::connect(screenReader, SIGNAL(selected(QObject*)), sceneManager, SLOT(setSelected(QObject*)));
+    screenReader->setRootObject(window);
+    screenReader->setOptionsWidget(optionsWidget);
+
+    previousUpdateHandler = QAccessible::installUpdateHandler(accessibilityUpdateHandler);
+
+    QTimer::singleShot(100, sceneManager, SLOT(populateAccessibilityScene()));
+    QTimer::singleShot(100, sceneManager, SLOT(populateAccessibilityTreeScene()));
+
+    QSettings settings;
+    accessibilityView->restoreGeometry(settings.value("accessiblityGeometry").toByteArray());
+    accessibilityView->show();
+    accessibilityTreeView->restoreGeometry(settings.value("treeGeometry").toByteArray());
+    accessibilityTreeView->show();
+    optionsWidget->restoreGeometry(settings.value("optionsGeometry").toByteArray());
+    optionsWidget->show();
+}
+
+void AccessibilityInspector::saveWindowGeometry()
+{
+    QSettings settings;
+    settings.setValue("accessiblityGeometry", accessibilityView->saveGeometry());
+    settings.setValue("treeGeometry", accessibilityTreeView->saveGeometry());
+    settings.setValue("optionsGeometry", optionsWidget->saveGeometry());
+}
+
+QString translateRole(QAccessible::Role role)
+{
+    if (role == 0x2B)
+        return "PushButton";
+    if (role == 0x2C)
+        return "CheckBox";
+    if (role == 0x2D)
+        return "RadioButton";
+    if (role == 0xA)
+        return "Client";
+    if (role == 0x29)
+        return "Static Text";
+    if (role == 0x33)
+        return "Slider";
+    if (role == 0x33)
+        return "Slider";
+    if (role == 0x10)
+        return "Pane";
+
+    return QString::number(role, 16);
+}
+
Index: qt4-x11-4.7.4/tools/accessibilityinspector/accessibilityinspector.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ qt4-x11-4.7.4/tools/accessibilityinspector/accessibilityinspector.h	2011-09-02 13:16:17.534866119 +0200
@@ -0,0 +1,48 @@
+#ifndef ACCESSIBILITYINSPECTOR_H
+#define ACCESSIBILITYINSPECTOR_H
+
+#include <QObject>
+#include <qgraphicsscene.h>
+#include <QAccessible>
+
+QString translateRole(QAccessible::Role role);
+
+class OptionsWidget;
+class MouseInterceptingGraphicsScene;
+class QGraphicsView;
+class QGraphicsScene;
+class AccessibilitySceneManager;
+class ScreenReader;
+class AccessibilityInspector : public QObject
+{
+    Q_OBJECT
+public:
+    explicit AccessibilityInspector(QObject *parent = 0);
+    ~AccessibilityInspector();
+    void inspectWindow(QWidget *window);
+    void saveWindowGeometry();
+signals:
+
+public slots:
+
+private:
+    OptionsWidget *optionsWidget;
+    MouseInterceptingGraphicsScene *accessibilityScene;
+    QGraphicsView *accessibilityView;
+    QGraphicsScene *accessibilityTreeScene;
+    QGraphicsView *accessibilityTreeView;
+    ScreenReader *screenReader;
+};
+
+class MouseInterceptingGraphicsScene : public QGraphicsScene
+{
+Q_OBJECT
+protected:
+    virtual void mousePressEvent(QGraphicsSceneMouseEvent *event);
+    virtual void mouseDoubleClickEvent(QGraphicsSceneMouseEvent *event);
+signals:
+    void mousePressed(const QPoint point);
+    void mouseDobleClicked();
+};
+
+#endif // ACCESSIBILITYINSPECTOR_H
Index: qt4-x11-4.7.4/tools/accessibilityinspector/accessibilityinspector.pri
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ qt4-x11-4.7.4/tools/accessibilityinspector/accessibilityinspector.pri	2011-09-02 13:16:17.538866143 +0200
@@ -0,0 +1,23 @@
+QT += declarative
+CONFIG += uitools
+INCLUDEPATH += $$PWD
+
+mac {
+    # for text-to-speach
+    LIBS += -framework AppKit
+}
+
+HEADERS += \
+    $$PWD/screenreader.h \
+    $$PWD/optionswidget.h \
+    $$PWD/accessibilityscenemanager.h \
+    $$PWD/accessibilityinspector.h
+SOURCES += \
+    $$PWD/optionswidget.cpp \
+    $$PWD/accessibilityscenemanager.cpp \
+    $$PWD/screenreader.cpp \
+    $$PWD/accessibilityinspector.cpp
+
+OBJECTIVE_SOURCES += $$PWD/screenreader_mac.mm
+
+
Index: qt4-x11-4.7.4/tools/accessibilityinspector/accessibilityinspector.pro
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ qt4-x11-4.7.4/tools/accessibilityinspector/accessibilityinspector.pro	2011-09-02 13:16:17.538866143 +0200
@@ -0,0 +1,11 @@
+include (accessibilityinspector.pri)
+
+SOURCES += main.cpp \
+
+RESOURCES += \
+    testqml.qrc
+
+OTHER_FILES += \
+    phase1.qml
+
+CONFIG += console
Index: qt4-x11-4.7.4/tools/accessibilityinspector/accessibilityscenemanager.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ qt4-x11-4.7.4/tools/accessibilityinspector/accessibilityscenemanager.cpp	2011-09-02 13:16:17.538866143 +0200
@@ -0,0 +1,459 @@
+#include "accessibilityscenemanager.h"
+
+AccessibilitySceneManager::AccessibilitySceneManager()
+{
+    m_window = 0;
+    m_view = 0;
+    m_scene = 0;
+    m_rootItem = 0;
+    m_optionsWidget = 0;
+    m_selectedObject = 0;
+}
+
+void AccessibilitySceneManager::populateAccessibilityScene()
+{
+    m_scene->clear();
+    m_graphicsItems.clear();
+
+    QAccessibleInterface * rootInterface = QAccessible::queryAccessibleInterface(m_window);
+    if (!rootInterface)
+        return;
+
+    populateAccessibilityScene(rootInterface, 0, m_scene);
+}
+
+void AccessibilitySceneManager::updateAccessibilitySceneItemFlags()
+{
+    qDebug() << "update";
+    foreach (QObject *object, m_graphicsItems.keys()) {
+        if (!object)
+            continue;
+        QAccessibleInterface *interface = QAccessible::queryAccessibleInterface(object);
+        if (!interface)
+            continue;
+        updateItemFlags(m_graphicsItems.value(object), interface);
+        delete interface;
+    }
+}
+
+void AccessibilitySceneManager::populateAccessibilityTreeScene()
+{
+    m_treeScene->clear();
+    QAccessibleInterface * rootInterface = QAccessible::queryAccessibleInterface(m_window);
+    if (!rootInterface)
+        return;
+
+    populateAccessibilityTreeScene(rootInterface, 0);
+}
+
+void AccessibilitySceneManager::handleUpdate(QObject *object, QAccessible::Event reason)
+{
+    QAccessibleInterface *interface = QAccessible::queryAccessibleInterface(object);
+    if (!interface)
+        return;
+
+    QString name = interface->text(QAccessible::Name, 0);
+
+    if (reason == QAccessible::ObjectCreated) {
+  //      qDebug() << "ObjectCreated" << object << name;
+        populateAccessibilityScene(interface, 0, m_scene);
+    }
+
+    QGraphicsRectItem *item = m_graphicsItems.value(object);
+
+    if (!item) {
+//        qDebug() << "populateAccessibilityScene failed for" << object;
+        return;
+    }
+
+    if (reason == QAccessible::LocationChanged) {
+
+        //if (name.startsWith("List"))
+            qDebug() << "locationChange" << object << name << interface->rect(0);
+
+        updateItem(item, interface);
+        for (int i = 0; i < interface->childCount(); ++i) {
+           QAccessibleInterface *child = 0;
+           int ret = interface->navigate(QAccessible::Child, i + 1, &child);
+           if (ret == 0 && child) {
+               updateItem(m_graphicsItems.value(child->object()), child);
+               delete child;
+            }
+        }
+
+        delete interface;
+    } else if (reason == QAccessible::ObjectDestroyed) {
+//        qDebug() << "ObjectDestroyed" << object << name;
+        delete m_graphicsItems.value(object);
+        m_graphicsItems.remove(object);
+        m_animatedObjects.remove(object);
+        if (object == m_selectedObject) {
+            m_selectedObject = 0;
+        }
+    } else if (reason == QAccessible::ObjectHide) {
+//        qDebug() << "ObjectCreated Hide" << object;
+        updateItemFlags(item, interface);
+    } else if (reason == QAccessible::ObjectShow) {
+//        qDebug() << "ObjectCreated Show" << object;
+        updateItemFlags(item, interface);
+    } else if (reason == QAccessible::ScrollingStart) {
+        qDebug() << "ObjectCreated ScrollingStart" << object;
+        QAccessibleInterface *child = 0;
+        for (int i = 0; i < interface->childCount(); ++i) {
+            int ret = interface->navigate(QAccessible::Child, i + 1, &child);
+            if (ret == 0 && child) {
+                m_animatedObjects.insert(child->object());
+                delete child;
+            }
+        }
+    } else if (reason == QAccessible::ScrollingEnd) {
+        // qDebug() << "ObjectCreated ScrollingEnd" << object;
+        foreach (QObject *object, m_animatedObjects) {
+            updateItem(m_graphicsItems.value(object), interface);
+        }
+        delete interface;
+        m_animatedObjects.clear();
+
+    } else {
+        qDebug() << "other update" << object;
+    }
+}
+
+void AccessibilitySceneManager::setSelected(QObject *object)
+{
+    m_scene->update(); // scedule update
+
+    // clear existing selection
+    if (m_selectedObject) {
+        QObject *previousSelectedObject = m_selectedObject;
+        m_selectedObject = 0;
+        updateItem(previousSelectedObject);
+    }
+
+    m_selectedObject = object;
+    updateItem(object);
+
+    populateAccessibilityTreeScene();
+}
+
+void AccessibilitySceneManager::changeScale(int)
+{
+    // No QGraphicsView::setScale :(
+
+    //m_view->scale(scale / 10.0, scale / 10.0);
+    //if (m_rootItem)
+    //    m_view->ensureVisible(m_rootItem);
+}
+
+void AccessibilitySceneManager::updateItems(QObject *root)
+{
+    QAccessibleInterface *interface = QAccessible::queryAccessibleInterface(root);
+    if (!interface)
+        return;
+    updateItem(m_graphicsItems.value(root), interface);
+
+    QAccessibleInterface *child = 0;
+    for (int i = 0; i < interface->childCount(); ++i) {
+        int ret = interface->navigate(QAccessible::Child, i + 1, &child);
+        if (ret == 0 && child) {
+            updateItems(child->object());
+            delete child;
+        }
+    }
+    delete interface;
+}
+
+void AccessibilitySceneManager::updateItem(QObject *object)
+{
+    if (!object)
+        return;
+
+    QAccessibleInterface *interface = QAccessible::queryAccessibleInterface(object);
+    if (!interface)
+        return;
+
+    updateItem(m_graphicsItems.value(object), interface);
+
+    delete interface;
+}
+
+void AccessibilitySceneManager::updateItem(QGraphicsRectItem *item, QAccessibleInterface *interface)
+{
+    if (!item)
+        return;
+
+    QRect rect = interface->rect(0);
+    item->setPos(rect.topLeft());
+    item->setRect(QRect(QPoint(0,0), rect.size()));
+
+    updateItemFlags(item, interface);
+}
+
+void AccessibilitySceneManager::updateItemFlags(QGraphicsRectItem *item, QAccessibleInterface *interface)
+{
+  //  qDebug() << "udpateItemFlags" << interface << interface->object();
+
+    int childCount = interface->childCount();
+
+    bool shouldShow = true;
+
+    if (m_optionsWidget->hideInvisibleItems()) {
+        if (isHidden(interface)) {
+            shouldShow = false;
+        }
+    }
+
+    if (m_optionsWidget->hideOffscreenItems()) {
+        if (interface->state(0) & QAccessible::Offscreen) {
+            shouldShow = false;
+        }
+    }
+
+    if (m_optionsWidget->hidePaneItems()) {
+        if (interface->role(0) & QAccessible::Pane) {
+            shouldShow = false;
+        }
+    }
+
+    item->setVisible(shouldShow);
+
+    if (interface->object() == m_selectedObject)
+        item->setBrush(QColor(Qt::yellow));
+    else
+        item->setBrush(QColor(Qt::white));
+
+    m_view->update();
+}
+
+QGraphicsRectItem * AccessibilitySceneManager::processInterface(QAccessibleInterface * interface, int child, QGraphicsScene *scene)
+{
+    // Process this interface
+
+    QGraphicsRectItem * item = new QGraphicsRectItem();
+    scene->addItem(item);
+    if (!m_rootItem)
+        m_rootItem = item;
+
+    QString name = interface->text(QAccessibleInterface::Name, child);
+    QString description; // = interface->text(QAccessibleInterface::Description, child);
+    QString role = translateRole(interface->role(child));
+    int childCount = interface->childCount();
+
+    /* qDebug() << "name:" << name << "local pos" <<
+               interface->rect(0) << "description" << description << "childCount" << childCount;
+*/
+
+    updateItem(item, interface);
+
+    QGraphicsSimpleTextItem * textItem = new QGraphicsSimpleTextItem();
+    textItem->setParentItem(item);
+    textItem->setPos(QPoint(5, 5));
+
+    QString text;
+    text.append("Name: " + name + " ");
+    if (!description.isEmpty())
+        text.append("Description: " + description + " ");
+    text.append("Role: " + role + " ");
+    if (childCount > 0)
+        text.append("ChildCount: " + QString::number(childCount) + " ");
+    textItem->setText(text);
+
+    QFont font;
+    font.setPointSize(10);
+ //   font.setPointSize(14);
+    textItem->setFont(font);
+
+    return item;
+}
+
+void AccessibilitySceneManager::populateAccessibilityScene(QAccessibleInterface * interface, int child, QGraphicsScene *scene)
+{
+    if (!interface)
+        return;
+
+    QGraphicsRectItem *item = processInterface(interface, child, scene);
+
+    QObject *object = interface->object();
+    if (object) {
+        m_graphicsItems.insert(object, item);
+    }
+
+    // Possibly process children
+    if (child != 0)
+        return;
+
+    int childCount = interface->childCount();
+    for (int i = 0; i < childCount; ++i) {
+        QAccessibleInterface *childInterface = 0;
+        int targetChild = interface->navigate(QAccessible::Child, i + 1, &childInterface);
+        if (childInterface) {
+            populateAccessibilityScene(childInterface, targetChild, scene);
+            delete childInterface;
+        }
+    }
+}
+
+AccessibilitySceneManager::TreeItem AccessibilitySceneManager::computeLevels(QAccessibleInterface * interface, int level)
+{
+    if (interface == 0)
+        return TreeItem();
+
+    TreeItem currentLevel;
+
+    const int childCount = interface->childCount();
+    int usedChildren = 0;
+    for (int i = 1; i <= childCount; ++i) {
+        //qDebug() << "level" << level << "child" << i;
+        // Get the with of the children;
+        QAccessibleInterface *child = 0;
+        int ret = interface->navigate(QAccessible::Child, i, &child);
+        // recurse to "proper" children.
+        if (child != 0 && ret == 0) {
+            ++usedChildren;
+            TreeItem childLevel = computeLevels(child, level + 1);
+            currentLevel.children.append(childLevel);
+            currentLevel.width += childLevel.width + m_treeItemHorizontalPadding;
+            delete child;
+        }
+    }
+
+    // leaf node case
+    if (usedChildren == 0) {
+        currentLevel.width = m_treeItemWidth + m_treeItemHorizontalPadding;
+    }
+
+    // capture information:
+    currentLevel.name = interface->text(QAccessible::Name, 0);
+    currentLevel.description += interface->text(QAccessible::DebugDescription, 0);
+    currentLevel.role = translateRole(interface->role(0));
+    currentLevel.rect = interface->rect(0);
+    currentLevel.state = interface->state(0);
+    currentLevel.object = interface->object();
+
+    return currentLevel;
+}
+
+void AccessibilitySceneManager::populateAccessibilityTreeScene(QAccessibleInterface * interface, int child)
+{
+    if (!interface)
+        return;
+
+    // set some layout metrics:
+    m_treeItemWidth = 90;
+    m_treeItemHorizontalPadding = 10;
+    m_treeItemHeight = 60;
+    m_treeItemVerticalPadding = 30;
+
+    // We want to draw the accessibility hiearchy as a vertical
+    // tree, growing from the root node at the top.
+
+    // First, figure out the number of levels and the width of each level:
+    m_rootTreeItem = computeLevels(interface, 0);
+
+    // create graphics items for each tree item
+    addGraphicsItems(m_rootTreeItem, 0, 0);
+}
+
+void AccessibilitySceneManager::addGraphicsItems(AccessibilitySceneManager::TreeItem item, int row, int xPos)
+{
+    //qDebug() << "add graphics item" << row << item.name << item.role << xPos << item.width << item.children.count();
+
+    int yPos = row * (m_treeItemHeight + m_treeItemVerticalPadding);
+
+    // Process this interface
+    QGraphicsRectItem * graphicsItem = new QGraphicsRectItem();
+    graphicsItem->setPos(xPos, yPos);
+    graphicsItem->setRect(0, 0, m_treeItemWidth, m_treeItemHeight);
+    graphicsItem->setFlag(QGraphicsItem::ItemClipsChildrenToShape);
+
+    if (item.object == m_selectedObject)
+        graphicsItem->setBrush(QColor(Qt::yellow));
+    else
+        graphicsItem->setBrush(QColor(Qt::white));
+
+    if (item.state & QAccessible::Invisible) {
+        QPen linePen;
+        linePen.setStyle(Qt::DashLine);
+        graphicsItem->setPen(linePen);
+    }
+
+    m_treeScene->addItem(graphicsItem);
+
+    QGraphicsTextItem * textItem = new QGraphicsTextItem();
+    textItem->setParentItem(graphicsItem);
+    textItem->setPos(QPoint(0, 0));
+
+    QFont font;
+    font.setPointSize(8);
+    textItem->setFont(font);
+
+    QString text;
+    text += item.name + "\n";
+    text += item.role + "\n";
+    text += item.description.split(" ", QString::SkipEmptyParts).join("\n") + "\n";
+    text += "P:" + QString::number(item.rect.x()) + " " + QString::number(item.rect.y()) + " ";
+    text += "S:" + QString::number(item.rect.width()) + " " + QString::number(item.rect.height()) + "\n";
+
+    textItem->setPlainText(text);
+
+    // recurse to children
+    int childIndex = 0;
+    int childCount = item.children.count();
+    int segmentSize = item.width / qMax(1, childCount);
+    int segmentCenterOffset = segmentSize / 2;
+    int segmentsStart = xPos - (item.width / 2);
+    foreach (TreeItem child, item.children) {
+        // spread the children out, covering the width, centered on xPos
+        int segmentPosition = segmentsStart + (segmentSize * childIndex) + segmentCenterOffset;
+        addGraphicsItems(child, row + 1, segmentPosition);
+        ++childIndex;
+    }
+
+    // add lines from parents to kids
+    int boxBottom = yPos + m_treeItemHeight;
+    int boxMiddleX = xPos + m_treeItemWidth / 2;
+    int yBottomMiddle = boxBottom + m_treeItemVerticalPadding / 2;
+    int boxTop = yPos;
+    int yTopMiddle = boxTop - m_treeItemVerticalPadding / 2;
+
+    if (row > 0) {
+        QGraphicsLineItem *childVerticalStem = new QGraphicsLineItem();
+        childVerticalStem->setLine(boxMiddleX, yTopMiddle, boxMiddleX, boxTop);
+        m_treeScene->addItem(childVerticalStem);
+    }
+
+    if (childCount > 0) {
+        QGraphicsLineItem *parentVerticalStem = new QGraphicsLineItem();
+        parentVerticalStem->setLine(boxMiddleX, boxBottom, boxMiddleX, yBottomMiddle);
+        m_treeScene->addItem(parentVerticalStem);
+    }
+
+    if (childCount > 1) {
+        QGraphicsLineItem *horizontalStem = new QGraphicsLineItem();
+        // match the end points with the horizontal lines
+        int lineStartX = segmentsStart + segmentCenterOffset + m_treeItemWidth / 2;
+        int lineStopX = segmentsStart + segmentSize * (childCount -1) + segmentCenterOffset + m_treeItemWidth / 2;
+        horizontalStem->setLine(lineStartX, yBottomMiddle, lineStopX , yBottomMiddle);
+        m_treeScene->addItem(horizontalStem);
+    }
+}
+
+bool AccessibilitySceneManager::isHidden(QAccessibleInterface *interface)
+{
+    QAccessibleInterface *current = interface;
+    while (current) {
+
+        if (current->state(0) & QAccessible::Invisible) {
+            return true;
+        }
+
+        QAccessibleInterface *parent = 0;
+        current->navigate(QAccessible::Ancestor, 0, &parent);
+
+        if (current != interface)
+            delete current;
+        current = parent;
+    }
+
+    return false;
+}
Index: qt4-x11-4.7.4/tools/accessibilityinspector/accessibilityscenemanager.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ qt4-x11-4.7.4/tools/accessibilityinspector/accessibilityscenemanager.h	2011-09-02 13:16:17.538866143 +0200
@@ -0,0 +1,76 @@
+#ifndef ACCESSIBILITYSCENEMANAGER_H
+#define ACCESSIBILITYSCENEMANAGER_H
+
+#include <QtGui>
+
+#include "optionswidget.h"
+
+QString translateRole(QAccessible::Role role);
+class AccessibilitySceneManager : public QObject
+{
+Q_OBJECT
+public:
+    AccessibilitySceneManager();
+    void setRootWidget(QWidget * widget) { m_window = widget; }
+    void setView(QGraphicsView *view) { m_view = view; }
+    void setScene(QGraphicsScene *scene) { m_scene = scene; }
+    void setTreeView(QGraphicsView *treeView) { m_treeView = treeView; }
+    void setTreeScene(QGraphicsScene *treeScene) { m_treeScene = treeScene; }
+
+    void setOptionsWidget(OptionsWidget *optionsWidget) { m_optionsWidget = optionsWidget; }
+public slots:
+    void populateAccessibilityScene();
+    void updateAccessibilitySceneItemFlags();
+    void populateAccessibilityTreeScene();
+    void handleUpdate(QObject *object, QAccessible::Event reason);
+    void setSelected(QObject *object);
+
+    void changeScale(int scale);
+private:
+    void updateItems(QObject *root);
+    void updateItem(QObject *object);
+    void updateItem(QGraphicsRectItem *item, QAccessibleInterface *interface);
+    void updateItemFlags(QGraphicsRectItem *item, QAccessibleInterface *interface);
+
+    void populateAccessibilityScene(QAccessibleInterface * interface, int child, QGraphicsScene *scene);
+    QGraphicsRectItem * processInterface(QAccessibleInterface * interface, int child, QGraphicsScene *scene);
+
+    struct TreeItem;
+    TreeItem computeLevels(QAccessibleInterface * interface, int level);
+    void populateAccessibilityTreeScene(QAccessibleInterface * interface, int child);
+    void addGraphicsItems(TreeItem item, int row, int xPos);
+
+    bool isHidden(QAccessibleInterface *interface);
+
+    QWidget *m_window;
+    QGraphicsView *m_view;
+    QGraphicsScene *m_scene;
+    QGraphicsView *m_treeView;
+    QGraphicsScene *m_treeScene;
+    QGraphicsItem *m_rootItem;
+    OptionsWidget *m_optionsWidget;
+    QObject *m_selectedObject;
+
+    QHash<QObject *, QGraphicsRectItem*> m_graphicsItems;
+    QSet<QObject *> m_animatedObjects;
+
+    struct TreeItem {
+        QList<TreeItem> children;
+        int width;
+        QString name;
+        QString role;
+        QString description;
+        QRect rect;
+        QAccessible::State state;
+        QObject *object;
+        TreeItem() : width(0) {}
+    };
+
+    TreeItem m_rootTreeItem;
+    int m_treeItemWidth;
+    int m_treeItemHorizontalPadding;
+    int m_treeItemHeight;
+    int m_treeItemVerticalPadding;
+};
+
+#endif // ACCESSIBILITYSCENEMANAGER_H
Index: qt4-x11-4.7.4/tools/accessibilityinspector/main.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ qt4-x11-4.7.4/tools/accessibilityinspector/main.cpp	2011-09-02 13:16:17.538866143 +0200
@@ -0,0 +1,70 @@
+#include <QtGui>
+#include <QtDeclarative/QtDeclarative>
+#include <QtUiTools/QtUiTools>
+
+#include "accessibilityinspector.h"
+
+int main(int argc, char **argv)
+{
+    QApplication app(argc, argv);
+
+    if (app.arguments().count() < 2) {
+        qDebug() << "Usage: accessebilityInspector [ ui-file | qml-file ] [Option]";
+        qDebug() << "Option:";
+        qDebug() << "-qtquick1: Use QDeclarativeView instead of QSGView for rendering QML files";
+        return 0;
+    }
+
+    QString fileName = app.arguments().at(1);
+    QString mode;
+    if (app.arguments().count() > 2) {
+        mode = app.arguments().at(2);
+    }
+
+    QWidget *window;
+
+    if (fileName.endsWith(".ui")) {
+        QUiLoader loader;
+        QFile file(fileName);
+        file.open(QFile::ReadOnly);
+        window = loader.load(&file, 0);
+    } else if (fileName.endsWith(".qml")){
+        QUrl fileUrl;
+        if (fileName.startsWith(":")) { // detect resources.
+            QString name = fileName;
+            name.remove(0, 2); // reomve ":/"
+            fileUrl.setUrl(QLatin1String("qrc:/") + name);
+        } else {
+            fileUrl = QUrl::fromLocalFile(fileName);
+        }
+
+        if (mode == QLatin1String("-qtquick1")) {
+            QDeclarativeView * declarativeView = new QDeclarativeView();
+            declarativeView->setSource(fileUrl);
+            window = declarativeView;
+        } else {
+            QSGView * sceneGraphView = new QSGView();
+            sceneGraphView->setSource(fileUrl);
+            window = sceneGraphView;
+        }
+    } else {
+        qDebug() << "Error: don't know what to do with" << fileName;
+    }
+
+    AccessibilityInspector *accessibilityInspector = new AccessibilityInspector();
+
+    accessibilityInspector->inspectWindow(window);
+
+    window->move(50, 50);
+    window->show();
+
+    int ret = app.exec();
+
+    accessibilityInspector->saveWindowGeometry();
+    delete accessibilityInspector;
+
+    return ret;
+
+
+}
+
Index: qt4-x11-4.7.4/tools/accessibilityinspector/optionswidget.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ qt4-x11-4.7.4/tools/accessibilityinspector/optionswidget.cpp	2011-09-02 13:16:17.538866143 +0200
@@ -0,0 +1,2 @@
+#include "optionswidget.h"
+
Index: qt4-x11-4.7.4/tools/accessibilityinspector/optionswidget.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ qt4-x11-4.7.4/tools/accessibilityinspector/optionswidget.h	2011-09-02 13:16:17.538866143 +0200
@@ -0,0 +1,75 @@
+#ifndef OPTIONSWIDGET_H
+#define OPTIONSWIDGET_H
+
+#include <QtGui>
+
+class OptionsWidget : public QWidget
+{
+Q_OBJECT
+public:
+    OptionsWidget()
+        :QWidget()
+    {
+        QVBoxLayout *m_layout = new QVBoxLayout;
+
+        m_refresh = new QPushButton(this);
+        m_refresh->setText(QLatin1String("Refresh"));
+        m_layout->addWidget(m_refresh);
+        connect(m_refresh, SIGNAL(clicked()), SIGNAL(refreshClicked()));
+
+        m_hideInvisibleItems = new QCheckBox(this);
+        m_layout->addWidget(m_hideInvisibleItems);
+        m_hideInvisibleItems->setText("Hide Invisible Items");
+        m_hideInvisibleItems->setChecked(true);
+        connect(m_hideInvisibleItems, SIGNAL(toggled(bool)), SIGNAL(optionsChanged()));
+
+        m_hideOffscreenItems = new QCheckBox(this);
+        m_layout->addWidget(m_hideOffscreenItems);
+        m_hideOffscreenItems->setText("Hide Offscreen Items");
+        m_hideOffscreenItems->setChecked(true);
+        connect(m_hideOffscreenItems, SIGNAL(toggled(bool)), SIGNAL(optionsChanged()));
+
+        m_hidePaneItems = new QCheckBox(this);
+        m_layout->addWidget(m_hidePaneItems);
+        m_hidePaneItems->setText("Hide Items with the Pane role");
+        m_hidePaneItems->setChecked(true);
+        connect(m_hidePaneItems, SIGNAL(toggled(bool)), SIGNAL(optionsChanged()));
+
+        m_enableTextToSpeach = new QCheckBox(this);
+        m_layout->addWidget(m_enableTextToSpeach);
+        m_enableTextToSpeach->setText("Enable Text To Speech");
+        m_enableTextToSpeach->setChecked(false);
+        connect(m_enableTextToSpeach, SIGNAL(toggled(bool)), SIGNAL(optionsChanged()));
+
+
+        m_scale = new QSlider(Qt::Horizontal);
+//        m_layout->addWidget(m_scale);
+        m_scale->setRange(5, 30);
+        m_scale->setValue(1);
+        connect(m_scale, SIGNAL(valueChanged(int)), SIGNAL(scaleChanged(int)));
+
+        this->setLayout(m_layout);
+    }
+
+    bool hideInvisibleItems() { return m_hideInvisibleItems->isChecked(); }
+    bool hideOffscreenItems() { return m_hideOffscreenItems->isChecked(); }
+    bool hidePaneItems() { return m_hidePaneItems->isChecked(); }
+    bool enableTextToSpeach() { return m_enableTextToSpeach->isChecked(); }
+signals:
+    void optionsChanged();
+    void refreshClicked();
+    void scaleChanged(int);
+
+private:
+    QVBoxLayout *m_layout;
+
+    QPushButton *m_refresh;
+    QCheckBox *m_hideInvisibleItems;
+    QCheckBox *m_hideOffscreenItems;
+    QCheckBox *m_hidePaneItems;
+    QCheckBox *m_enableTextToSpeach;
+    QSlider *m_scale;
+};
+
+
+#endif // OPTIONSWIDGET_H
Index: qt4-x11-4.7.4/tools/accessibilityinspector/phase1.qml
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ qt4-x11-4.7.4/tools/accessibilityinspector/phase1.qml	2011-09-02 13:16:17.538866143 +0200
@@ -0,0 +1,52 @@
+import QtQuick 2.0
+
+Rectangle {
+    id : rect
+    width: 300
+    height: 200
+
+    Rectangle {
+        width : 200
+        height : 20
+
+        id: button
+        anchors.top : rect.top
+        anchors.topMargin: 30
+        property string text : "Click to activate"
+        property int counter : 0
+
+        accessibleRole : Qt.PushButton
+        function accessibleAction(action) {
+            if (action == Qt.Press)
+                buttonAction()
+        }
+
+        function buttonAction() {
+            ++counter
+            text = "clicked " + counter
+
+            text2.x += 20
+        }
+
+        Text {
+            id : text1
+            anchors.fill: parent
+            text : parent.text
+        }
+
+        MouseArea {
+            id : mouseArea
+            anchors.fill: parent
+            onClicked: parent.buttonAction()
+        }
+    }
+
+    Text {
+        id : text2
+        anchors.top: button.bottom
+        anchors.topMargin: 50
+        text : "Hello World " + x
+
+        Behavior on x { PropertyAnimation { duration: 500 } }
+    }
+}
Index: qt4-x11-4.7.4/tools/accessibilityinspector/screenreader.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ qt4-x11-4.7.4/tools/accessibilityinspector/screenreader.cpp	2011-09-02 13:16:17.538866143 +0200
@@ -0,0 +1,121 @@
+#include "screenreader.h"
+#include "optionswidget.h"
+#include "accessibilityscenemanager.h"
+#include <QtGui>
+
+#ifdef Q_OS_MAC
+#include <private/qt_mac_p.h>
+#endif
+
+ScreenReader::ScreenReader(QObject *parent) :
+    QObject(parent)
+{
+    m_selectedInterface = 0;
+    m_rootInterface = 0;
+    bool activateCalled = false;
+}
+
+ScreenReader::~ScreenReader()
+{
+    delete m_selectedInterface;
+    delete m_rootInterface;
+}
+
+void ScreenReader::setRootObject(QObject *rootObject)
+{
+    m_rootInterface = QAccessible::queryAccessibleInterface(rootObject);
+}
+
+void ScreenReader::setOptionsWidget(OptionsWidget *optionsWidget)
+{
+    m_optionsWidget = optionsWidget;
+}
+
+void ScreenReader::touchPoint(const QPoint &point)
+{
+    qDebug() << "touch" << point;
+    // Wait and see if this touch is the start of a double-tap
+    // (activate will then be called and cancel the touch processing)
+    m_activateCalled = false;
+    m_currentTouchPoint = point;
+    QTimer::singleShot(200, this, SLOT(processTouchPoint()));
+}
+
+void ScreenReader::processTouchPoint()
+{
+    if (m_activateCalled) {
+        return;
+    }
+
+    if (m_rootInterface == 0) {
+        return;
+    }
+
+    QAccessibleInterface * currentInterface = m_rootInterface;
+
+    int hit = -2;
+    int guardCounter = 0;
+    const int guardMax = 40;
+    while (hit != 0) {
+        ++guardCounter;
+        if (guardCounter > guardMax) {
+            qDebug() << "touchPoint exit recursion overflow";
+            return; // outside
+        }
+
+        hit = currentInterface->childAt(m_currentTouchPoint.x(), m_currentTouchPoint.y());
+        //qDebug() << "hit" << hit;
+        if (hit == -1) {
+            return; // outside
+        } else if (hit == 0) {
+            break; // found it.
+        } else {
+            QAccessibleInterface *childInterface = 0;
+            int child = currentInterface->navigate(QAccessible::Child, hit, &childInterface);
+            if (childInterface == 0) {
+                return; // navigation error
+            }
+
+            if (currentInterface != m_rootInterface)
+                delete currentInterface;
+            currentInterface = childInterface;
+        }
+    }
+
+    m_selectedInterface = currentInterface;
+    emit selected(m_selectedInterface->object());
+    if (m_optionsWidget->enableTextToSpeach())
+        speak(m_selectedInterface->text(QAccessible::Name, 0)
+              /*+ "," + translateRole(m_selectedInterface->role(0)) */);
+
+//    qDebug() << "touchPoint exit found" << m_selectedInterface->text(QAccessible::Name, 0) << m_selectedInterface->object() << m_selectedInterface->rect(0);
+}
+
+void ScreenReader::activate()
+{
+    qDebug() << "ScreenReader::activate";
+    m_activateCalled = true;
+    if (m_selectedInterface) {
+        m_selectedInterface->doAction(QAccessible::Press, 0);
+    }
+}
+
+#ifdef Q_OS_MAC
+
+    // screenreader.mm
+
+#else
+
+void ScreenReader::speak(const QString &text, const QString &/*voice*/)
+{
+    QFile f("festivalspeachhack");
+    f.open(QIODevice::WriteOnly);
+    f.write(text.toLocal8Bit());
+    f.close();
+
+    QProcess *process = new QProcess;
+    process->start("/usr/bin/festival", QStringList() << "--tts" << "festivalspeachhack");
+}
+
+#endif
+
Index: qt4-x11-4.7.4/tools/accessibilityinspector/screenreader.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ qt4-x11-4.7.4/tools/accessibilityinspector/screenreader.h	2011-09-02 13:16:17.538866143 +0200
@@ -0,0 +1,42 @@
+#ifndef SCREENREADER_H
+#define SCREENREADER_H
+
+#include <QObject>
+#include <QAccessible>
+#include <QAccessibleBridge>
+
+/*
+    A Simple screen reader for touch-based user interfaces.
+
+    Requires a text-to-speach backend. Currently implemented on
+    Mac OS X and using festival on unix.
+*/
+class OptionsWidget;
+class ScreenReader : public QObject
+{
+    Q_OBJECT
+public:
+    explicit ScreenReader(QObject *parent = 0);
+    ~ScreenReader();
+
+    void setRootObject(QObject *rootObject);
+    void setOptionsWidget(OptionsWidget *optionsWidget);
+public slots:
+    void touchPoint(const QPoint &point);
+    void activate();
+protected slots:
+    void processTouchPoint();
+signals:
+    void selected(QObject *object);
+
+protected:
+    void speak(const QString &text, const QString &voice = QString());
+private:
+    QAccessibleInterface *m_selectedInterface;
+    QAccessibleInterface *m_rootInterface;
+    OptionsWidget *m_optionsWidget;
+    QPoint m_currentTouchPoint;
+    bool m_activateCalled;
+};
+
+#endif // SCREENREADER_H
Index: qt4-x11-4.7.4/tools/accessibilityinspector/screenreader_mac.mm
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ qt4-x11-4.7.4/tools/accessibilityinspector/screenreader_mac.mm	2011-09-02 13:16:17.538866143 +0200
@@ -0,0 +1,19 @@
+#include "screenreader.h"
+#include <QtCore>
+#include <private/qt_mac_p.h>
+
+void ScreenReader::speak(const QString &text, const QString &voice)
+{
+    QString voiceBase = "com.apple.speech.synthesis.voice.";
+    if (voice.isEmpty())
+        voiceBase += "Vici";
+    else
+        voiceBase += voice;
+
+    CFStringRef cfVoice = QCFString::toCFStringRef(voiceBase);
+    NSSpeechSynthesizer *synth = [[NSSpeechSynthesizer alloc] initWithVoice:(NSString *)cfVoice];
+    CFStringRef cfText = QCFString::toCFStringRef(text);
+    [synth startSpeakingString: (NSString *)cfText];
+    CFRelease(cfText);
+    CFRelease(cfVoice);
+}
Index: qt4-x11-4.7.4/tools/accessibilityinspector/testqml.qrc
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ qt4-x11-4.7.4/tools/accessibilityinspector/testqml.qrc	2011-09-02 13:16:17.538866143 +0200
@@ -0,0 +1,5 @@
+<RCC>
+    <qresource prefix="/qml">
+        <file>phase1.qml</file>
+    </qresource>
+</RCC>
